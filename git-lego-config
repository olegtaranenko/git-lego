#!/usr/bin/env bash
set +o posix

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git umbrella-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'
    '${FLAGS_PREFIX} [--local|--global|--system] --lego-mode[[=| [versioned|solo] [--force|-f]' # view or set lego mode

DESCRIPTION:

EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset currentLegoMode
typeset verbose=0
typeset doForce=0
# solo (1) or global (0)
# lego solo mode means that no any additional settings are stored to versioned files like .gitmodules or .gitrepo
# That no git lego don''t pollute modules' history at all.
# Global mode as opposed keep 'lego-aware' settings into history, which can be cloned later by other repo instances.
# There are pros & cons of both solutions.
typeset nextLegoMode # string
typeset showLegoMode=0 # boolean
typeset doModeUnset=0 # boolean

# scope where git-lego setting should be saved or read
typeset scope #--local|--global|--system|-f .gitlego

# to set or get git lego parameter
typeset parameterKey parameterValue unsetParameter=0

typeset autoAttach=$(get_lego_setting "autoAttach")
autoAttach=$(READ_boolean ${autoAttach} 1) # 1 === true
#typeset doRecursive=0

typeset initialPath initialModulePath

################################ PARAMETERS PARSING ################################
#      set -x
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

		-f | --force)
			doForce=1
			;;

		--lego-mode)
			case $2 in
        '')
          showLegoMode=1
          ;;
        --unset)
          doModeUnset=1
          ;;
        --*)
			    nextLegoMode=current
          ;;
        *)
			    nextLegoMode=$2
          shift
          ;;
			esac
			;;
		--lego-mode=*)
			nextLegoMode="${1#--lego-mode=}"
			;;

    --local|--global|--system)
      scope="$1"
      ;;


    --auto-attach|-A)
      autoAttach=1
      ;;
    --no-auto-attach)
      autoAttach=0
      ;;
    --attach|-a)
      case "$2" in '') echo usage ;; esac
      attachHints+=("$2")
      shift
      ;;

#    --recursive|-r)
#      doRecursive=1
#      ;;
#    --no-recursive|-R)
#      doRecursive=0
#      ;;
    *=)
      parameterKey=${1:%%=*}
      parameterValue=${1:#*=}
      ;;
    *)
#    set -x
      notAPath=1
      if [[ -z "$initialPath" ]]; then
        initialPath="$1"
        initialModulePath=$(resolve_module_path "$initialPath" "..." "1")
        notAPath=$?

        if (( $notAPath )); then
          unset initialPath
        fi
      fi

      if (( "$notAPath" )); then
        parameterKey="$1"
        case "$2" in
          '')
            showParameter=1
          ;;
          --unset)
            unsetParameter=1
            shift
          ;;
          --*)
            showParameter=1
          ;;
          *)
            parameterValue="$2"
            shift
        esac
      fi
      ;;
  esac
#  set +x
  shift
done
#set +x

if [[ -n $nextLegoMode ]] && [[ $nextLegoMode != versioned ]] && [[ $nextLegoMode != solo ]] && [[ $nextLegoMode != current ]]; then
  die "Unrecognized option for --lego-mode options, 'solo' and 'versioned' are allowed for now"
fi

if (( ! $showLegoMode )) && [[ -z ${nextLegoMode} ]] ; then
  currentLegoMode=$( get_lego_mode )
  [[ ${currentLegoMode} == versioned ]] && versioned=1
  [[ ${currentLegoMode} == solo ]] && solo=1
fi



################################ SCRIPT SPECIFIC METHODS ################################

typeset modeTo
typeset modeFrom
typeset doReconcile=${doForce}
(( doModeUnset )) && doReconcile=0
typeset clearVersioned=0
typeset clearSolo=0
typeset copyFrom=0
typeset toVersioned=0
typeset toSolo=0

migrate_lego_mode() {
  modeTo=$1
  modeFrom=$2
  case ${modeFrom} in
    empty|'')
      (( ! doModeUnset )) && doReconcile=1
      ;;
    ambiguous)
      (( ! doModeUnset )) && doReconcile=1
      clearSolo=1
      clearVersioned=1
      ;;
    versioned)
      clearVersioned=1
      (( ! doModeUnset )) && copyFrom=1
      ;;
    solo)
      clearSolo=1
      (( ! doModeUnset )) && copyFrom=1
      ;;
  esac

  if (( ! doModeUnset )) ; then
    case ${modeTo} in
      versioned)
        toVersioned=1
        ;;
      solo)
        toSolo=1
        ;;
    esac
  else
    clearSolo=1
    clearVersioned=1
  fi


  local filePath="${globals[$G_ROOT_DIR]}"

  (( $clearSolo )) && git config --local --remove-section lego

  pushd ${filePath} &>/dev/null

  reconcile_level "${filePath}" "/"

  popd &>/dev/null

#  cat ${globals[$G_AFFECTED_MODULES]}
#  while read -a module; do
#  done < <( cat ${globals[$G_AFFECTED_MODULES]} )
}


reconcile_level() {
  local outerFilePath="$1"
  local outerPath="${2:-/}"
#
#set -x
#echo "modeFrom $modeFrom modeTo $modeTo"
  read -a outerModule < <(module_descriptor ${outerFilePath})
  local reference
  local key

  while read -a innerModule; do
    local moduleName="${innerModule[0]}"
    local moduleInnerPath="${innerModule[1]}"
    local innerFilePath="${outerFilePath}/${moduleInnerPath}"
    local section="submodule.${moduleName}"

    unset reference
    unset key

    for token in "${G_REFTYPE_TOKENS[@]}" ; do
      reference=$(get_lego_setting_mode "${token}" "$section" "${modeFrom}" )
      if (( ${#reference} )); then
        key="$token"
        break
      fi
    done

    if (( ${#key} )); then
      wipe_lego_setting_at_mode "$key" "$section" "$modeFrom"
      if (( $copyFrom )); then
        set_module_meta_mode "$key" "$reference" "$section" "." "$modeTo"
      fi

      if (( $doModeUnset )); then
        wipe_lego_setting_at_mode "$key" "$section" "$modeTo"
      fi
    fi

    local modulePath="${outerPath}"
    if [[ ${modulePath:(-1)} != "/" ]]; then
      modulePath+="/"
    fi
    modulePath+="$moduleName"

    pushd ${innerFilePath} &>/dev/null
    reconcile_level "${innerFilePath}" "${modulePath}"
    popd &>/dev/null
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
}


################################ MAIN SCRIPT LOGIC ################################
#
# callback to detect what command should be called
#
dispatch_subaction() {
  if (( $showLegoMode )) || [[ -n ${nextLegoMode} ]] || (( $doModeUnset )); then
    echo legomode
  else
    if [[ -n ${parameterKey} ]]; then
      echo parameter
    fi
  fi
}

cmd_parameter() {
  echo "$FUNCNAME() key=$parameterKey val=$parameterValue unset=$unsetParameter mode=$currentLegoMode"
  local value=${parameterValue}
}

## Just show current
cmd_legomode() {
#  echo "$FUNCNAME() setLegoMode=$nextLegoMode" >&2
  local currentMode
  local investigated
  local hint

  local doEcho=$1

  if (( $showLegoMode )) ; then
    local currentMode=$( get_lego_setting "mode")
    if [[ -z "$currentMode" ]] ; then
      investigated=$( investigate_lego_mode )
      if [[ "$investigated" == "empty" ]]; then
        unset investigated
      fi
    fi

    cw_echo "${currentMode:+Mode is explicit set to }${currentMode:-Mode not set}${investigated:+, guessing: ${investigated}}."
    if [[ -n "${investigated}" ]]; then
      if [[ "$investigated" == "ambiguous" ]] || [[ "$investigated" == "empty" ]]; then
        hint="[versioned|solo]"
      else
        hint="${investigated}"
      fi
      cw_echo "You are advised to make this settings explicitly via 'git lego config --lego-mode=$hint'"
    fi

    # get feedback if necessary
    (( "$doEcho" )) && echo "$nextLegoMode"
  else
    case "$nextLegoMode" in
      current)
        #do nothing
        ;;
      *)
###################    SET & UNSET LEGO MODE ##################
        (( $doModeUnset )) && nextLegoMode=empty
        read currentMode implicit < <( get_lego_mode 1 )
        if [[ "$currentMode" != "$nextLegoMode" ]] || (( "$implicit" )) || (( "$doModeUnset" )) || (( "$doForce" )); then

          if (( "$implicit" )) && [[ "$currentMode" == "$nextLegoMode" ]]; then
            case "$nextLegoMode" in
            solo)
              currentMode="versioned"
              ;;
            versioned)
              currentMode="solo"
              ;;
            esac

          fi
          if [[ "$currentMode" == "versioned" || "$currentMode" == "solo" ]]; then
            migrate_lego_mode ${nextLegoMode} ${currentMode}
            wipe_lego_setting_at_mode "mode" "lego" "$currentMode"
          fi

          set_module_meta_mode "mode" "$nextLegoMode" "lego" "." "$nextLegoMode"

          if (( "$doModeUnset" )) ; then
            cw_echo "Lego mode unset for ${scope:---local} scope"
          else
            cw_echo "Lego mode set to '$nextLegoMode' for ${scope:---local} scope"
          fi
        else
          if (( "$doModeUnset" )) ; then
            cw_echo "Lego mode not yet set."
          else
            cw_echo "Lego mode is already set to $nextLegoMode."
          fi
        fi
        ;;
    esac
  fi
}


#set -x
cmd_default() {
  typeset modulePath=$(resolve_module_path "${initialPath}" "/")
  read moduleName filePath < <(module_info "${modulePath}" "name" "path")
  typeset dieMsg
  typeset skippedModules=()
  typeset affected=0
  typeset vetoed=0
  typeset affected_module=0

#  pushd ${filePath} &>/dev/null
#  cd ${filePath}



#  if (( $affected )); then
#
#    while read -a module; do
#      cd ${module[$MFS_FULL_PATH]}
#      level_verbose_about_to ${module[@]}
#
#      git reset "${args[@]}"
#    done < <(cat ${globals[$G_AFFECTED_MODULES]} | (tac 2> /dev/null || tail -r))
#  fi
#
#  if (( ${#skippedModules} )); then
#    cw_echo "Not affected modules: ${skippedModules[*]}"
#  fi

#  popd &>/dev/null
  umbrella_finalize

#  exit $ret
}