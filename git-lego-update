#!/usr/bin/env bash
set +o posix

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git umbrella-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'
    '${FLAGS_PREFIX} [--local|--global|--system] --lego-mode[[=| [versioned|solo] [--force|-f]' # view or set lego mode

DESCRIPTION:

EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset verbose=0
typeset afterDash=()
typeset stopOptions=0
typeset initialPath updateMessage updateTemplate doRecursive=1  doForce=1 

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force)
      doForce=0
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done
#set +x


################################ SCRIPT SPECIFIC METHODS ################################
update_level() {
#echo "$FUNCNAME()" $@ >&2
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local modulePath="$3"
  local parentFullPath=$4
  local repoBranch
  local ret=0   # return code
  local childRet # child return code

  if [[ $modulePath != / ]]; then
    module_porcelain_status "${modulePath}" update
    local uninitialized=${MODULE_STATUS[$MS_UNINITIALIZED]}
    local unmanaged=${MODULE_STATUS[$MS_UNMANAGED]}
    local applied=0

    drop_to_affected "$levelPath"
    if (( ! $? )) ; then
      applied=1
      if (( ! $unmanaged )) || (( $doForce )); then
        pushd "${parentFullPath}" >/dev/null
        if (( $uninitialized )); then
          cw_echo "About to update module $moduleName..."
          git submodule update --init -- "${moduleName}"
          (( ! $? )) && cw_echo "...OK!"
        fi
        popd >/dev/null
        if (( ! $unmanaged )) ; then
          local managedRefname=${MODULE_STATUS[$MS_MANAGED_REFNAME]}
          if [[ -n "${managedRefname}" ]] ; then
            cw_echo "About to checkout module $managedRefname for $moduleName..."
            git checkout "${managedRefname}"
            (( ! $? )) && cw_echo "...OK!"
          fi
        fi
      fi
    fi
  fi


  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      moduleName="${module[0]}"
      localPath="${module[1]}"
      subRepoPath="${levelPath}"/"${localPath}"

      local modulePath="$3"
      if [[ ${modulePath:(-1)} != "/" ]]; then
        modulePath+="/"
      fi
      modulePath+="$moduleName"

      pushd "${subRepoPath}" &> /dev/null
      update_level "${subRepoPath}" "${moduleName}" "${modulePath}" "$levelPath"
      childRet=$?

      (( $childRet > $ret )) && ret = ${childRet}
      popd  &> /dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi
}


################################ MAIN SCRIPT LOGIC ################################
#
# callback to detect what command should be called
#
#dispatch_subaction() {
#  echo update
#}

cmd_default() {
  typeset modulePath=$(resolve_module_path "${initialPath}" ".")
  read moduleName moduleFilePath < <(module_info "${modulePath}" "name" "path")

  typeset affected=0
  typeset onEmptyMessage
  typeset skippedModules=()
#  [[ -z ${updateMessage} ]] && onEmptyMessage="update for umbrella ${globals[$G_ROOT_NAME]}, affected modules: "

  pushd ${moduleFilePath} &>/dev/null
  update_level "${moduleFilePath}" "${moduleName}" "${modulePath}"

  popd &>/dev/null
  umbrella_finalize
}