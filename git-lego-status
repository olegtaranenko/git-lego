#!/usr/bin/env bash

set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #

declare ret=0

args=()

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ SCRIPT-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git lego-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [<any-git-status-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset verbose=0
typeset initialPath
typeset afterDash=()
typeset stopOptions=0
#set -x
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;
    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath="$1"
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done

#echo "args: ${args}"
#set +x


################################ SCRIPT SPECIFIC METHODS ################################

#
## Print status in format
# ... (tbd)
## Parameters
#   $1 file path to module toplevel
#   $2 path to the enclosed module in module hierarchy
#   $3 module name
#
##  Globals settings.
#     $quiet ??
#
##  Side effects to globals.
#     $commitable - sets to 1, if one of affected module has dirty state, required to be commit
# .
#
typeset oneLine

function show_current_module_status {
#echo "$FUNCNAME(): subRepoPath=$1 subModule=$2 modulePath=$3 initialized=$4 stickOnBranch$5 managed=$6" >&2
#printf "%s,\n" "${MODULE_STATUS[@]}"
  local filePath="$1"
  local moduleName="$2"
  local modulePath="$3"
  local verboseMsg=([1]="path: $filePath")

#  [[ $moduleName == macosx ]] && set -x

  oneLine="$modulePath"
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local verboseIssues infoIssues

  # gather all additional fine information into $MODULE_STATUS global array
#  [[ $modulePath == / ]] && set -x
  module_porcelain_status "${modulePath}" status
#  [[ $modulePath == / ]] && set +x

  # two below variables are defined to cmd_default()
  (( ${MODULE_STATUS[$MS_DETACHED]} )) && detached=${MODULE_STATUS[$MS_DETACHED]}
  (( ${MODULE_STATUS[$MS_COMMITABLE]} )) && commitable=${MODULE_STATUS[$MS_COMMITABLE]}

  local branchInfo=${MODULE_STATUS[$MS_BRANCH_INFO]}
  [[ -n ${branchInfo} ]] && [[ $branchInfo != HEAD ]] && oneLine+=", ${branchInfo}"

  if (( ${MODULE_STATUS[$MS_MODIFIED_SUBMODULE]} )); then
    verboseIssues+="${verboseIssues:+ ,}modified (${MODULE_STATUS[$MS_MODIFIED_SUBMODULE]} files)"
    infoIssues+="${infoIssues:+, }Sx${MODULE_STATUS[$MS_MODIFIED_SUBMODULE]}"
  fi
  if (( ${MODULE_STATUS[$MS_MODIFIED]} )); then
    verboseIssues+="${verboseIssues:+ ,}modified (${MODULE_STATUS[$MS_MODIFIED]} files)"
    infoIssues+="${infoIssues:+, }Mx${MODULE_STATUS[$MS_MODIFIED]}"
  fi
  if (( ${MODULE_STATUS[$MS_ADDED]} )); then
    verboseIssues+="${verboseIssues:+ ,}added (${MODULE_STATUS[$MS_ADDED]} files)"
    infoIssues+="${infoIssues:+, }Ax${MODULE_STATUS[$MS_ADDED]}"
  fi
  if (( ${MODULE_STATUS[$MS_DELETED]} )); then
    verboseIssues+="${verboseIssues:+ ,}deleted (${MODULE_STATUS[$MS_DELETED]} files)"
    infoIssues+="${infoIssues:+, }Dx${MODULE_STATUS[$MS_DELETED]}"
  fi
  if (( ${MODULE_STATUS[$MS_RENAMED]} )); then
    verboseIssues+="${verboseIssues:+ ,}renamed (${MODULE_STATUS[$MS_RENAMED]} files)"
    infoIssues+="${infoIssues:+, }Rx${MODULE_STATUS[$MS_RENAMED]}"
  fi
  if (( ${MODULE_STATUS[$MS_COPIED]} )); then
    verboseIssues+="${verboseIssues:+ ,}copied (${MODULE_STATUS[$MS_COPIED]} files)"
    infoIssues+="${infoIssues:+, }Cx${MODULE_STATUS[$MS_COPIED]}"
  fi
  if (( ${MODULE_STATUS[$MS_UNMERGED]} )); then
    verboseIssues+="${verboseIssues:+ ,}unmerged (${MODULE_STATUS[$MS_UNMERGED]} files)"
    infoIssues+="${infoIssues:+, }Ux${MODULE_STATUS[$MS_UNMERGED]}"
  fi
  if (( ${MODULE_STATUS[$MS_UNTRACKED]} )); then
    verboseIssues+="${verboseIssues:+ ,}untracked (${MODULE_STATUS[$MS_UNTRACKED]} files)"
    infoIssues+="${infoIssues:+, }Nx${MODULE_STATUS[$MS_UNTRACKED]}"
  fi

  local uninitialized=${MODULE_STATUS[$MS_UNINITIALIZED]}
  local mismatched=${MODULE_STATUS[$MS_MISMATCHED]}
  local detached=${MODULE_STATUS[$MS_DETACHED]}
  local managed=${MODULE_STATUS[$MS_MANAGED]}
  local unmanaged=${MODULE_STATUS[$MS_UNMANAGED]}
  local managedRefname=${MODULE_STATUS[$MS_MANAGED_REFNAME]}
  local moduleRefname=${MODULE_STATUS[$MS_MODULE_REFNAME]}

  if (( $uninitialized )); then
    oneLine+=", not initialized"
    verboseMsg+=("The module not initialized yet. 'git-lego init --reconcile' to fix it.")

    if (( ! $unmanaged )); then
      case $managed in
        0)
          oneLine+=", managed${managedRefname:+ as $managedRefname}"
          ;;
        1|2)
          oneLine+=", pinned${managedRefname:+ to $managedRefname}"
          ;;
      esac

      verboseMsg+=("Expected, that module should be initialized to $managedRefname")
    fi

  else    ## (( initialized ))

    local managedAlias
    if (( ! $detached )); then
      oneLine+=", $moduleRefname${MODULE_STATUS[$MS_UPSTREAM]:+...${MODULE_STATUS[$MS_UPSTREAM]}}"
      local commits=0
      if (( MODULE_STATUS[$MS_UPSTREAM_AHEAD] )) ; then oneLine+=", ${MODULE_STATUS[$MS_UPSTREAM_AHEAD]} ahead"; commits=1; fi
      if (( MODULE_STATUS[$MS_UPSTREAM_BEHIND] )); then oneLine+=", ${MODULE_STATUS[$MS_UPSTREAM_BEHIND]} behind"; commits=1; fi
      (( $commits )) && oneLine+=" commit(s)"
  #      (( $commits - 1 )) && oneLine+="s"
    else
      oneLine+=", detached: $moduleRefname"
      if (( ! $unmanaged )) && [[ $modulePath != "/" ]]; then
        case $managed in
          0)
            managedAlias+='managed as'
            ;;
          1|2)
            managedAlias+='pinned to'
            ;;
        esac
      fi
    fi
    if (( ! ${mismatched:-0} )) && (( ! $unmanaged )) && [[ $modulePath != / ]]; then
      oneLine+=", OK"
    elif (( ${mismatched:-0} )); then
      oneLine+=", mismatched, expected: $managedAlias $managedRefname"
      if (( $detached > 0 )); then
        local ahead=${MODULE_STATUS[$MS_UPSTREAM_AHEAD]}
        local behind=${MODULE_STATUS[$MS_UPSTREAM_BEHIND]}

        if (( $ahead )) ; then oneLine+=", $ahead commit"; (( $ahead > 1 )) && oneLine+="s"; oneLine+=" ahead";
        elif (( $behind )) ; then oneLine+=", $behind commit"; (( $behind > 1 )) && oneLine+="s"; oneLine+=" behind"; fi
      fi
      # TODO verboseMsg

  #      (( $commits - 1 )) && oneLine+="s"

    fi

    if (( $unmanaged )); then
      oneLine+=", unmanaged"
  #      TODO verboseMsg+=("You need to run either 'git-lego checkout <branch-name>' or 'git-lego init [--reconcile|--pin]' to make those consent.")

    fi

#    if [[ -n ${MODULE_STATUS[$MS_MANAGED_REFNAME]} ]]; then
#      oneLine+="${MODULE_STATUS[$MS_MANAGED_REFNAME]:+, expected:${MODULE_STATUS[$MS_MANAGED_REFNAME]}}"
#      verboseMsg+=("Expected, that module should be initialized to ${MODULE_STATUS[$MS_MANAGED_REFNAME]}")
#    fi

    if (( $mismatched )) || (( $unmanaged )) ; then
      if (( $detached )); then
        if [[ -n ${MODULE_STATUS[$MS_GUESSED_BRANCHES]} ]]; then
          oneLine+=", attainable to: ${MODULE_STATUS[$MS_GUESSED_BRANCHES]}"
        fi

        if [[ -n ${MODULE_STATUS[$MS_GUESSED_TAGS]} ]]; then
          oneLine+=", pinnable to: ${MODULE_STATUS[$MS_GUESSED_TAGS]}"
        fi
      fi
    fi

    if (( ${#infoIssues} )) ; then
      verboseIssues="issues: "$verboseIssues" paths"
      verboseMsg+=("${verboseIssues}")
      oneLine+=", dirty: "${infoIssues}
    fi

  fi     ##(( $uninitialized ))

  verboseMsg[0]=${oneLine}
  cw_echo "${verboseMsg[@]}"

  if (( $verbose > 1 )) && [ -n ${args} ]; then
    git status ${args}
  fi
#  set +x
}



function status_level() {
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is synchronized
  local childRet # child return code

  drop_to_affected ${levelPath}

  (( ! $? )) && show_current_module_status "$@"

  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      subModule="${module[0]}"
      localPath="${module[1]}"
      subRepoPath=${levelPath}/${localPath}

      pushd "${subRepoPath}" &>/dev/null
      local modulePath="$3" #/$subModule"
      if [[ ${modulePath:(-1)} != "/" ]]; then
        modulePath+="/"
      fi
      modulePath+="$subModule"

      status_level "${subRepoPath}" "${subModule}" "${modulePath}"
      childRet=$?
      if [[ ${childRet} > ${ret} ]] ; then
        ret=${childRet}
      fi
      popd  &>/dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  return $ret
}


################################ MAIN SCRIPT LOGIC ################################
cmd_default() {

  # 'cumulative variables, if any of module hits.
  local commitable
  local detached

  local modulePath=$(resolve_module_path "${initialPath}" /)
  read moduleName path < <(module_info "${modulePath}" "name" "path")

  pushd ${path} &>/dev/null
  #baseModulePath=$(_m_pmd)
  status_level "${path}" "${moduleName}" "${modulePath}"
  ret=$?

  if (( $commitable )); then
    msg="You have to COMMIT current changes ('git-lego commit --help' for more information)"
    if (( $detached )); then
      msg2+="One (or more) module(s) DETACHED ('git-lego branch --help' for more information)"
  #    msg2="Your are advised to run CW 'branch ... <branch-name>' command before doing commit"
    fi
    msg+="."
    cw_cr
    cw_echo "${msg}"
    [[ -n ${msg2} ]] && cw_echo "${msg2}"
    (( ! $verbose )) && cw_echo "'${FLAGS_PREFIX} -v ' option to get output more verbose or '${FLAGS_PREFIX} --help for other options'"
    cw_cr
  fi

  popd &>/dev/null

  umbrella_finalize
  exit ${ret}
}
