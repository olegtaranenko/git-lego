#!/usr/bin/env bash

set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #

declare ret=0

args=()

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ SCRIPT-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} in git lego-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [<any-git-status-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset verbose=0
typeset initialPath
typeset modulePath
typeset moduleName
typeset moduleFilePath

typeset afterDash=()
typeset stopOptions=0

# TODO add setting 
typeset doHintOptions=0
#set -x
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --hint|-t)
      doHintOptions=1
      ;;
    --no-hint|-T)
      doHintOptions=0
      ;;

    --)
      stopOptions=1
      ;;
    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath="$1"
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done

#echo "args: ${args}"
#set +x


################################ SCRIPT SPECIFIC METHODS ################################

#
## Print status in format
# ... (tbd)
## Parameters
#   $1 file path to module toplevel
#   $2 path to the enclosed module in module hierarchy
#   $3 module name
#
##  Globals settings.
#     $quiet ??
#
##  Side effects to globals.
#     $commitable - sets to 1, if one of affected module has dirty state, required to be commit
# .
#
typeset oneLine


managed_or_pinned() {
#echo "$FUNCNAME()" $@ >&2
  local result=""
  local refinedName
  local managedRefname="$2" 
  local moduleRefname="$3" 
  local detached="$4"

  if [[ "$detached" > 0 ]]; then
#    set -x
    result+=", detached: $moduleRefname"
  fi
  
  if [[ -n "$managedRefname" ]]; then
    case "$1" in
      0)
        result+=", managed${managedRefname:+ as $managedRefname}"
        ;;
      1|2)
        refinedName="${managedRefname#refs/tags/}"
        result+=", pinned${refinedName:+ to $refinedName}"
        ;;
    esac
  fi

  echo "$result"
}


function show_current_module_status {
#echo "$FUNCNAME()" $@ >&2
#echo "$FUNCNAME(): subRepoPath=$1 subModule=$2 modulePath=$3 refname=$4 reftype=$5 " >&2
#printf "%s,\n" "${MODULE_STATUS[@]}"

#if [[ $2 == "viatra" ]]; then
#  set -x
#fi
  local filePath="$1"
  local moduleName="$2"
  local modulePath="$3"
  local parentRefname="$4"
  local parentReftype="$5"

  local verboseMsg=([1]="path: $filePath")
  oneLine="$modulePath"
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local verboseIssues infoIssues

  # gather all additional fine information into $MODULE_STATUS global array
  module_porcelain_status "$modulePath" status

  # two below variables are defined to cmd_default()
  (( "${MODULE_STATUS[$MS_DETACHED]}" )) && detached="${MODULE_STATUS[$MS_DETACHED]}"
  (( "${MODULE_STATUS[$MS_COMMITABLE]}" )) && commitable="${MODULE_STATUS[$MS_COMMITABLE]}"

  local branchInfo="${MODULE_STATUS[$MS_BRANCH_INFO]}"
  [[ -n "$branchInfo" ]] && [[ "$branchInfo" != "HEAD" ]] && oneLine+=", $branchInfo"

  if (( "${MODULE_STATUS[$MS_MODIFIED_SUBMODULE]}" )); then
    verboseIssues+="${verboseIssues:+ ,}modified (${MODULE_STATUS[$MS_MODIFIED_SUBMODULE]} files)"
    infoIssues+="${infoIssues:+, }Sx${MODULE_STATUS[$MS_MODIFIED_SUBMODULE]}"
  fi
  if (( "${MODULE_STATUS[$MS_MODIFIED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}modified (${MODULE_STATUS[$MS_MODIFIED]} files)"
    infoIssues+="${infoIssues:+, }Mx${MODULE_STATUS[$MS_MODIFIED]}"
  fi
  if (( "${MODULE_STATUS[$MS_ADDED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}added (${MODULE_STATUS[$MS_ADDED]} files)"
    infoIssues+="${infoIssues:+, }Ax${MODULE_STATUS[$MS_ADDED]}"
  fi
  if (( "${MODULE_STATUS[$MS_DELETED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}deleted (${MODULE_STATUS[$MS_DELETED]} files)"
    infoIssues+="${infoIssues:+, }Dx${MODULE_STATUS[$MS_DELETED]}"
  fi
  if (( "${MODULE_STATUS[$MS_RENAMED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}renamed (${MODULE_STATUS[$MS_RENAMED]} files)"
    infoIssues+="${infoIssues:+, }Rx${MODULE_STATUS[$MS_RENAMED]}"
  fi
  if (( "${MODULE_STATUS[$MS_COPIED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}copied (${MODULE_STATUS[$MS_COPIED]} files)"
    infoIssues+="${infoIssues:+, }Cx${MODULE_STATUS[$MS_COPIED]}"
  fi
  if (( "${MODULE_STATUS[$MS_UNMERGED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}unmerged (${MODULE_STATUS[$MS_UNMERGED]} files)"
    infoIssues+="${infoIssues:+, }Ux${MODULE_STATUS[$MS_UNMERGED]}"
  fi
  if (( "${MODULE_STATUS[$MS_UNTRACKED]}" )); then
    verboseIssues+="${verboseIssues:+ ,}untracked (${MODULE_STATUS[$MS_UNTRACKED]} files)"
    infoIssues+="${infoIssues:+, }Nx${MODULE_STATUS[$MS_UNTRACKED]}"
  fi

#echo ${MODULE_STATUS[*]} >&2
#set -x

  local uninitialized="${MODULE_STATUS[$MS_UNINITIALIZED]}"
  local mismatched="${MODULE_STATUS[$MS_MISMATCHED]}"
  local detached="${MODULE_STATUS[$MS_DETACHED]}"
#  local unreachable="${MODULE_STATUS[$MS_UNREACHABLE]}"
#  local dangled="${MODULE_STATUS[$MS_DANGLED]}"
  local detachedFrom="${MODULE_STATUS[$MS_DETACHED_FROM]}"
  local managedIndex="${MODULE_STATUS[$MS_MANAGED_REFTYPE]}"
  local unmanaged="${MODULE_STATUS[$MS_UNMANAGED]}"
  local managedRefname="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
  local moduleRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"

  local ahead="${MODULE_STATUS[$MS_UPSTREAM_AHEAD]}"
  local behind="${MODULE_STATUS[$MS_UPSTREAM_BEHIND]}"
#set +x

  if (( "$uninitialized" )); then
    oneLine+=", not initialized"
#    verboseMsg+=("The module not initialized yet. 'git-lego init --reconcile' to fix it.")
    if (( ! "$unmanaged" )); then
      oneLine+=$( managed_or_pinned "$managedIndex" "$managedRefname" )
      verboseMsg+=("Expected, that module should be initialized to $managedRefname")
    fi
  else    ## of  (( uninitialized ))
    if (( ! "$detached" )); then
      local upstream="${MODULE_STATUS[$MS_UPSTREAM]}"
      oneLine+=", $moduleRefname${upstream:+...$upstream}"
    else
      oneLine+=$( managed_or_pinned "$managedIndex" "$managedRefname" "$moduleRefname" "$detached")
    fi

#    if [[ -n "$dangled" ]] ; then
#      oneLine+=", dangled"
#    fi
    if [[ -n "$detachedFrom" && "${mismatched:-0}" == 1 ]]; then
      oneLine+=", dangled from $detachedFrom"
    fi

    if (( "$unmanaged" )); then
      oneLine+=", unmanaged"
  #      TODO verboseMsg+=("")
    else
      if (( ! "${mismatched:-0}" )) && [[ "$modulePath" != "/" ]] ; then
        oneLine+=", OK"
      elif (( "${mismatched:-0}" )) ; then
        oneLine+=", mismatched"

        if (( ! "$detached" )); then
          oneLine+=", expected: $managedRefname"
        fi
        # TODO verboseMsg
      fi
    fi

    if (( "$ahead" )) ; then
      oneLine+=", $ahead commit"
      (( "$ahead" > 1 )) && oneLine+="s"
      oneLine+=" ahead";
    fi

    if (( "$behind" )) ; then
      oneLine+=", $behind commit"
      (( "$behind" > 1 )) && oneLine+="s"
      oneLine+=" behind";
    fi

    if (( "$doHintOptions" )); then
      local guessedRefnames=()
      local asWellRefs=()
      local oldIFS

      if [[ -n ${MODULE_STATUS[$MS_GUESSED_BRANCHES]} ]]; then
        asWellRefs=()
        if [[ -n "$managedIndex" ]] && (( ! "$managedIndex" )); then
          guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
          calculate_as_well_refnames "$managedRefname"
        else
          asWellRefs=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
        fi
        if (( "${#asWellRefs[@]}" )); then
          oldIFS=$IFS; IFS=","
          oneLine+=", attainable to: ${asWellRefs[*]}"
          IFS=$oldIFS

        fi
      fi

      if [[ -n ${MODULE_STATUS[$MS_GUESSED_TAGS]} ]]; then
        asWellRefs=()
        if [[ -n "$managedIndex" ]] && (( "$managedIndex" )); then
          guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
          calculate_as_well_refnames "$managedRefname"
        else
          asWellRefs=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
        fi
        if (( "${#asWellRefs[@]}" )); then
          oldIFS=$IFS; IFS=","
          oneLine+=", pinnable to: ${asWellRefs[*]}"
          IFS=$oldIFS
        fi
      fi
    fi

    ## show updatable hint
    if [[ ("$parentReftype" == 0 || "$parentReftype" == "branch" ) && -n "$parentRefname" && "$parentRefname" != "$moduleRefname" ]]; then

      read isCorrect normalizedRefname isRemote isBranch isTag < <( is_revision_correct "$parentRefname" 1 )

      if (( "$isCorrect" )) && (( "$isBranch" )) && [[ "$modulePath" != "/" ]]; then
        oneLine+=", updatable to $parentRefname"

        read a b < <(calculate_ab_for_branch "$normalizedRefname")
        oneLine+=" ["
        if (( "$isRemote" )); then
          oneLine+="$normalizedRefname:"
        fi
        oneLine+=" $a $b commit(s)]"
      fi
    fi

    if (( "${#infoIssues}" )) ; then
      verboseIssues="issues: $verboseIssues paths"
      verboseMsg+=("$verboseIssues")
      oneLine+=", dirty: $infoIssues"
    fi
  fi     ##(( $uninitialized ))

  verboseMsg[0]=${oneLine}
  cw_echo "${verboseMsg[@]}"

  if (( $verbose > 1 )) && [ -n ${args} ]; then
    git status ${args}
  fi

#if [[ $2 == "viatra" ]]; then
#  set +x
#fi
}



function status_level() {
#echo "$FUNCNAME()" $@ >&2
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is synchronized
  local childRet # child return code
#if [[ $modulePath == /ext ]]; then
#set -x
#fi
  drop_to_affected "$levelPath"

  (( ! $? )) && show_current_module_status "$@"
  local managedRefname="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
  local moduleRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
  local moduleReftype="${MODULE_STATUS[$MS_DETACHED]}"
#  echo "$FUNCNAME()... parent managed=$managedRefname parent moduleRefname=$moduleRefname, moduleReftype=$moduleReftype "


  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      subModule="${module[0]}"
      localPath="${module[1]}"
      subRepoPath="$levelPath/$localPath"

      pushd "$subRepoPath" &>/dev/null
      ret=$?

      if (( ! "$ret" )); then
        local modulePath="$3" #/$subModule"
        [[ ${modulePath:(-1)} != "/" ]] && modulePath+="/"
        modulePath+="$subModule"

        status_level "$subRepoPath" "$subModule" "$modulePath" "$moduleRefname" "$moduleReftype"
        childRet=$?
        if [[ "$childRet" > $ret ]] ; then
          ret=${childRet}
        fi
        popd  &>/dev/null
      fi
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  return $ret
}

default_init_path_callback() {
  echo "/";
}

default_pinned_policy() {
  echo 0
}

################################ MAIN SCRIPT LOGIC ################################
cmd_default() {

  # 'cumulative variables, if any of module hits.
  local commitable
  local detached

#  local parentRefType parentRefName

  cd "$moduleFilePath"

  if [[ "$modulePath" != "/" ]]; then
    pushd "$moduleFilePath" &>/dev/null
    module_up
  fi

  read parentRefName parentRefType < <( evaluate_refname )

  if [[ "$modulePath" != "/" ]]; then
    popd &>/dev/null
  fi

  pushd ${moduleFilePath} &>/dev/null
  status_level "$moduleFilePath" "$moduleName" "$modulePath" "$parentRefName" "$parentRefType"
  ret=$?

  if (( $commitable )); then
    msg="You have to COMMIT current changes ('git-lego commit --help' for more information)"
    if (( $detached )); then
      msg2+="One (or more) module(s) DETACHED ('git-lego branch --help' for more information)"
  #    msg2="Your are advised to run CW 'branch ... <branch-name>' command before doing commit"
    fi
    msg+="."
    cw_cr
    cw_echo "$msg"
    [[ -n ${msg2} ]] && cw_echo "$msg2"
    (( ! $verbose )) && cw_echo "'${FLAGS_PREFIX} -v ' option to get output more verbose or '${FLAGS_PREFIX} --help for other options'"
    cw_cr
  fi

  popd &>/dev/null

  umbrella_finalize
  exit "$ret"
}
