#!/usr/bin/env bash
set +o posix
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git umbrella-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [<any-git-status-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset args=()
typeset verbose=0
typeset doRecursive=1
typeset doUpstream=1
typeset doForce=0

typeset initialPath
typeset modulePath
typeset moduleName
typeset moduleFilePath
typeset moduleInitialized
typeset moduleGitDir

typeset initialPath
typeset afterDash=()
typeset stopOptions=0
typeset fetchBefore=0
typeset pushAllTags=0
typeset remoteParam branchParam
typeset explicitTagName wrongTag=0

typeset doFixDangled=0
typeset dangledBranch="__detached__"
typeset dangledModules=()
typeset dangledRefs=()
typeset tagsModules=()
typeset noUpstreamModules=()
typeset noUpstreamBranches=()
typeset plainPushModules=()
typeset remoteExplicitTagModules=()

typeset legoRemote="${globals[$G_LEGO_REMOTE]}"
################################ PARAMETERS PARSING ################################
#set -x
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --create-upstream|-u)
      doUpstream=1
      ;;
    --no-create-upstream|-U)
      doUpstream=0
      ;;

    --force|-f)
      doForce=1
#      args+=("$1")
      ;;
    --no-force)
      doForce=0
      ;;

    --fetch)
      fetchBefore=1
      ;;
    --no-fetch)
      fetchBefore=0
      ;;

    --tags|--mirror)
      doRecursive=1
      doForce=1
      if [[ "$1" == "--tags" ]]; then
        pushAllTags=1
      fi
      ;;

		--tag)
			case $2 in
        '' | -*)
          wrongTag=1
          ;;
        *)
			    explicitTagName="$2"
          shift
          ;;
			esac
			;;
		--tag=*)
			explicitTagName="${1#--tag=}"
			;;

    --fix-dangled|-d)
      doFixDangled=1
      ;;
    --no-fix-dangled|-D)
      doFixDangled=0
      ;;
    --fix-dangled=*)
      dangledBranch="${1#*=}"
# TODO check if branch name, given in parameters for fix dangled commits does not exists
      ;;

    --)
      stopOptions=1
      ;;
    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=("$1")
      elif [[ -z "$initialPath" ]]; then
        initialPath="$1"
      elif [[ -z "$remoteParam" ]]; then
        remoteParam="$1"
      elif [[ -z "$branchParam" ]]; then
        branchParam="$1"
      else
        die "unknown parameter: '$1'"
      fi
      ;;
  esac
  shift
done

if [[ -n "$remoteParam" || -n "$branchParam" ]]; then
  die "Parameters possible remote and/or branch not supported by git-lego"
fi

if (( "$wrongTag" )); then
  die "Wrong tag name"
fi

if [[ -n "$explicitTagName" && "$pushAllTags" == 1 ]]; then
  die "Options --tag=$explicitTagName and --tags are not compatible"
fi

echo "args: ${args[@]}"


################################ SCRIPT SPECIFIC METHODS ################################
#
# Returns
#     0 - module not requires push or pushable and listed as affected
#     1 - module is pushable, but not listed as affected
#     2 - module is not pushable (requires pull/fetch/merge) or detached
#

function prepare_push_level() {
#echo "$FUNCNAME() $@" >&2; pwd >&2

  local levelPath="$1"
  [[ -z "$levelPath" ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local modulePath="$3"
  local ret=0
  local childRet # child modules return code

  if (( "$fetchBefore" )); then
    cw_verbose "About to fetch from remote..."
    if (( "$verbose" )); then
      git fetch
    else
      git fetch &> /dev/null
    fi
    (( $? )) && panic "Something wrong with git fetch"
  fi

  module_porcelain_status "$modulePath" "push"

  local notApplied=1

  local moduleRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
  local detached="${MODULE_STATUS[$MS_DETACHED]}"
  local mismatched="${MODULE_STATUS[$MS_MISMATCHED]}"

  local managedRefname="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
  local managedReftype="${MODULE_STATUS[$MS_MANAGED_REFTYPE]}"
  local upstream="${MODULE_STATUS[$MS_UPSTREAM]}"
  local upstreamAhead="${MODULE_STATUS[$MS_UPSTREAM_AHEAD]}"
  local detachedFrom="${MODULE_STATUS[$MS_DETACHED_FROM]}"

  local checkDropAffected=0
  local tagsAlreadyAdded=0

  if [[ -z "$upstream" && "$detached" == 0 ]]; then
    if [[ "$doUpstream" == 1 ]]; then
      noUpstreamModules+=("$moduleName")
      noUpstreamBranches+=("$moduleRefname")
      checkDropAffected=1
    else
      ret=1
      dieMsg="'$moduleName' module has no upstream "
    fi
  elif [[ "$upstreamAhead" > 0  && ("$detached" == 0  || "$doForce" == 1 ) ]]; then
    checkDropAffected=1
    if [[ -n "$detachedFrom" && "$detached" > 0 && "$managedReftype" == 1 && "$mismatched" == 1 ]]; then
      tagsAlreadyAdded=1
      local tagName="${managedRefname#refs/}"
      tagName="${tagName#tags/}"

      dangledModules+=("$moduleName")
      dangledRefs+=("$tagName")

      noUpstreamModules+=("$moduleName")
      noUpstreamBranches+=("$dangledBranch")

      git checkout -B "$dangledBranch"
      ret=$?
      (( ! "$ret" )) && ( git tag -f "$tagName" ; ret=$? )
    fi
  fi

  if (( "$pushAllTags" )); then
    if (( "$checkDropAffected" )) ; then
      plainPushModules+=("$moduleName")
    elif (( ! "$tagsAlreadyAdded" )); then
      checkDropAffected=1
    fi
  elif [[ -n "$explicitTagName" ]]; then
    local tagRef="refs/tags/$explicitTagName"
    read -a existsLocal < <( git show-ref --tags | grep -E "\s$tagRef\$" )

    if [[ -n "{$existsLocal[0]}" ]]; then
      local addToTagsModules=1
      checkDropAffected=1
      local remoteTagExists=0
      read -a existsRemote < <( git ls-remote --tags | grep -E "\s$tagRef\$" )

      if [[ -n "{$existsRemote[0]}" ]]; then
        if [[ "{$existsRemote[0]}" != "{$existsLocal[0]}" ]]; then
          remoteTagExists=1
        else
          addToTagsModules=0
        fi
      fi

      if (( "$addToTagsModules" )); then
        remoteExplicitTagModules+=("$remoteTagExists")
        tagsModules+=("$moduleName")
      fi
    fi
  fi

  if (( ! "$ret" )) && (( "$checkDropAffected" )); then
    drop_to_affected "$levelPath"
    notApplied=$?
  fi

  if (( "$notApplied" )); then
    skippedModules+=("$moduleName")
  fi

  if [ -f .gitmodules ] && (( "$doRecursive" )); then
    while read -a module; do
      childRet=0
      subModuleName="${module[0]}"
      localPath="${module[1]}"
      subRepoPath="$levelPath/$localPath"

      subModulePath="$modulePath"
      [[ "${subModulePath:(-1)}" != "/" ]] && subModulePath+="/"
      subModulePath+="$subModuleName"

      pushd "$subRepoPath" &>/dev/null
      prepare_push_level "$subRepoPath" "$subModuleName" "$subModulePath"
      childRet=$?

      (( "$childRet" > "$ret" )) && ret="$childRet"
      popd  &>/dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  return "$ret"
}


################################ MAIN SCRIPT LOGIC ################################
cmd_default() {
  typeset skippedModules=()
#  typeset affected=0
  local ret=0
  local index
  local dieMsg

  pushd "$moduleFilePath" &>/dev/null

  prepare_push_level "$moduleFilePath" "$moduleName" "$modulePath"
  ret=$?
  
  local wasPushed=()
  if (( ! $ret )) && [ -f ${globals["$G_AFFECTED_MODULES"]} ]; then
    while read -a module; do
      local moreOptions=()
      local upstreamBranch

      moduleName="${module[$MFS_MODULE_NAME]}"

      cd "${module[$MFS_FULL_PATH]}"
      level_verbose_about_to "${module[@]}"
      index=0
      for noUpstreamModule in "${noUpstreamModules[@]}"; do
        if [[ "$noUpstreamModule" == "$moduleName" ]]; then
          moreOptions+=("$legoRemote")
          upstreamBranch="${noUpstreamBranches[$index]}"
          moreOptions+=("$upstreamBranch")
          break
        fi
        index=$(( $index + 1 ))
      done

      local doPlainPushOption=1
      if [[ "${#plainPushModules[@]}" > 0 && "$pushAllTags" == 1 ]]; then
        doPlainPushOption=0

        for plainPushModule in "${plainPushModules[@]}"; do
          if [[ "$plainPushModule" == "$moduleName" ]]; then
            doPlainPushOption=1
            break
          fi
        done
      fi

      if (( "$doPlainPushOption" )); then
#      echo "git push ${args[@]} ${moreOptions[@]}"
        dieMsg="git push ${args[@]} ${moreOptions[@]}"
        git push ${args[@]} ${moreOptions[@]}
        ret=$?

        if (( ! "$ret" )) && (( "$doUpstream" )) && [[ -n "$upstreamBranch" ]]; then
          dieMsg="git branch --set-upstream-to=origin/$upstreamBranch $upstreamBranch"
          git branch --set-upstream origin/$upstreamBranch $upstreamBranch
          ret=$?
        fi
      fi

      if (( ! "$ret" )); then
#        pwd >&2
#        panic "'$dieMsg' failed"
#      else
        wasPushed+=("${module[$MFS_MODULE_NAME]}")
        if (( "${#dangledModules[@]}" )) ; then
          index=0
          for dangledModule in "${dangledModules[@]}"; do
            if [[ "$dangledModule" == "$moduleName" ]]; then
              local tagName="${dangledRefs[$index]}"
              git checkout "$tagName"
              git push "$legoRemote" ":$tagName"
              git push "$legoRemote" "$tagName"
              git branch -D "$dangledBranch"
              git push "$legoRemote" ":$dangledBranch"
              break
            fi
            index=$(( $index + 1 ))
          done
        fi
        if (( "$pushAllTags" )); then
          git push "$legoRemote" --tags
        else
          index=0
          if (( "${#tagsModules[@]}" )) ; then
            for tagModule in "${tagsModules[@]}"; do
              if [[ "$tagModule" == "$moduleName" ]]; then
                local remoteExists="${remoteExplicitTagModules[$index]}"
                if (( "$remoteExists" )); then
                  git push "$legoRemote" ":$explicitTagName"
                fi
                git push "$legoRemote" "$explicitTagName"
                break
              fi
              index=$(( $index + 1 ))
            done
          fi
        fi
      fi
    done < <(cat ${globals[$G_AFFECTED_MODULES]}  | (tac 2>/dev/null || tail -r))
  fi
#  else

  if (( "$ret" )); then
    cw_echo "$dieMsg"
  fi

#    mainWarn="Request to push is rejected. "
#    (( "$verbose" )) && mainWarn+="Use '${FLAGS_PREFIX} -v' to figure out the reason."
#    (( 1 == "$verbose" )) && mainWarn+="'${FLAGS_PREFIX} -v -v' to get more detailed information."
#
#    cw_echo  "$mainWarn" \
#    "Some mutual dependent repositories will not be pushed, but required." \
#    "Pushing at current state will break consistence of modules hierarchy."
#  fi

  if (( ! "${#wasPushed[@]}" )); then
    cw_echo "No modules was pushed"
  elif (( "${#skippedModules[@]}" )); then
    local modulesCount="${#skippedModules[@]}"
    local msgSkipped="Not affected modules: "
    local maxShownModules=5

    if (( $modulesCount > $maxShownModules )); then
      local rest=$(( $modulesCount - $maxShownModules ))
      msgSkipped+="${skippedModules[@]:0:$maxShownModules} and $rest others..."
    else
      msgSkipped+="${skippedModules[*]}"
    fi

    cw_echo "$msgSkipped"
  fi

  popd &>/dev/null
  umbrella_finalize
  exit "$ret"
}