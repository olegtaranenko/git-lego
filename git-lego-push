#!/usr/bin/env bash
set +o posix
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

args=()

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap

cwRoot="${globals[$G_ROOT_DIR]}"
gitDir="${globals[$G_MODULE_GIT_DIR]}"


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git umbrella-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [<any-git-status-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset verbose=0
typeset initialPath
typeset afterDash=()
typeset stopOptions=0
typeset fetchBefore=1

#set -x
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --fetch|-f)
      fetchBefore=1
      ;;
    --no-fetch|-F)
      fetchBefore=0
      ;;

    --)
      stopOptions=1
      ;;
    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath="$1"
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done

#echo "args: ${args}"
#set +x


################################ SCRIPT SPECIFIC METHODS ################################
#
# Returns
#     0 - module not requires push or pushable and listed as affected
#     1 - module is pushable, but not listed as affected
#     2 - module is not pushable (requires pull/fetch/merge) or detached
#

function prepare_push_level() {
  local parentPushable=$4
  local currentPushable=0
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local ret=0
  local childRet # child modules return code

  if (( $fetchBefore )); then
    cw_verbose "About to fetch from remote..."
    if (( $verbose == 2 )); then
      git fetch
    else
      git fetch &> /dev/null
    fi
    (( $? )) && panic "Something wrong with git fetch"
  fi

  module_porcelain_status push

  local applied=1
#  echo "$MODULE_STATUS[@]"
  if (( ${MODULE_STATUS[$MS_DETACHED]} )); then
    die "Push is peeled rejected as module '$moduleName' is detached."
  elif [[ 1 == ${MODULE_STATUS[$MS_PUSHABLE]}  && -z ${MODULE_STATUS[$MS_PULLABLE]}  &&  -z ${MODULE_STATUS[$MS_DETACHED]} ]]; then
    currentPushable=1
    drop_to_affected ${levelPath}
    applied=$?
    # 0 means applied, 1 - not
    # if applied == 1, the module is pushable but not applied - dangerous for upper modules,
    # they should not be pushed. Otherwise other developers will pull upper module with undefined
    # commit for submodule
    (( $applied )) && (( $parentPushable > 0 )) && ret=1
  else
    currentPushable=-1
  fi

  if (( $applied )); then
    skippedModules+=(${moduleName})
  fi

  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      subModule="${module[0]}"
      checkBranch=$(git config --file .gitmodules --get submodule."${subModule}".branch)
      localPath="${module[1]}"
      subRepoPath="${levelPath}"/"${localPath}"

      pushd "${subRepoPath}" &> /dev/null
      local modulePath="$3" #/$subModule"
      if [[ ${modulePath:(-1)} != "/" ]]; then
        modulePath+="/"
      fi
      modulePath+="$subModule"

      prepare_push_level "${subRepoPath}" "${subModule}" "${modulePath}" "${currentPushable}"
      childRet=$?

      (( $childRet > $ret )) && ret=${childRet}
      popd  &> /dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  return ${ret}
}


################################ MAIN SCRIPT LOGIC ################################
cmd_default() {
  typeset modulePath=$(resolve_module_path "${initialPath}" /)
  read moduleName resolvedPath < <(module_info "${modulePath}" "name" "path")
  typeset skippedModules=()
  typeset affected=0
  typeset vetoed=0

  pushd ${resolvedPath} &>/dev/null
  baseModulePath=$(pmd)
  #set -x
  prepare_push_level "${resolvedPath}" "${moduleName}" "${baseModulePath}" "0"
  ret=$?

  if (( $ret )); then
    vetoed=1
  fi

  wasPushed=0
  if (( ! $vetoed )); then
    if (( $affected )); then
      while read -a module; do
        cd ${module[$MFS_FULL_PATH]}
        pwd
        level_verbose_about_to ${module[@]}
    #    echo "git push ${args[@]} ${#args[@]}"
        git push "${args[@]}"
        if (( $? )); then
          panic $(pwd)
          panic "Unexpected error 'git push' command"
        fi
        wasPushed+=(module[$MFS_MODULE_NAME])
      done < <(cat ${globals[$G_AFFECTED_MODULES]} | (tac 2> /dev/null || tail -r))
    fi
  else
    mainWarn="Request to push is rejected. "
    (( $verbose )) && mainWarn+="Use '${FLAGS_PREFIX} -v' to figure out the reason."
    (( 1 == $verbose )) && mainWarn+="'${FLAGS_PREFIX} -v -v' to get more detailed information."

    cw_echo  ${mainWarn} \
    "Some mutual dependent repositories will not be pushed, but required." \
    "Pushing at current state will break consistence of modules hierarchy."
  fi

  (( ! ${#wasPushed[@]} )) && cw_echo "Push not happens"

  if (( ${#skippedModules} )); then
    cw_echo "Not affected modules: ${skippedModules[*]}"
  fi

  popd &>/dev/null
  umbrella_finalize
  exit ${ret}
}