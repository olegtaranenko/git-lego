#!/usr/bin/env bash

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

args=()

. $(dirname $0)/lib/shared_functions.sh

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap

cwRoot="${globals[$G_ROOT_DIR]}"
uModules="${globals[$G_MODULES_FN]}"
gitDir="${globals[$G_MODULE_GIT_DIR]}"


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/} status in git umbrella-managed modules

SYNOPSIS:
    '${0##*/} [<any-git-status-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${0##*/} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset verbose=0
typeset initialPath
#set -x

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    *)
      if [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac
  shift
done

#echo "args: ${args}"
#set -x


################################ SCRIPT SPECIFIC METHODS ################################

#
## Print status in format
# ... (tbd)
## Parameters
#   $1 file path to module toplevel
#   $3 module name
#   $2 path to the enclosed module in module hierarchy
#
##  Globals settings.
#     $quiet ??
#
##  Side effects to globals.
#     $commitable - sets to 1, if one of affected module has dirty state, required to be commit
# .
#
function show_current_module_status {
  local filePath=$1
  local info="${3:-/}"
  local verboseMsg=([1]="path: $filePath")
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local fineIssues infoIssues
#  set -x

  module_porcelain_status
  
  (( ${MODULE_STATUS[$MS_DETACHED]} )) && detached=${MODULE_STATUS[$MS_DETACHED]}
  (( ${MODULE_STATUS[$MS_COMMITABLE]} )) && commitable=${MODULE_STATUS[$MS_COMMITABLE]}

  typeset branchInfo=${MODULE_STATUS[$MS_BRANCH_INFO]}
  [[ -n ${branchInfo} ]] && info+=", ${branchInfo}"

  if (( ${MODULE_STATUS[$MS_UNTRACKED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="untracked"
    infoIssues+="?"
  fi
  if (( ${MODULE_STATUS[$MS_ADDED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="added"
    infoIssues+="A"
  fi
  if (( ${MODULE_STATUS[$MS_MODIFIED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="modified"
    infoIssues+="M"
  fi
  if (( ${MODULE_STATUS[$MS_DELETED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="deleted"
    infoIssues+="D"
  fi
  if (( ${MODULE_STATUS[$MS_RENAMED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="renamed"
    infoIssues+="R"
  fi
  if (( ${MODULE_STATUS[$MS_COPIED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="copied"
    infoIssues+="C"
  fi
  if (( ${MODULE_STATUS[$MS_UNMERGED]} )); then
    (( ${#fineIssues} )) && fineIssues+=", "
    fineIssues+="unmerged"
    infoIssues+="U"
  fi

#  set -x
  if (( ${#infoIssues} )); then
    fineIssues="issues: "$fineIssues" paths"
    verboseMsg+=("${fineIssues}")
    info+=", dirty: "${infoIssues}
#    commitable=1
  else
    verboseMsg+=("no commitable changes")
    [[ ${MODULE_STATUS[$MS_DETACHED]} != 1 ]] && info+=", clean"
    (( ${MODULE_STATUS[$MS_DETACHED]} )) && info+=", no changes"
  fi
  verboseMsg[0]=${info}
#  set +x
  cw_echo "${verboseMsg[@]}"

  if (( $verbose > 1 )) && [ -n ${args} ]; then
    git status ${args}
  fi
}

function status_level() {
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "status_level()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is syncronized
  local childRet # child return code
  show_current_module_status "$@"

  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      subModule="${module[0]}"
      checkBranch=$(git config --file .gitmodules --get submodule."${subModule}".branch)
      localPath="${module[1]}"
      subRepoPath="${levelPath}"/"${localPath}"

      pushd "${subRepoPath}" &> /dev/null
      status_level "${subRepoPath}" "${subModule}" "$3/$subModule"
      childRet=$?
      (( $childRet > $ret )) && ret = ${childRet}
      popd  &> /dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi
}


function get_module_path_up() {
  local path=${1%/*}

  local ret=1
  (( ${#path} )) && ret=0

  (( ! $ret )) && echo "${path}"
  return ${ret}
}


function get_module_path_down() {
  local path="$1/$2"
  local ret=1

  for mp in ${g_module_paths[@]}; do
    if [[ ${mp} == ${path} ]]; then
      ret=0
      break
    fi
  done

  (( ! $ret )) && echo "${path}"
  return ${ret}
}


function resolve_module_path() {
  cantResolve="Can't resolve module path '$1'"
  local reminder="$1" originPath

  if [[ -n ${reminder} ]]; then
    if [[ -z ${reminder%%/*} ]]; then
      originPath=""
      reminder=${reminder:1}
    fi

    if [[ -z ${reminder%%./*} || $reminder == "." ]]; then
      reminder=${reminder:2}
      originPath=$(pmd)
    fi

    if [[ -z ${reminder%%../*} || $reminder == ".." ]]; then
      reminder=${reminder:3}
      originPath=$(pmd)
      originPath=$(get_module_path_up ${originPath})
    fi

    if (( ${#reminder} )); then
      IFS="/" read -a parts <<< $reminder
      for part in $parts; do
        echo $part
        case $part in
          \.\.\.)
            die "${cantResolve}"
          ;;
          \.\.)
            originPath=$(get_module_path_up ${originPath})
            (( $? )) && die "${cantResolve}"
          ;;
          \.)
            ## nothing
          ;;
          *)
            originPath=$(get_module_path_down ${originPath} ${part})
            (( $? )) && die "${cantResolve}"
          ;;
        esac
      done
    fi
  fi

  [[ -z "$originPath" ]] && originPath="/"


  local index=0
  local ret=1
  local path="$originPath"
#  if [[ -n $reminder ]]; then
#    path+=/${reminder}
#  fi
  for mp in ${g_module_paths[@]}; do
    if [[ ${mp} = $path ]]; then
      ret=0
      break
    fi
    index=$(( index + 1 ))
  done
  echo ${path}
#  (( ! $ret )) && echo ${g_full_paths[${index}]}
  return $ret
}


################################ MAIN SCRIPT LOGIC ################################
#cat ${uModules}

typeset commitable
typeset detached
set -x
#echo $initialPath

typeset resolvedPath=$(resolve_module_path $initialPath)
echo $resolvedPath
exit 1

pushd ${resolvedPath} &>/dev/null
status_level "${resolvedPath}" "${globals[$G_ROOT_NAME]}"
if (( $commitable )); then
  msg="You have to commit current changes ('commit --help' for more information)"
  if (( $detached )); then
    msg+=", but CAUTION, one (or more) module(s) detached, than you may lost your changes thereafter."
    msg2="Your are advised to run CW 'branch ... <branch-name>' command before doing commit"
  fi
  msg+="."
  cw_cr
  cw_echo "${msg}"
  [[ -n ${msg2} ]] && cw_echo "${msg2}"
  (( ! $verbose )) && cw_echo "'${0##*/} -v ...' option to get output more verbose or '${0##*/} --help' for other options"
  cw_cr
fi
ret=$?

popd &>/dev/null

umbrella_finalize
exit ${ret}