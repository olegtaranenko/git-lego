#!/usr/bin/env bash

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

  # After call to 'consistentwork_bootstrap' this array contains following predefined values.
  #
  ## "${globals[0]}" [cwRoot]           - path to umbrella repository
  ## "${globals[1]}" [cwTmpSubmodules]  - temporary file name, which listed all current repositories with additional information
  ## "${globals[2]}" [gitDir]           - current repository (or sub repository, from the
  #
globals=()

args=()

. $(dirname $0)/lib/shared_functions.sh

################################ STANDARD BOOTSTRAP CALL ################################
consistentwork_bootstrap

cwRoot="${globals[0]}"
cwTmpSubmodules="${globals[1]}"
gitDir="${globals[2]}"


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/} status in git umbrella-managed modules

SYNOPSIS:
    '${0##*/} [<any-git-status-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${0##*/} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

#echo  "${cwRoot} ${gitDir}"
pushd ${cwRoot} &>/dev/null
typeset verbose=0
typeset branchName
#set -x

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    *)
      if [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${branchName} ]]; then
        branchName=$1
        noAppendArg=1
      fi
      ;;
  esac
  shift
done

#echo "args: ${args}"
#set -x


################################ SCRIP SPECIFIC METHODS ################################
function show_current_module_status {
  local repoName=$1
  local info
  if [ -z $3 ]; then
    info="${globals[3]} /"
  else
    info="$3"
  fi
  local verboseMsg=([1]="path: $1")
  verboseMsg+=("url: "$(get_repo_url))


  if (( $verbose )); then
    cw_cr
  fi

  local fineIssues infoIssues untracked modified deleted added renamed copied unmerged
#  set -x

  while read -a output; do
    unset fineIssues
    unset infoIssues
    case ${output[0]} in
      \#\#)
        [ -n ${output[1]} ] && info+=", "${output[@]:1}
        [[ ${output[1]} == "HEAD" ]] && detached=1
      ;;
      *)
        cmd=${output:0:2}
        case ${cmd} in
          \?\?)
            untracked=1
          ;;
          *)
            [[ ${cmd:0:1} == "M" || ${cmd:1:1} == "M" ]] && modified=1
            [[ ${cmd:0:1} == "A" || ${cmd:1:1} == "A" ]] && added=1
            [[ ${cmd:0:1} == "D" || ${cmd:1:1} == "D" ]] && deleted=1
            [[ ${cmd:0:1} == "R" || ${cmd:1:1} == "R" ]] && renamed=1
            [[ ${cmd:0:1} == "C" || ${cmd:1:1} == "C" ]] && copied=1
            [[ ${cmd:0:1} == "U" || ${cmd:1:1} == "U" ]] && unmerged=1
          ;;
        esac

        if (( $untracked )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="untracked"
          infoIssues+="?"
        fi
        if (( $added )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="added"
          infoIssues+="A"
        fi
        if (( $modified )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="modified"
          infoIssues+="M"
        fi
        if (( $deleted )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="deleted"
          infoIssues+="D"
        fi
        if (( $renamed )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="renamed"
          infoIssues+="R"
        fi
        if (( $copied )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="copied"
          infoIssues+="C"
        fi
        if (( $unmerged )); then
          (( ${#fineIssues} )) && fineIssues+=", "
          fineIssues+="unmerged"
          infoIssues+="U"
        fi
      ;;
    esac
  done < <(git status -u --porcelain -b)
#  set -x
  if (( ${#infoIssues} )); then
    fineIssues="Issues: "$fineIssues" paths"
    verboseMsg+=("${fineIssues}")
    info+=", dirty state: "${infoIssues}
    commitable=1
  else
    verboseMsg+=("no commitable changes")
    info+=", clean state"
  fi
  verboseMsg[0]=${info}
#  set +x
  cw_echo "${verboseMsg[@]}"

  if (( $verbose > 1 )) && [ -n ${args} ]; then
    git status ${args}
  fi

}

function status_level() {
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "check_branch_sync()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is syncronized
  local childRet # child return code
#  cd "${levelPath}"
  show_current_module_status "$@"

  if [ -f .gitmodules ]; then
    while read -a repo; do

      childRet=0
      subRepoName="${repo[0]}"
      checkBranch=$(git config --file .gitmodules --get submodule."${subRepoName}".branch)
      checkPath="${repo[1]}"
      subRepoPath="${levelPath}"/"${checkPath}"

      pushd "${subRepoPath}" &> /dev/null
      status_level "${subRepoPath}" "${subRepoName}" "$3/$subRepoName"
      childRet=$?
      (( $childRet > $ret )) && ret = ${childRet}
      popd  &> /dev/null

    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

}


################################ MAIN SCRIPT LOGIC ################################
typeset commitable
typeset detached
cd "${cwRoot}"
status_level "${cwRoot}" "/"
if (( $commitable )); then
  msg="You have to commit current changes ('commit --help' for more information)"
  if (( $detached )); then
    msg+=", but CAUTION, one (or more) module(s) in detached mode, than you may lost your changes after there."
    msg2="Your are advised to run CW 'branch ... <branch-name>' command before commit"
  fi
  msg+="."
  cw_cr
  cw_echo "${msg}"
  [[ -n ${msg2} ]] && cw_echo "${msg2}"
  (( ! $verbose )) && cw_echo "'${0##*/} -v ...' option to get output more verbose or '${0##*/} --help' for other options"
  cw_cr
fi
ret=$?

popd &>/dev/null

exit ${ret}