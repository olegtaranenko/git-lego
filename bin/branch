#!/usr/bin/env bash

#set -x
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

  # After call to 'consistentwork_bootstrap' this array contains following predefined values.
  #
  ## "${globals[0]}" [cwRoot]           - path to umbrella repository
  ## "${globals[1]}" [cwTmpSubmodules]  - temporary file name, which listed all current repositories with additional information
  ## "${globals[2]}" [gitDir]           - current repository (or sub repository, from the
  #
declare globals=()

. $(dirname $0)/lib/shared_functions.sh


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/}

SYNOPSIS:
    ${0##*/} [--show] [--[no-]sync] [--[no-]push [<remote>]]
    ${0##*/} --[no-]current [--[no-]recursive] ...] [--[no-]push] new-branch
    ${0##*/} [--[no-]umbrella] [--[no-]push] new-branch -- <repo> ...
    ${0##*/}  --delete|-d|-D branch [--[no-]push [<remote>]]


DESCRIPTION:
    Creates new branch or check current branches state of modules hierarchy.
    All affected repositories SHOULD be in clean state.
    New branch will be forked from current branches. Use 'checkout --fallback=... <fork-branch'
    command to change base branches for fine tuning.

    There are two different modes for creating branches for repositories.

    1) direct repositories names listing after '--'; name it "absolute"
    2) depending, from module ${0##*/} is started: name it "relative" mode.

      In absolute mode doesn\'t matter current module, and affecting on only umbrella (managed by
    --[no-]umbrella option) and modules, listed after '--'

      In relative mode calling ${0##*/} affects on modules depends on options --[no-]recursive and
    --[no-]umbrella. If current module is umbrella
    new branch will be created to current and umbrella repositories only

    Repositories not matching to umbrella branch and having committalbe changes, will be managed
    to umbrella branch name explicit created.

OPTIONS:
      --help|-h|-\?
          get help

      --show
          check state of the branding modules hierarchy.

      --[no]-sync]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --fallback[=| ]<branch>
          fallback branch name used instead of <fork-branch>, if last does not exists in sub-module

      --[no-]push[=<remote>]
          push (or prevent) to <remote> ('origin' by default) repository.

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

typeset doView=0
typeset doSync=1
typeset doAutoCommit=1
typeset doPush=0
typeset doCurrent=0
typeset stopOptions=0
typeset doUpdate=0
typeset doUmbrella=1
typeset doRecursive=0
typeset branchName

(( ! $# )) && doView=1; doSync=0; doPush=0; doAutoCommit=0

# globals is being used in consistent_bootstrap as container return important metrics of branded repo

repos=()
excludes=()

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit 0
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;


    --exclude)
      if [ -n "$2" ]; then
        ${excludes[${#excludes[@]}]}=$2
        shift
      else
        die "--exclude requires a non-empty option argument."
      fi
      ;;
    --exclude=?*)
      ${excludes[${#excludes[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --exclude=)         # Handle the case of an empty --exclude=
      die "--exclude requires a non-empty option argument."
      ;;

    --push)
      doPush=1
      ;;
    --no-push)
      doPush=0
      ;;

    --current)
      doCurrent=1
      ;;
    --no-current)
      doCurrent=0
      ;;

    --umbrella)
      doUmbrella=1
      ;;
    --no-umbrella)
      doUmbrella=0
      ;;

    --recursive)
      doRecursive=1
      ;;
    --no-recursive)
      doRecursive=0
      ;;

    --sync)
      doSync=1
      doView=1
      ;;
    --no-sync)
      doSync=0
      ;;

    --auto-commit)
      doAutoCommit=1
      ;;
    --no-auto-commit)
      doAutoCommit=0
      ;;

    --view|--show)
      doView=1
      ;;

    -d|-D|--delete)
      ## keep case
      if [[ $1 == "--delete" ]]; then
        doDelete="-d"
      else
        doDelete=$1
      fi
      ;;
    --)
      stopOptions=1
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        # TODO take into account getopts parsing call
        die "Unknown option $1"
      fi

      if (( ! $stopOptions )); then
        if [[ -z ${branchName} ]]; then
          branchName="$1"
          doUpdate=1
        elif [[ -n ${1%%-*} ]]; then
            die "Fork name options '$1' is not supported for now.
        Please first do 'checkout $1' as base for creating new branch '$branchName'"

        fi
      else
        repos[1+${#repos[@]}]="$1"
      fi
      ;;
  esac
  shift
done


################################ STANDARD BOOTSTRAP CALL ################################ 

skipSplash=1
consistentwork_bootstrap

(( $doAutoCommit && ! $doSync )) && die "--auto-commit should be set only with --sync option"

cwRoot="${globals[0]}"
cwTmpSubmodules="${globals[1]}"
gitDir="${globals[2]}"
needMessageToPush=0

## Checks branching state for current repository
## Let name the branch is synched if entry submodule.<subrepo>.branch in .gitmodules is matched
## to the branch of the sub-repository, (what can be checked via 'cd subrepo; git branch',
## It they are mismatched, 3 options are possible.
## 1. Sub-repo can be detached. In this case we are looking for value in the outer repo and doing git checkout branch
## 2. Sub-repo is pinned to another branch then it is given in .gitmodules. To sync this we just changing v
##    value in .gitmodules file of outer repo
## 3. Sub-repo is detached, no value in .gitmodules. We are uneble to re-syncronize, notifying user about and exitiing.
## Parameters:
##      1. path [required] - path getting started checking. It can be called recursively to drill down to the leaves repos.
## Returns
##
function check_branch_sync() {
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "check_branch_sync()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is syncronized
  local childRet # child return code
  cd "${levelPath}"

  while read -a repo; do
    childRet=0
    subRepoName="${repo[0]}"
    checkBranch=$(git config --file .gitmodules --get submodule."${subRepoName}".branch)
    checkPath="${repo[1]}"
    subRepoPath="${levelPath}"/"${checkPath}"

    #    echo "${subRepoName}" "${checkBranch}" "${checkPath}"

    pushd "${subRepoPath}" &> /dev/null
    #    pwd

    repoBranch=$(git rev-parse --abbrev-ref HEAD)
    local detached=0
    [[ "${repoBranch}" == "HEAD" ]] && detached=1

    #    echo "${repoBranch}"
    if [[ ${repoBranch} != ${checkBranch} ]]; then

      ret=1
      (( ! $doSync )) && cw_echo "Module ${subRepoName} is not synchronized"
      #      echo "$repoBranch != $checkBranch"

      #
      if [[ -n "${repoBranch}" && ${detached} == 0  ]]; then
        cd "${levelPath}"
        if (( $doSync )); then
          cw_echo "About to change reference in .gitmodules for submodule $subRepoName to branch $repoBranch"
          git config --file .gitmodules submodule."${subRepoName}".branch "${repoBranch}"
          ret=$?
        fi
      elif [[ -n "${checkBranch}" && ${detached} == 1 ]]; then
        cd "${subRepoPath}"
        if (( $doSync )); then
          cw_echo "About to checkout submodule $subRepoName to branch $checkBranch"
          git checkout ${checkBranch}
          ret=$?
        fi
      else
        cw_echo "Warning: submodule ${subRepoName} can't be syncronized"
        ret=2
      fi
    else
      (( $doView )) && cw_echo "Module '$subRepoName' at '$checkBranch' branch"
    fi

    if [[ -e .gitmodules ]]; then
      check_branch_sync "${subRepoPath}"
      childRet=$?
    fi
    (( $childRet )) && ret = 1


    popd  &> /dev/null

    if (( $doSync )); then
      git diff --exit-code --quiet -- .gitmodules
      needToCommit=$?
      #echo "needToCommit=${needToCommit}"
      if (( $qeedToCommit )); then
        if (( $doAutoCommit )); then
          git add .gitmodules
          git commit -m "$subRepoName submodule configuration is changed"
        else
          needMessageToPush=1
        fi
      fi
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return "${ret}"
} ## of check_branch_sync


cd "${cwRoot}"
  ##
  ## Current state of umbrella branch
  ##
mainBranch=$(git rev-parse --abbrev-ref HEAD)

if (( "$doView" )); then
############################################### CHECK STATE (SHOW) (VIEW) ################################################
  #printf "do view"
  #(( $doSync )) && printf ", do sync"; (( $doAutoCommit )) && printf "(autocommit)"; (( ! $doAutoCommit )) && printf "(NO autocommit)"; (( ! $doSync )) && printf ", NO sync"
  #(( $doPush )) && printf ", do push";  (( ! $doPush )) && printf ", NO push"
#  printf "\n"

  if [[ ${mainBranch} == "HEAD" ]]; then
    instruction="$(cat<<EOF
Umbrella repo is in the detached mode.
        You need to configure it using 'checkout ${branchName:-<branch-name>}'
        Use '${0##*/} --help' for more information
EOF
)"
    cw_echo "${instruction}"
    ret=1
  else
    cw_echo "Umbrella repo at '$mainBranch' branch"
  fi

  check_branch_sync "${cwRoot}"
  ret=$?

  (( ! $ret )) && cw_echo "All submodules are mutually syncronized."
  [[ $ret == 1 ]] && cw_echo "Submodules are not synchronized. Run '${0##*/} --sync' to fix"
  [[ $ret == 2 ]] && cw_echo "Unexpected error"

elif (( $doUpdate )); then
################################################# UPDATE #################################################
  currentUmbrellaState="'${mainBranch}'"
  [[ $mainBranch == "HEAD" ]] && currentUmbrellaState="detached"

  typeset mainAlreadyExists=$(is_branch_exists "${branchName}")
  if (( $mainAlreadyExists )) && (( $doUmbrella )); then
    die "Branch '$branchName' already exists in the umbrella repo.
        You are advised to do 'checkout $branchName' and then continue to create branch in sub-repositories
        with '${0##*/} ... --no-umbrella ...' option"
  fi

  verboseMsgs=()

  if (( $doUmbrella )); then
    verboseMsgs[0]="About to create new branch '$branchName' for umbrella repo"
  else
    verboseMsgs[0]="About to create branch '$branchName' in sub-repositories only"
  fi
  verboseMsgs[1]="Current umbrella branch: $currentUmbrellaState"
  verboseMsgs[2]="Affected sub repositories: ${repos[*]}"
#  verboseMsgs[3]="Fallback branches: ${fallbacks[*]}"

  cw_echo "${verboseMsgs[@]}"

  if (( $doUmbrella )); then
    reposPath[0]="${cwRoot}"
  fi
fi


cw_verbose_stop
exit $ret
