#!/usr/bin/env bash

#set -x
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
globals=()
. $(dirname $0)/lib/shared_functions.sh


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/}

SYNOPSIS:
    ${0##*/} [--view] [--[no-]sync] [--[no-]push [<remote>]]
    ${0##*/} [[--fallback <branch1> ...] [--[no-]umbrella]
                    [--[no-]push] new-branch [<fork-branch>] -- <repo>[:<fork-branch> ...
    ${0##*/}  --delete|-d|-D branch [--[no-]push [<remote>]]


DESCRIPTION:
    Creates new branch or check current branches state of modules hierarchy.
    By default new branch will be created to current and umbrella repositories only
    if affected modules have no committable changes. Repositories not matching to umbrella
    branch and having committalbe changes, will be managed to umbrella branch name explicit
    created. Options --repo=<repo1> (can be multiplied) to create branches with same
    name for <repo1>, <repo2>, ... if they are in clean state. Option --all will create
    new branch for all repositories. --fallback <branch> option defines base branch to
    be forked off. If repository does not contain fallback <branch> current branch will
    be used. Allows multiply --fallback options, first has more priority.
    Option --repo=<repo>:<repo-branch> override --fallback property and put forking
    branch to specified <repo-branch>
    <fork-branch> changes forked off branch for clean modules.

OPTIONS:
      --help|-h|-\?
          get help

      --view
          check state of the branding modules hierarchy.

      --[no]-sync]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --fallback[=| ]<branch>
          fallback branch name used instead of <fork-branch>, if last does not exists in sub-module

      --[no-]push[=<remote>]
          push (or prevent) to <remote> ('origin' by default) repository.

      --
          marks state after which only affected repositories will be enumerated. If --[no-]umbrella option is given

EOF
}

typeset doView=0
typeset doSync=1
typeset doAutoCommit=1
typeset doPush=0
typeset stopOptions=0
typeset doUpdate=0
typeset doUmbrella=1
typeset branchName
typeset forkName

(( ! $# )) && doView=1; doSync=0; doPush=0; doAutoCommit=0

# globals is being used in consistent_bootstrap as container return important metrics of branded repo

fallbacks=()
repos=()
excludes=()

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  afterOptions=${1%%--*}
  (( $stopOptions )) && [[ -z $afterOptions ]] && die "after '--' additional options are not allowed "
  case $1 in
    -h|-\?|--help)
      show_help
      exit 0
      ;;

    --fallback)
      if [ -n "$2" ]; then
        ${fallbacks[${#fallbacks[@]}]}=$2
        shift
      else
        cw_echo 'ERROR: "--fallback" requires a non-empty option argument.' >&2
        exit 1
      fi
      ;;
    --fallback=?*)
      ${fallbacks[${#fallbacks[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --fallback=)         # Handle the case of an empty --fallback=
      cw_echo 'ERROR: "--fallback" requires a non-empty option argument.' >&2
      exit 1
      ;;

    --exclude)
      if [ -n "$2" ]; then
        ${excludes[${#excludes[@]}]}=$2
        shift
      else
        cw_echo 'ERROR: "--exclude" requires a non-empty option argument.' >&2
        exit 1
      fi
      ;;
    --exclude=?*)
      ${excludes[${#excludes[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --exclude=)         # Handle the case of an empty --exclude=
      cw_echo 'ERROR: "--exclude" requires a non-empty option argument.' >&2
      exit 1
      ;;

    --push)
      doPush=1
      ;;
    --no-push)
      doPush=0
      ;;

    --umbrella)
      doUmbrella=1
      ;;
    --no-umbrella)
      doUmbrella=0
      ;;

    --sync)
      doSync=1
      doView=1
      ;;
    --no-sync)
      doSync=0
      ;;

    --auto-commit)
      doAutoCommit=1
      ;;
    --no-auto-commit)
      doAutoCommit=0
      ;;

    -v|--verbose)
        verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
        ;;
    --view)
      doView=1
      ;;

    -d|-D|--delete)
      doDelete=1
      ;;

    --)
      stopOptions=1
      ;;
    *)
      if (( ! $stopOptions )); then
        if [[ -z ${branchName} ]]; then
          branchName="$1"
          doUpdate=1
        elif [[ -z ${forkName} ]]; then
          forkName="$1"
        fi
      else
        repos[1+${#repos[@]}]="$1"
      fi
      ;;
  esac
  shift
done


################################ STANDARD BOOTSTRAP CALL ################################ 

skipSplash=1
consistentwork_bootstrap

(( $doAutoCommit && ! $doSync )) && die "--auto-commit should be set only with --sync option"

cwRoot="${globals[0]}"
cwTmpSubmodules="${globals[1]}"
gitDir="${globals[2]}"
needMessageToPush=0


function check_branch_sync() {
  local levelPath="$1"
  local repoBranch
  local ret=0   # return code, 0 - the repo is syncronized
  local childRet # child return code
  cd "${levelPath}"

  while read -a repo; do
    childRet=0
    subRepoName="${repo[0]}"
    checkBranch=$(git config --file .gitmodules --get submodule."${subRepoName}".branch)
    checkPath="${repo[1]}"
    subRepoPath="${levelPath}"/"${checkPath}"

    #    echo "${subRepoName}" "${checkBranch}" "${checkPath}"

    pushd "${subRepoPath}" &> /dev/null
    #    pwd

    repoBranch=$(git rev-parse --abbrev-ref HEAD)
    local detached=0
    [[ "${repoBranch}" == "HEAD" ]] && detached=1

    #    echo "${repoBranch}"
    if [[ ${repoBranch} != ${checkBranch} ]]; then

      ret=1
      (( ! $doSync )) && cw_echo "Module ${subRepoName} is not synchronized"
      #      echo "$repoBranch != $checkBranch"

      #
      if [[ -n "${repoBranch}" && ${detached} == 0  ]]; then
        cd "${levelPath}"
        if (( $doSync )); then
          cw_echo "About to change reference in .gitmodules for submodule $subRepoName to branch $repoBranch"
          git config --file .gitmodules submodule."${subRepoName}".branch "${repoBranch}"
          ret=$?
        fi
      elif [[ -n "${checkBranch}" && ${detached} == 1 ]]; then
        cd "${subRepoPath}"
        if (( $doSync )); then
          cw_echo "About to checkout submodule $subRepoName to branch $checkBranch"
          git checkout ${checkBranch}
          ret=$?
        fi
      else
        cw_echo "Warning: submodule ${subRepoName} can't be syncronized"
        ret=2
      fi
    else
      (( $doView )) && cw_echo "Module '$subRepoName' at '$checkBranch' branch"
    fi

    if [[ -e .gitmodules ]]; then
      check_branch_sync "${subRepoPath}"
      childRet=$?
    fi
    (( $childRet )) && ret = 1


    popd  &> /dev/null

    if (( $doSync )); then
      git diff --exit-code --quiet -- .gitmodules
      needToCommit=$?
      #echo "needToCommit=${needToCommit}"
      if (( $qeedToCommit )); then
        if (( $doAutoCommit )); then
          git add .gitmodules
          git commit -m "$subRepoName submodule configuration is changed"
        else
          needMessageToPush=1
        fi
      fi
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return "${ret}"
} ## of check_branch_sync


cd "${cwRoot}"
  ##
  ## Current state of umbrella branch
  ##
mainBranch=$(git rev-parse --abbrev-ref HEAD)
  ##
  ## Exit code of the script
  ## 0 - success
  ## 1 - warning
  ## 2 - error
  ##
declare ret=0

if (( "$doView" )); then
############################################### CHECK STATE (SHOW) (VIEW) ################################################
  #printf "do view"
  #(( $doSync )) && printf ", do sync"; (( $doAutoCommit )) && printf "(autocommit)"; (( ! $doAutoCommit )) && printf "(NO autocommit)"; (( ! $doSync )) && printf ", NO sync"
  #(( $doPush )) && printf ", do push";  (( ! $doPush )) && printf ", NO push"
#  printf "\n"

  if [[ ${mainBranch} == "HEAD" ]]; then
    instruction="$(cat<<EOF
Umbrella repo is in the detached mode.
        You need to configure it using '${0##*/} <branch-name>'
        Use '${0##*/} --help' for more information
EOF
)"
    cw_echo "${instruction}"
    ret=1
  else
    cw_echo "Umbrella repo at '$mainBranch' branch"
  fi

  check_branch_sync "${cwRoot}"
  ret=$?

  (( ! $ret )) && cw_echo "All submodules are mutually syncronized."
  [[ $ret == 1 ]] && cw_echo "Submodules are not synchronized. Run '${0##*/} --sync' to fix"
  [[ $ret == 2 ]] && cw_echo "Unexpected error"

elif (( $doUpdate )); then
################################################# UPDATE #################################################
  currentUmbrellaState="'${mainBranch}'"
  [[ $mainBranch == "HEAD" ]] && currentUmbrellaState="detached"

  typeset mainAlreadyExists=$(is_branch_exists "${branchName}")
  if (( $mainAlreadyExists )) && (( $doUmbrella )); then
    die "Branch '$branchName' already exists in the umbrella repo.
        You are adviced to do   'checkoout $branchName'
        and then continue to create branch in sub-repositories with '${0##*/} ... --no-umbrella ...' option"
  fi

  typeset

  if (( $doUmbrella )); then
    cw_echo "About to create new branch '$branchName' for umbrella repo" \
      "Current umbrella branch: $currentUmbrellaState" \
      "Fork branch name: '$forkName'" \
      "Affected repos: '${repos[*]}'" \
      "Fallback branches: '${fallbacks[*]}'"
  else
    cw_echo "About to create branch '$branchName' in sub-repositories"
  fi

  if [[ -n $forkName && $mainBranch != $forkName ]]; then
    if (( $doUmbrella )); then
      # TODO check whether $forkName exist or not, if not - check whether fallback branch exists
      cd "${cwRoot}"
      typeset forkExists = $(is_branch_exists "${forkName}")
      if (( $forkExists )); then
        cw_echo "Change branch for umbrella from '$mainBranch' to '$forkName'"
        git checkout "${forkName}"
      fi
    fi
  fi
fi


cw_verbose_stop
exit $ret
