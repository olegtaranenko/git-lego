#!/usr/bin/env bash
globals=()
args=()

. $(dirname $0)/lib/shared_functions.sh

consistentwork_bootstrap 

cwRoot="${globals[0]}"
cwTmpSubmodules="${globals[1]}"
gitDir="${globals[2]}"

function show_help() {
cat << EOF

NAME:
    ${0##*/}

SYNOPSIS:
    ${0##*/} [--show] [--[no-]sync] [--[no-]push [<remote>]]
    ${0##*/} --[no-]current [--[no-]recursive] ...] [--[no-]push] new-branch
    ${0##*/} [--[no-]umbrella] [--[no-]push] new-branch -- <repo> ...
    ${0##*/}  --delete|-d|-D branch [--[no-]push [<remote>]]


DESCRIPTION:
    Creates new branch or check current branches state of modules hierarchy.
    All affected repositories SHOULD be in clean state.
    New branch will be forked from current branches. Use 'checkout --fallback=... <fork-branch'
    command to change base branches for fine tuning.

    There are two different modes for creating branches for repositories.

    1) direct repositories names listing after '--'; name it "absolute"
    2) depending, from module ${0##*/} is started: name it "relative" mode.

      In absolute mode doesn\'t matter current module, and affecting on only umbrella (managed by
    --[no-]umbrella option) and modules, listed after '--'

      In relative mode calling ${0##*/} affects on modules depends on options --[no-]recursive and
    --[no-]umbrella. If current module is umbrella
    new branch will be created to current and umbrella repositories only

    Repositories not matching to umbrella branch and having committalbe changes, will be managed
    to umbrella branch name explicit created.

OPTIONS:
      --help|-h|-\?
          get help

      --show
          check state of the branding modules hierarchy.

      --[no]-sync]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --fallback[=| ]<branch>
          fallback branch name used instead of <fork-branch>, if last does not exists in sub-module

      --[no-]push[=<remote>]
          push (or prevent) to <remote> ('origin' by default) repository.

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

function checkout_level () {
  local repoPath="$1"
  local repoBranch="$2"
  local -a modulesBefore
  local -a modulesAfter
  local -a removedModules
  local -a addedModules
#  oldIfs=IFS

  cd "${repoPath}"
  echo "---> checkout_level ${repoPath}"

  while IFS="#" read -a repo; do
    modulesBefore[${#modulesBefore[@]}]="${repo[2]}"
  done < <(git submodule status | sed -E 's/(.)([[:xdigit:]]{40})[[:space:]]+([[:graph:]]*).*/\1#\2#\3/' 2>/dev/null)
  git checkout ${branchName}
  echo $?

  while IFS="#" read -a repo; do
    modulesAfter[${#modulesAfter[@]}]="${repo[2]}"
  done < <(git submodule status | sed -E 's/(.)([[:xdigit:]]{40})[[:space:]]+([[:graph:]]*).*/\1#\2#\3/' 2>/dev/null)
#  IFS=${oldIfs}

  for b in ${modulesBefore[@]}; do
    found=0
    for a in ${modulesAfter[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      removedModules[${#removedModules[@]}]="${b}"
    fi
  done

  for a in ${modulesAfter[@]}; do
    found=0
    for b in ${modulesBefore[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      addedModules[${#addedModules[@]}]="$a"
    fi
  done

  printf "%s\n" "${addedModules[@]}"
  printf "%s\n" "${removedModules[@]}"

  doGitUpdate=0
  for modulePath in "${addedModules[@]}"; do
    git submodule update $modulePath
  done

  #By change branch can happen that submodules can't be removed (usually can) if, for example, if submodule has its own submodule.
  (( "${#removedModules[@]}" )) && git clean -d -f -f

  # do recurse call for every sub-repos
  for modulePath in "${modulesAfter[@]}"; do
    deleted=0
    for d in "${removedModules[@]}"; do
      if [[ ${d} == ${modulePath} ]]; then
        deleted=1
        break
      fi
    done
    if (( ! $deleted )); then
      echo "${cwRoot}/${modulePath}"
      checkout_level "${cwRoot}/${modulePath}"
    fi
  done
}

#echo  "${cwRoot} ${gitDir}"
pushd ${cwRoot} &>/dev/null
verbose=0
doAdd=0 # by default do not add
typeset branchName
typeset commit=1
fallbacks=()
#set -x

while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --fallback)
      if [ -n "$2" ]; then
        noAppendArg=1
        ${fallbacks[${#fallbacks[@]}]}=$2
        shift
      else
        die "--fallback requires a non-empty option argument."
      fi
      ;;
    --fallback=?*)
      noAppendArg=1
      ${fallbacks[${#fallbacks[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --fallback=)         # Handle the case of an empty --fallback=
      die "--fallback requires a non-empty option argument."
      ;;


    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;
    -b|-B|--orphan)
      cw_echo 'ERROR: "'$1'" options is not supported for now. Create new branches using CW branch --help command' >&2
      exit 1
      ;;
    *)
      if [[ -z ${branchName} ]]; then
        branchName=$1
        noAppendArg=1
      fi
      ;;
  esac
  [[ 1 != ${noAppendArg} ]] && args+=$1
  shift
done

#set -x

checkout_level "${cwRoot}" "${branchName}"

exit 0


[[ ${#args} ]] && echo "${args[*]}"
typeset checkoutEnvironment

if [[ -n ${branchName} ]]; then
  checkoutEnvironment="switch to \""${branchName}"\""
  [[ -n ${fallback} ]] && checkoutEnvironment+=", fallback branch \""${fallback}"\""
  [[ -z ${fallback} ]] && checkoutEnvironment+=", no fallback branch "
else
  cw_echo 'ERROR: No branch name defined.' >&2
  exit 1
fi

cd ${cwRoot}
[[ 1 == ${verbose} ]] && cw_echo "$(pwd), $checkoutEnvironment"
hasBranch=()
typeset subBranch
hasBranch[0]=$(is_branch_exists "$branchName")
#set +x

if ((! ${hasBranch[0]} )); then
  cw_echo 'ERROR: branch '$branchName' does not exists in umbrella repo.
    Create it using CW branch command: branch --help' >&2
  exit 1
fi

#checking loop
#echo ${fallback}
while read -r -a line; do
  path=${line[0]}
  cd "${cwRoot}/${path}"
  checkoutMsg=$(pwd)
  subBranch=$(is_branch_exists "$branchName")
  if [[ ${subBranch} == 1 ]]; then
    subBranch=${branchName}
  fi
  if [[ 0 == ${subBranch} && -n ${fallback} ]]; then
    subBranch=$(is_branch_exists "$fallback")
    if [[ ${subBranch} == 1 ]]; then
      subBranch=${fallback}
    fi
  fi
  hasBranch+=${subBranch}
  if [[ ${subBranch} != 0 ]]; then
    checkoutMsg+=" switch to branch $subBranch"
  else
    checkoutMsg+=" branch is not changed"
  fi
  cw_echo "$checkoutMsg"
  if [[ ${subBranch} != 0 ]]; then
    git checkout "${subBranch}"
  fi
  git clean -f -d
  if [[ 1 == ${commit} ]]; then
    git commit -am "switch to branch ${branchName}"
  fi
done < <(cat ${cwTmpSubmodules})
  echo "${hasBranch[*]}"
cd ${cwRoot}
git checkout "${args} ${branchName}"
git commit -am "switch to branch ${branchName}"


: <<EOF
while read -r -a line; do
  path=${line[0]}
  cd "${cwRoot}/${path}"
  cw_echo $(pwd)
  hasBranch=$(is_branch_exists "$branchName")
  #  git checkout "${args}"
done < <(cat ${cwTmpSubmodules})
EOF

popd &>/dev/null
