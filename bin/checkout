#!/usr/bin/env bash
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
args=()

. $(dirname $0)/lib/mfs.sh
. $(dirname $0)/lib/shared_functions.sh

################################ STANDARD BOOTSTRAP CALL ################################
#set -x
umbrella_bootstrap
#set +x

cwRoot="${globals[$G_ROOT_DIR]}"
cwTmpSubmodules="${globals[$G_MODULES_FN]}"
gitDir="${globals[$G_MODULE_GIT_DIR]}"


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/} tool to manage checkouts different version onto umbrella-managed git repositories

SYNOPSIS:
    ${0##*/} --[no-]current [--[no-]recursive] ...] [[--fallback <branch1> ...] ([--[no-]push] | [--[no-]commit] | <revision|reference-resolution>) [<path-resolution>] -- <module1> ...

DESCRIPTION:
    Checkout in umbrella mode handles slightly differ from its 'git checkout' counterpart.
    First it don\'t works with file or files after -- trigger. In umbrella it will works with
    modules\' list. In absolute convention it defines modules affecting on checkout.

    Umbrella checkout processing falling into three different modes.
    1) solo mode is just revision-resolution direct or inderect reference to specific commit,
        rather than symbolic ref aka branch.
    2) if no solo mode - relative mode, if path-resolution follows to be a path relative to current directory.
    3) if path-resolution directs to the umbrella module, it will be an absolute mode, or setting it to '/'
        or if path-resolution parameter just omitted.

    For solo mode all parameters except umbrella-specific will be used as parameters for usual 'git commit ... '
    command. For two other modes usual git checkout parameters are not permitted.

    CAUTION!
    Umbrella checkout does NOT supports --branch|--orphan functionality. It is moved to
    'branch <branch-name>' to avoid over-complicated scenarios can happening in multi-repo architecture.


EXAMPLES:
    '${0##*/} master /' -> absolute mode, --no-recursive, --current, --no-commit, --no-push
        ACTION: if umbrella module branch is different from master, it will be checked out to master,
        all sub-modules will be updated to master as well

    '${0##*/} master' -> same as above

    '${0##*/} develop .' -> relative mode, --no-recursive, --current, --commit, --push
        This action may cause (or may not) enclosed module to be dirty, if previous commit differs to develop.
        ACTION: if umbrella module branch differs from develop, it will be checked out to develop,
        all sub-modules have to be updated to develop as well. If there is any module having no develop branch,
        getting warning about this, no commit (if no --force given), state of that module is not chnanged.

    '${0##*/} --fallback=develop qa' -> absolute mode, --recursive, --current, --commit, --push
        ACTION: if umbrella module branch differs from develop, it will be checked out to develop,
        all sub-modules have to be updated to develop as well. Any of module has no develop branch,
        but has develop, will be checked out to develop.

    '${0##*/} --fallback=develop --fallback=master qa' -> same as above, but if no qa and develop exists,
        change to master

    '${0##*/} master .' -> relative mode, --no-recursive, --current, --no-commit, --no-push
        Change for current module to master branch. Get warning, if enclosing repo not referencing to master.
        All options except umbrella-specific will be passed to underlying 'git checkout ...' command.

    '${0##*/} release . --commit --push' -> solo mode, --no-recursive, --current, --push
        all predecessor modules will be updated to new state, if required. After they will be committed and
        pushed to origin.

    '${0##*/} release ./wiki' -> relative mode, change branch for first sibling wiki module to 'release', --commit

    '${0##*/} release -- wiki docs' -> absolute, looking from umbrella root, doesn\'t matter deep of module.


OPTIONS:
      --help|-h|-\?
          get this help

      --[no-]push[=<remote>]
          push (or prevent) to <remote> ('origin' by default) repository.

      --[no]-commit]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --fallback[=| ]<branch>
          fallback branch name used instead of <fork-branch>, if last does not exists in sub-module

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

#echo  "${cwRoot} ${gitDir}"
#pushd ${cwRoot} &>/dev/null
typeset verbose=0
typeset doAdd=0 # by default do not add
typeset revision
typeset commit=1 force=0
typeset fallbacks=()
typeset initialPath 
#set -x

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --fallback)
      if [ -n "$2" ]; then
        noAppendArg=1
        ${fallbacks[${#fallbacks[@]}]}=$2
        shift
      else
        die "--fallback requires a non-empty option argument."
      fi
      ;;
    --fallback=?*)
      noAppendArg=1
      ${fallbacks[${#fallbacks[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --fallback=)         # Handle the case of an empty --fallback=
      die "--fallback requires a non-empty option argument."
      ;;


    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;

    --force|-f)
      force=1
      ;;
    --no-force|-F)
      force=0
      ;;

    -b|-B|--orphan)
      die "$1 options is not supported for now. Create new branches using CW 'branch ...' command" >&2
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        die "Unknown option '$1'"
      elif [[ -z ${revision} ]]; then
        revision=$1
        noAppendArg=1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac
  (( ${noAppendArg} )) && args+=$1
  shift
done


if [[ -z $revision ]]; then
  die "Parameter revision/branch required"
fi
#set -x

################################ SCRIPT SPECIFIC METHODS ################################
function checkout_level () {
  local levelRevision="$1"
  local modulePath="$2"
  local moduleName="$3"
  local levelPath="$4"
  local doUpdate="$5"
  local parentCheckBranch="$6"

  local parentCheckCommit="$7"
  local parentRevision="${parentCheckBranch}"
  if [[ -z "${parentRevision}" ]]; then
    parentRevision="${parentCheckCommit}"
  fi

  if [[ -n "${parentRevision}" ]]; then
    levelRevision="${parentRevision}"
  fi

  if [[ -z "${levelRevision}" ]]; then
    panic "$FUNCNAME: Empty revision"
  fi

  local -a modulesBefore
  local -a modulesAfter
  local -a removedModules
  local -a addedModules

  pushd "${levelPath}" &> /dev/null

#  cd "${levelPath}"
#  echo "---> checkout_level ${levelPath}"

  while read -a module; do
    modulesBefore+=("${module[0]}")
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  git checkout ${levelRevision} &> /dev/null
#  echo $?

  while read -a module; do
    modulesAfter+=("${module[0]}")
  done < <(git config --file .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  for b in ${modulesBefore[@]}; do
    local found=0
    for a in ${modulesAfter[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      removedModules[${#removedModules[@]}]="${b}"
    fi
  done

  for a in ${modulesAfter[@]}; do
    found=0
    for b in ${modulesBefore[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      addedModules[${#addedModules[@]}]="$a"
    fi
  done

  (( "${#addedModules[@]}" )) && git submodule update --checkout

  #By change branch can happen that submodules can't be removed (usually can) if, for example, if submodule has its own submodule.
  (( "${#removedModules[@]}" )) && git clean -d -f -f &> /dev/null

  # do recurse call for every sub-repos
  while read -a module; do
    local subModule="${module[0]}"
    local localPath="${module[1]}"
    local path="${levelPath}"/"${localPath}"

#      checkoutd "${path}" &> /dev/null
    local childModulePath="${modulePath}"
    if [[ ${modulePath:(-1)} != "/" ]]; then
      local childModulePath+="/"
    fi
    childModulePath+="$subModule"

    local deleted=0
    for d in ${removedModules[@]}; do
      if [[ ${d} == ${subModule} ]]; then
        deleted=1
        break
      fi
    done

#    local added=0
#    for a in ${addedModules[@]}; do
#      if [[ ${a} == ${subModule} ]]; then
#        added=1
#        break
#      fi
#    done

    if (( ! $deleted )); then
      local branchAfter=$(git config --file .gitmodules --get "submodule.${subModule}.branch" &> /dev/null)
      local commitAfter=$(git config --file .gitmodules --get "submodule.${subModule}.commit" &> /dev/null)

      checkout_level "-" "${childModulePath}" "${subModule}" "${path}" "${added}" "${branchAfter}" "${commitAfter}"
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  popd &> /dev/null
}  ## of checkout_level



function prepare_checkout_level() {
#  echo ${FUNCNAME}": $@" >&2
#  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local levelRevision="$1"
  local modulePath="$2"
  local moduleName="$3"
  local levelPath="$4"
  local toBeDeleted=$5
  local parentCheckBranch="$6"
  local parentCheckCommit="$7"
  local parentRevision="${parentCheckBranch}"
  if [[ -z "${parentRevision}" ]]; then
    parentRevision="${parentCheckCommit}"
  fi

  local -a modulesBefore
  local -a modulesAfter
  local -a removedModules

  local ret=0
  local childRet # child modules return code

  pushd "${levelPath}" &> /dev/null

### Use case when in new checkout revision the submodule not exists, but in current branch it is change
### It should be vetoed, but this veto can be disclosed only on the next call for getting if sub-module is
### commitable.
  while read -a module; do
    local after="${module[0]}"
    modulesAfter+=($after)
    local branchAfter=$(git config --blob ${levelRevision}:.gitmodules --get "submodule.${after}.branch" &> /dev/null)
    local commitAfter=$(git config --blob ${levelRevision}:.gitmodules --get "submodule.${after}.commit" &> /dev/null)
    local revisionAfter="${branchAfter}"
    if [[ -z $revisionAfter ]]; then
      revisionAfter="${commitAfter}"
    fi
    revisionsAfter+=("${revisionAfter}")
  done < <(git config --blob ${levelRevision}:.gitmodules --get-regexp "submodule.*.path" 2> /dev/null | sed -E "s/submodule\.(.*)\.path/\1/" )

  local found=0
  while read -a module; do
    local b="${module[0]}"
    modulesBefore+=("$b")
    for a in ${modulesAfter[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      removedModules+=("${b}")
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  if (( $toBeDeleted )); then
    module_porcelain_status ${0##*/}

    if [[ 0 == ${force} &&  (1 == ${MODULE_STATUS[$MS_COMMITABLE]} || 1 == ${MODULE_STATUS[$MS_UNTRACKED]} || 1 == ${MODULE_STATUS[MS_PUSHABLE]}) ]]; then
      dieMsg+="Module '$moduleName' has not committed or not pushed changes, but intended to be deleted as it does not exists in revision '$revision'"
      ret=1
    fi

  elif [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      subModule="${module[0]}"
      localPath="${module[1]}"
      local path="${levelPath}"/"${localPath}"

#      checkoutd "${path}" &> /dev/null
      local childModulePath="${modulePath}"
      if [[ ${modulePath:(-1)} != "/" ]]; then
        local childModulePath+="/"
      fi
      childModulePath+="$subModule"

      local childToBeDeleted=0
      for b in ${removedModules[@]}; do
        if [[ $subModule == $b ]]; then
          childToBeDeleted=1
          break
        fi
      done

      if (( ! childToBeDeleted )); then
        local checkBranch=$(git config --blob "${levelRevision}".gitmodules --get submodule."${subModule}".branch) 2> /dev/null
        local checkCommit=$(git config --blob "${levelRevision}".gitmodules --get submodule."${subModule}".commit) 2> /dev/null
        local checkRevision="${checkBranch}"
        if [[ -z $checkRevision ]]; then
          checkRevision="${checkCommit}"
        fi
      else
        checkRevision="?"
      fi
      prepare_checkout_level "${checkRevision}" "${childModulePath}" "${subModule}" "${path}" "${childToBeDeleted}" "${checkBranch}" "${checkCommit}"
      childRet=$?

      (( $childRet > $ret )) && ret=${childRet}
      popd  &> /dev/null

    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  popd &> /dev/null
  return ${ret}
} ## of prepare_checkout_level


################################ MAIN SCRIPT LOGIC ################################
#set -x

typeset modulePath=$(resolve_module_path "${initialPath}" "/")
read moduleName path < <(module_info "${modulePath}" "name" "path")
typeset dieMsg
typeset skippedModules=()
typeset affected=0
typeset vetoed=0
#pushd ${path} &>/dev/null
cd ${path}
git rev-parse "${revision}" &> /dev/null
(( $? )) && die "Revision '$revision' not exists in the module '$moduleName'"

prepare_checkout_level "${revision}" "${modulePath}" "${moduleName}" "${path}" 0
if (( $? )); then
  if [[ -n $dieMsg ]]; then
    die "${dieMsg}"
  fi
fi

#set -x
checkout_level "${revision}" "${modulePath}" "${moduleName}" "${path}" 0
#popd &> /dev/null can be meanwhile already removed

exit 0


[[ ${#args} ]] && echo "${args[*]}"
typeset checkoutEnvironment

if [[ -n ${revision} ]]; then
  checkoutEnvironment="switch to \""${revision}"\""
  [[ -n ${fallback} ]] && checkoutEnvironment+=", fallback branch \""${fallback}"\""
  [[ -z ${fallback} ]] && checkoutEnvironment+=", no fallback branch "
else
  cw_echo 'ERROR: No branch name defined.' >&2
  exit 1
fi

cd ${cwRoot}
[[ 1 == ${verbose} ]] && cw_echo "$(pwd), $checkoutEnvironment"
hasBranch=()
typeset subBranch
hasBranch[0]=$(is_branch_exists "$revision")
#set +x

if ((! ${hasBranch[0]} )); then
  cw_echo 'ERROR: branch '$revision' does not exists in umbrella repo.
    Create it using CW branch command: branch --help' >&2
  exit 1
fi

#checking loop
#echo ${fallback}
while read -r -a line; do
  path=${line[0]}
  cd "${cwRoot}/${path}"
  checkoutMsg=$(pwd)
  subBranch=$(is_branch_exists "$revision")
  if [[ ${subBranch} == 1 ]]; then
    subBranch=${revision}
  fi
  if [[ 0 == ${subBranch} && -n ${fallback} ]]; then
    subBranch=$(is_branch_exists "$fallback")
    if [[ ${subBranch} == 1 ]]; then
      subBranch=${fallback}
    fi
  fi
  hasBranch+=${subBranch}
  if [[ ${subBranch} != 0 ]]; then
    checkoutMsg+=" switch to branch $subBranch"
  else
    checkoutMsg+=" branch is not changed"
  fi
  cw_echo "$checkoutMsg"
  if [[ ${subBranch} != 0 ]]; then
    git checkout "${subBranch}"
  fi
  git clean -f -d
  if [[ 1 == ${commit} ]]; then
    git commit -am "switch to branch ${revision}"
  fi
done < <(cat ${cwTmpSubmodules})
  echo "${hasBranch[*]}"
cd ${cwRoot}
git checkout "${args} ${revision}"
git commit -am "switch to branch ${revision}"


: <<EOF
while read -r -a line; do
  path=${line[0]}
  cd "${cwRoot}/${path}"
  cw_echo $(pwd)
  hasBranch=$(is_branch_exists "$revision")
  #  git checkout "${args}"
done < <(cat ${cwTmpSubmodules})
EOF

popd &>/dev/null
