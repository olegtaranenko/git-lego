#!/usr/bin/env bash
globals=()
args=()

. $(dirname $0)/lib/shared_functions.sh

consistentwork_bootstrap 

cwRoot="${globals[0]}"
cwTmpSubmodules="${globals[1]}"
gitDir="${globals[2]}"

function show_help() {
  echo "TODO: write help"
}

function checkout_level () {
  local repoPath="$1"
  local repoBranch="$2"
  local -a modulesBefore
  local -a modulesAfter
  local -a removedModules
  local -a addedModules
#  oldIfs=IFS

  cd "${repoPath}"
  echo "---> checkout_level ${repoPath}"

  while IFS="#" read -a repo; do
    modulesBefore[${#modulesBefore[@]}]="${repo[2]}"
  done < <(git submodule status | sed -E 's/(.)([[:xdigit:]]{40})[[:space:]]+([[:graph:]]*).*/\1#\2#\3/' 2>/dev/null)
  git checkout ${branchName}
  echo $?

  while IFS="#" read -a repo; do
    modulesAfter[${#modulesAfter[@]}]="${repo[2]}"
  done < <(git submodule status | sed -E 's/(.)([[:xdigit:]]{40})[[:space:]]+([[:graph:]]*).*/\1#\2#\3/' 2>/dev/null)
#  IFS=${oldIfs}

  for b in ${modulesBefore[@]}; do
    found=0
    for a in ${modulesAfter[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      removedModules[${#removedModules[@]}]="${b}"
    fi
  done

  for a in ${modulesAfter[@]}; do
    found=0
    for b in ${modulesBefore[@]}; do
      if [[ $a == $b ]]; then
        found=1
        break
      fi
    done
    if (( ! $found )); then
      addedModules[${#addedModules[@]}]="$a"
    fi
  done

  printf "%s\n" "${addedModules[@]}"
  printf "%s\n" "${removedModules[@]}"

  doGitUpdate=0
  for modulePath in "${addedModules[@]}"; do
    git submodule update $modulePath
  done

  #By change branch can happen that submodules can't be removed (usually can) if, for example, if submodule has its own submodule.
  (( "${#removedModules[@]}" )) && git clean -d -f -f

  # do recurse call for every sub-repos
  for modulePath in "${modulesAfter[@]}"; do
    deleted=0
    for d in "${removedModules[@]}"; do
      if [[ ${d} == ${modulePath} ]]; then
        deleted=1
        break
      fi
    done
    if (( ! $deleted )); then
      echo "${cwRoot}/${modulePath}"
      checkout_level "${cwRoot}/${modulePath}"
    fi
  done
}

#echo  "${cwRoot} ${gitDir}"
pushd ${cwRoot} &>/dev/null
verbose=0
doAdd=0 # by default do not add
typeset branchName
typeset commit=1
#set -x

while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;
    --fallback)
      if [ -n "$2" ]; then
        noAppendArg=1
        fallback=$2
        shift
      else
        cw_echo 'ERROR: "--fallback" requires a non-empty option argument.' >&2
        exit 1
      fi
      ;;
    --fallback=?*)
      noAppendArg=1
      fallback=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --fallback=)         # Handle the case of an empty --fallback=
      cw_echo 'ERROR: "--fallback" requires a non-empty option argument.' >&2
      exit 1
      ;;
    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;
    -b|-B|--orphan)
      cw_echo 'ERROR: "'$1'" options is not supported for now. Create new branches using CW branch --help command' >&2
      exit 1
      ;;
    *)
      if [[ -z ${branchName} ]]; then
        branchName=$1
        noAppendArg=1
      fi
      ;;
  esac
  [[ 1 != ${noAppendArg} ]] && args+=$1
  shift
done

#set -x

checkout_level "${cwRoot}" "${branchName}"

exit 0


[[ ${#args} ]] && echo "${args[*]}"
typeset checkoutEnvironment

if [[ -n ${branchName} ]]; then
  checkoutEnvironment="switch to \""${branchName}"\""
  [[ -n ${fallback} ]] && checkoutEnvironment+=", fallback branch \""${fallback}"\""
  [[ -z ${fallback} ]] && checkoutEnvironment+=", no fallback branch "
else
  cw_echo 'ERROR: No branch name defined.' >&2
  exit 1
fi

cd ${cwRoot}
[[ 1 == ${verbose} ]] && cw_echo "$(pwd), $checkoutEnvironment"
hasBranch=()
typeset subBranch
hasBranch[0]=$(is_branch_exists "$branchName")
#set +x

if ((! ${hasBranch[0]} )); then
  cw_echo 'ERROR: branch '$branchName' does not exists in umbrella repo.
    Create it using CW branch command: branch --help' >&2
  exit 1
fi

#checking loop
#echo ${fallback}
while read -r -a line; do
  path=${line[0]}
  cd "${cwRoot}/${path}"
  checkoutMsg=$(pwd)
  subBranch=$(is_branch_exists "$branchName")
  if [[ ${subBranch} == 1 ]]; then
    subBranch=${branchName}
  fi
  if [[ 0 == ${subBranch} && -n ${fallback} ]]; then
    subBranch=$(is_branch_exists "$fallback")
    if [[ ${subBranch} == 1 ]]; then
      subBranch=${fallback}
    fi
  fi
  hasBranch+=${subBranch}
  if [[ ${subBranch} != 0 ]]; then
    checkoutMsg+=" switch to branch $subBranch"
  else
    checkoutMsg+=" branch is not changed"
  fi
  cw_echo "$checkoutMsg"
  if [[ ${subBranch} != 0 ]]; then
    git checkout "${subBranch}"
  fi
  git clean -f -d
  if [[ 1 == ${commit} ]]; then
    git commit -am "switch to branch ${branchName}"
  fi
done < <(cat ${cwTmpSubmodules})
  echo "${hasBranch[*]}"
cd ${cwRoot}
git checkout "${args} ${branchName}"
git commit -am "switch to branch ${branchName}"


: <<EOF
while read -r -a line; do
  path=${line[0]}
  cd "${cwRoot}/${path}"
  cw_echo $(pwd)
  hasBranch=$(is_branch_exists "$branchName")
  #  git checkout "${args}"
done < <(cat ${cwTmpSubmodules})
EOF

popd &>/dev/null
