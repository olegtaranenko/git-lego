#!/usr/bin/env bash
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################

  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

args=()

. $(dirname $0)/lib/mfs.sh
. $(dirname $0)/lib/shared_functions.sh

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap

cwRoot="${globals[$G_ROOT_DIR]}"
cwTmpSubmodules="${globals[$G_MODULES_FN]}"
gitDir="${globals[$G_MODULE_GIT_DIR]}"


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/} status in git umbrella-managed modules

SYNOPSIS:
    '${0##*/} [<any-git-commit-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${0##*/} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset verbose=0
typeset afterDash=()
typeset stopOptions=0
typeset initialPath doRecursive=0 reuse
#set -x

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done


################################ SCRIPT SPECIFIC METHODS ################################
function prepare_pull_level () {
  local modulePath="$1"
  local moduleName="$2"
  local levelPath="$3"

  pushd "${levelPath}" &> /dev/null

  drop_to_affected ${levelPath}

  # do recurse call for every sub-repos
  while read -a module; do
    local subModule="${module[0]}"
    local localPath="${module[1]}"
    local path="${levelPath}"/"${localPath}"

    local childModulePath="${modulePath}"
    if [[ ${modulePath:(-1)} != "/" ]]; then
      local childModulePath+="/"
    fi
    childModulePath+="$subModule"

    prepare_pull_level "${childModulePath}" "${subModule}" "${path}"
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  popd &> /dev/null

}  ## of pull_level


################################ MAIN SCRIPT LOGIC ################################
#set -x

typeset modulePath=$(resolve_module_path "${initialPath}" "/")
read moduleName path < <(module_info "${modulePath}" "name" "path")
typeset dieMsg
typeset skippedModules=()
typeset affected=0
typeset vetoed=0
#pushd ${path} &>/dev/null
cd ${path}

prepare_pull_level "${modulePath}" "${moduleName}" "${path}"

if (( $affected )); then

  while read -a module; do
    cd ${module[$MFS_FULL_PATH]}
    level_verbose_about_to ${module[@]}

    git pull "${args[@]}"
  done < <(cat ${globals[$G_AFFECTED_MODULES]} | tail -r)
fi

if (( ${#skippedModules} )); then
  cw_echo "Not affected modules: ${skippedModules[*]}"
fi

popd &>/dev/null
umbrella_finalize

exit $ret
