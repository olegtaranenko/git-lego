#!/usr/bin/env bash
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################

  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

args=()

. $(dirname $0)/lib/shared_functions.sh

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap

cwRoot="${globals[$G_ROOT_DIR]}"
cwTmpSubmodules="${globals[$G_MODULES_FN]}"
gitDir="${globals[$G_MODULE_GIT_DIR]}"


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${0##*/} status in git umbrella-managed modules

SYNOPSIS:
    '${0##*/} [<any-git-commit-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${0##*/} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

#echo  "${cwRoot} ${gitDir}"
typeset verbose=0
typeset afterDash=()
typeset stopOptions=0
typeset initialPath commitMessage commitTemplate doRecursive=0 reuse doAppendUntracked=0
#set -x

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;

    -R)
      doRecursive=1
      ;;
    --recursive)
      doRecursive=1
      ;;
    --no-recursive)
      doRecursive=0
      ;;

    -[amFtscC]*)
      args+=($1)
      #getopts emulation -am...
      lastOption=${1:(-1)}
      if [[ $lastOption == "m" ]]; then
        args+=("\"$2"\")
        commitMessage=$2
        shift
      elif [[ $lastOption == "t" ]]; then
        args+=("\"$2"\")
        commitTemplate=$2
        shift
      elif [[ $lastOption == "c" || $lastOption == "C"  || $lastOption == "F" ]]; then
        args+=("\"$2"\")
#        reuse=$2
        shift
#      else
        # TODO ?? change behaviour for -a|--add option
        # in umbrella it will add untracked files as well
      fi
      ;;

    --append-untracked)
      doAppendUntracked=1
      ;;
    --message)
      args+=($1)
      args+=("\"$2\"")
      commitMessage=$2
      shift
      ;;
    --message=*)
      commitMessage=${1#*=}
      [[ -z ${commitMessage} ]] && die "message is not given $1"
      args+=("\"$1\"")
      ;;

    --template)
      args+=($1)
      commitTemplate=$2
      shift
      ;;
    --template=*)
      commitTemplate=${1#*=}
      [ -z ${commitTemplate} ] && die "template is not given $1"
      args+=($1)
      ;;
    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done
#set +x
#echo "args: ${args[*]}, message: \"$commitMessage\", template: \"$commitTemplate\", path: $initialPath, afterDash: ${afterDash[*]}, -R: $doRecursive"
#set -x
#cat "${cwTmpSubmodules}"


################################ SCRIPT SPECIFIC METHODS ################################
function about_to_commit_level {

  local path=$4
  local info="about to commit module '${1}'"
  local verboseMsg=([1]="path: $path")
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local fineIssues infoIssues
  verboseMsg[0]=${info}
#set +x
  cw_echo "${verboseMsg[@]}"

}

function prepare_commit_level() {
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "status_level()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is syncronized
  local childRet # child return code
  local include=0

#set +x
  module_porcelain_status
#set -x

  if (( ${MODULE_STATUS[$MS_COMMITABLE]} )); then
    while read -a module; do
      local moduleName=${module[$MFS_MODULE_NAME]}
      local fullPath=${module[MFS_FULL_PATH]}
      if [ "$levelPath" == "$fullPath" ]; then
        include=1
        if (( ${#afterDash[@]} )); then
          local found=0
          for dash in ${afterDash[@]}; do
            # exact comparison, not matching
            if [ "${moduleName}" = "${dash}" ]; then
              found=1
              break
            fi
          done
          if (( ! ${found} )); then
            include=0
          fi
        fi

        (( $include )) && break
      fi

    done < <(cat ${globals[$G_MODULES_FN]})
  fi

  if (( $include )); then
    affected=1
    [[ -z ${commitMessage} ]] && onEmptyMessage+="${moduleName}, "
    echo ${module[@]} >> ${globals[$G_AFFECTED_MODULES]}
  fi

  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      subModule="${module[0]}"
      checkBranch=$(git config --file .gitmodules --get submodule."${subModule}".branch)
      localPath="${module[1]}"
      subRepoPath="${levelPath}"/"${localPath}"

      pushd "${subRepoPath}" &> /dev/null
#      break
      local modulePath="$3" #/$subModule"
      if [[ ${modulePath:(-1)} != "/" ]]; then
        modulePath+="/"
      fi
      modulePath+="$subModule"

      prepare_commit_level "${subRepoPath}" "${subModule}" "${modulePath}"
      childRet=$?
      (( $childRet > $ret )) && ret = ${childRet}
      popd  &> /dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi
}

################################ MAIN SCRIPT LOGIC ################################
#set -x
typeset modulePath=$(resolve_module_path "${initialPath}")
typeset resolvedPath=$(module_2_full_path "${modulePath}")
typeset affected=0
typeset onEmptyMessage
[[ -z ${commitMessage} ]] && onEmptyMessage="commit for umbrella ${globals[$G_ROOT_NAME]}, affected modules: "

pushd ${resolvedPath} &>/dev/null
baseModulePath=$(pmd)
prepare_commit_level "${resolvedPath}" "${globals[$G_ROOT_NAME]}" "${baseModulePath}"

if (( $affected )); then
  if [[ -z ${commitMessage} && -n ${onEmptyMessage} ]]; then
   args+=('--message' )
   args+=(" \"${onEmptyMessage:0:(${#onEmptyMessage}-2)})\"")
  fi

cat ${globals[$G_AFFECTED_MODULES]}


  while read -a module; do
    cd ${module[$MFS_FULL_PATH]}
    pwd
    about_to_commit_level ${module[@]}
    echo "git commit ${args[@]} ${#args[@]}"
    (( $doAppendUntracked )) && git add . -A
    git commit "${args[@]}"
  done < <(cat ${globals[$G_AFFECTED_MODULES]} | tail -r)
fi
popd &>/dev/null
umbrella_finalize

exit 0
