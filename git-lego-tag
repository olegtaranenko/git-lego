#!/usr/bin/env bash
set +o posix

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git umbrella-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'
    '${FLAGS_PREFIX} [--force|-f] [--all|-a|--solo|--versioned] [--[no-]recursive|-R|-r] [<module-path>]'

DESCRIPTION:

EXAMPLES:


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset args=()
typeset verbose=0
typeset afterDash=()
typeset stopOptions=0
typeset doCheckout=0
typeset doRecursive=0 
typeset doForce=0

# is defined in git-lego
#typeset initialPath

# git tag [-a] <tag-name> [<base-commit] [<module-path>]
# base-commit have to be a refname, sha
# <module-path> - initialPath
# set implicitly for $initialPath - HEAD
typeset baseCommit
typeset givenBaseCommit=0
typeset maxParameters=3
typeset minParameters=0
# initial path can be set as a global --initial-path=<module-path> command parameter
typeset numParameters=0
typeset givenParameters=()

typeset modulePath
typeset moduleName
typeset moduleFilePath 
typeset moduleInitialized
typeset moduleGitDir

typeset tagName
#without -d -l and other options do set tag
typeset doTag=0
#without parameters doing list of all tags
typeset doList=0
typeset doDelete=0
typeset doVerify=0
# string representation of the 'tag' command
typeset currentCommand

typeset message
typeset messageDefined=0
typeset messageRequired=0
typeset affectedModules=()
#typeset emptyMsgNotAllowed="Empty message not allowed" moved to git-lego
typeset tagMissedMsg="Tag name is missed"

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    --)
      stopOptions=1
      ;;

    --message|-m)
      messageDefined=1
      args+=("$1")
      shift
      if [[ -n "$1" ]]; then
        args+=("\"$1\"")
      fi
      ;;

    --delete|-d)
      doDelete=1
      args+=("$1")
      minParameters=1
      maxParameters=2
      ;;

    --verify)
      doVerify=1
      minParameters=1
      maxParameters=2
      args+=("$1")
      ;;

    --list|-l)
      doList=1
      args+=("$1")
      minParameters=0
      maxParameters=2
      ;;

    --checkout|-c)
      doCheckout=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --base-commit=*)
      if (( ! "${#baseCommit}" )); then
        baseCommit="${1#--base-commit=}"
        if [[ -z "$baseCommit" ]]; then
          die "missed base commit"
        fi
        maxParameters=$(( $maxParameters - 1 ))
        givenBaseCommit=1
      else
        die "base commit already defined!"
      fi
      ;;

    --base-commit)
      if (( ! "${#baseCommit}" )); then
        case "$2" in
          '')
            die "missed base commit"
            ;;
          *)
            baseCommit="$2"
            shift
            ;;
        esac
        maxParameters=$(( $maxParameters - 1 ))
        givenBaseCommit=1
      else
        die "base commit already defined!"
      fi
      ;;

    --force|-f)
      doForce=1
      args+=("$1")
      ;;
    --no-force)
      doForce=0
      ;;

    --local-user=*)
      messageRequired=1
      args+=("$1")
      ;;
    -u)
      messageRequired=1
      args+=("$1")
      shift
      if [[ -z "$1" ]]; then
        die "keyid for signing missed"
      fi
      args+=("$1")
      ;;

    --annotate|-a|--sign|-s)
      messageRequired=1
      args+=("$1")
      ;;

    *)
      if (( "$stopOptions" )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=("$1")
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
        # detect -m option inside of ie. -am
        if (( ! "$messageDefined" )) ; then
          messageDefined=$( echo "$1" | grep -c m 2>/dev/null )
          if (( "$messageDefined" )); then
            shift
            if [[ -z "$1" ]]; then
               die "$emptyMsgNotAllowed"
            fi
            args+=("\"$1\"")
          fi
        fi
      else
        givenParameters+=("$1")
      fi
      ;;
  esac

  shift
done

if [[ -n "$initialPath" ]]; then
  maxParameters=$(( $maxParameters - 1 ))
fi

if (( ${#givenParameters[@]} > $maxParameters ))  || (( ${#givenParameters[@]} < $minParameters )) ; then
  die_usage "tag" "wrong extra parameters"
fi

if [[ -z "${givenParameters[0]}" ]]; then
  doList=1
  currentCommand="list"
else
  commandScore=$(( $doList + $doDelete + $doTag + $doVerify ))

  currentCommand=$( which_command "list delete verify tag")
  if (( ! "$commandScore" )); then
    doTag=1
    currentCommand="tag"
  elif (( "$commandScore" > 1 )); then
    die_usage "tag" "incompatible options: $currentCommand"
  fi

  for theParam in "${givenParameters[@]}"; do
    unset resolvedToken
    if [[ -z "$initialPath" ]]; then
      # only one parameter, either tag or module for list
      resolvedToken=$( path_or_revision "$theParam" )
      isPath=$?
      if (( "$isPath" )); then
        initialPath="$resolvedToken"
      else
        unset resolvedToken
      fi
    fi

    if [[ -z "$resolvedToken" ]]; then
      if [[ -z "$tagName" ]]; then
        tagName="$theParam"
      elif [[ -z "$baseCommit" ]]; then
        baseCommit="$theParam"
      else
        die
      fi
    fi
  done
fi



################################ SCRIPT SPECIFIC METHODS ################################
tag_level() {
#set -x
  local levelFilePath="$1"
  [[ -z ${levelFilePath} ]] && panic "$FUNCNAME()... parameter 'path' is required"

  local moduleName="$2"
  local modulePath="$3"

  local ret=0   # return code
  local childRet=0 # child return code

  while read -a module; do
    local subModulePath="${module[$MFS_MODULE_PATH]}"
    local subModuleName="${module[$MFS_MODULE_NAME]}"
    cd "${module[$MFS_FULL_PATH]}"
    git tag ${tagName}${baseCommit:+ $tagCommit} "${args[@]}"
    childRet=$?

    local actionDone
    if (( ! "$doDelete" )); then
      actionDone="added to"
    else
      actionDone="removed from"
    fi
    cw_echo "Tag '$tagName' $actionDone '$subModulePath'"

    if (( "$childRet" > "$ret" )) ; then
      ret="$childRet"
      break
    else

      if [[ "$subModulePath" != "/" ]]; then
        if (( "$doCheckout" )); then
          local legoMode modeImplicit
          local parentModulePath=$( get_module_path_up "$subModulePath" )
          read legoMode modeImplicit < <( module_info "$parentModulePath" "lego_mode" "lego_mode_implicit" )
          if (( ! "$doDelete" )); then
            if [[ "$legoMode" != "solo" ]] && [[ "$legoMode" != "versioned" ]] ; then
              legoMode="solo"
            fi
            persist_attain_hint "1" "$subModuleName" "$tagName" "pinned" "$legoMode"
          else
            local section="submodule.$subModuleName"
            local key="refname"
            local possibleTag=$( get_lego_setting_mode "$key" "$section" "$legoMode" )
            if [[ "$possibleTag" == "refs/tags/$tagName" ]]; then
              wipe_lego_setting_at_mode "$key" "$section" "$legoMode" ".."
            fi
          fi
        fi
      else
        if (( ! "$doDelete" )) && (( "$doCheckout" )); then
          git checkout "$tagName"
        fi
      fi

    fi
  done < <(cat ${globals[$G_AFFECTED_MODULES]} | (tac 2>/dev/null || tail -r))

  return "$ret"
}


prepare_tag_level() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local levelFilePath="$1"
  [[ -z "$levelFilePath" ]] && panic "$FUNCNAME()... parameter 'path' is required"

  local moduleName="$2"
  local modulePath="$3"

  local ret=0            # return code
  local affected=0
  local applied=1

  local tagExists=$( git tag -l | grep -Ec "^$tagName$" 2>/dev/null )
  ret=$?

  if (( ! "$doDelete" )) && (( "$tagExists" )) && (( ! "$doRecursive" )) && (( ! "$doForce" )); then
    dieMsg="Tag '$tagName' already exists in module '$moduleName' (at least), use --force to override it"
    ret=1
  else
    if [[ ( "$tagExists" == 0 || "$doForce" == 1 ) && "$doDelete" == 0 ]] || [[ "$tagExists" == 1 && "$doDelete" == 1  ]]; then
      drop_to_affected "$levelFilePath"
      applied=$?

      if (( ! "$applied" )); then
        affectedModules+=("$moduleName")
        affected=1
      fi
    fi
  fi

  if (( "$doRecursive" )) && (( ! "$ret" )); then
    if [[ -f .gitmodules && "$doRecursive" ]]; then
      while read -a module; do
        local childRet=0       # child return code
        local moduleName="${module[0]}"
        local localPath="${module[1]}"

        local subRepoPath="${levelFilePath}"/"${localPath}"
        local subModulePath="$modulePath"
        [[ "${subModulePath:(-1)}" != "/" ]] && subModulePath+="/"
        subModulePath+="$moduleName"
        read initialized managed < <( module_info "$subModulePath" "initialized" "managed" )

        if (( "$initialized" )); then
          pushd "${subRepoPath}" &>/dev/null
          prepare_tag_level "$subRepoPath" "$moduleName" "$subModulePath"
          childRet=$?
          popd  &>/dev/null

          (( "$childRet" > "$ret" )) && ret="$childRet"
        fi
      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi
  fi

  return "$ret"
}

################################ MAIN SCRIPT LOGIC ################################
#
# callback to detect what command should be called
#
dispatch_subaction() {
  local ret="$currentCommand"
  if [[ "$ret" == "delete" ]]; then
    ret="tag"
  fi
  echo "$ret"
}


cmd_list() {
  local ret=0

  die_not_implemented_yet "$currentCommand"

  umbrella_finalize
  return "$ret"
}

cmd_verify() {
  local ret=0
  if (( ! "${#tagName}" )); then
    dieMsg="$tagMissedMsg"
    ret=1
  fi

  die_not_implemented_yet "$currentCommand"
  umbrella_finalize
  return "$ret"
}

cmd_tag() {

  local ret=0

  if (( ! "${#tagName}" )); then
    dieMsg="$tagMissedMsg"
    ret=1
  fi

  if (( "$moduleInitialized" )) && (( ! "$ret" )) ; then
    cd "$moduleFilePath"
    prepare_tag_level "$moduleFilePath" "$moduleName" "$modulePath"
    ret=$?

    if (( "$messageRequired" )) && (( ! "$messageDefined" )) ; then
      local editMsgFile="${globals[$G_SCRIPT_TMP_DIRECTORY]}/COMMIT_EDITMSG"
      eAffected=$( IFS=','; echo "${affectedModules[*]}" )

      cat << EOT >> "$editMsgFile"
# ${0##*/}: Affected modules
#   $eAffected
# Write a message for tag:
#   $tagName
# Lines starting with '#' will be ignored.
EOT

      git_editor "$editMsgFile"
      ret=$?

      if (( ! $ret )); then
        message=$( cat "$editMsgFile" | grep -vE "^#.*$" )
        if (( ! "${#message}" )); then
          dieMsg="$emptyMsgNotAllowed"
          ret=1
        else
          echo "$message" > "$editMsgFile"
          args+=("-F")
          args+=("$editMsgFile")
        fi
      fi
    fi

    if (( ! "$ret" )) && (( "${#affectedModules[@]}" )); then
      tag_level "$moduleFilePath" "$moduleName" "$modulePath"
      ret=$?
    fi
  fi

  if (( "$ret" )) && (( "${#dieMsg}" )); then
    cw_echo "$dieMsg"
  fi
  umbrella_finalize
  return "$ret"
}
