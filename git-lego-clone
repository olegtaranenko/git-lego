#!/usr/bin/env bash
set +o posix
################################ OPTIONAL INPUT PARAMETERS ################################
typeset repoUrl
typeset repoPath


usage() {
  if test -n $1; then
    echo $1
  fi
  cat << EOF

    usage: ${FLAGS_PREFIX} [--[no-]auto-attach|-a|-A] [--attach-hint <module:branch>...] [-- <git-parameters-for-git-clone>]
EOF
  exit
}

typeset autoAttach=0
typeset attachHints=()
typeset doForce=0
typeset verbose=0
typeset doInit=0
typeset branchName wrongBranch branch=0
typeset nameName wrongName name=0
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      usage
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

		-f | --force)
			doForce=$1
			;;

		-b | --branch)
			branch=1
			case $2 in
        '' | -*)
          wrongBranch=1
          ;;
        *)
			    branchName=$2
          shift
          ;;
			esac
			;;
		--branch=*)
			branchName="${1#--branch=}"
			;;

		--name)
			name=1
			case $2 in
        '' | -*)
          wrongName=1
          ;;
        *)
			    nameName=$2
          shift
          ;;
			esac
			;;
		--name=*)
			nameName="${1#--name=}"
			;;


    --auto-attach|-a)
      autoAttach=1
      ;;
    --no-auto-attach|-A)
      autoAttach=0
      ;;
    --attach-hint)
        case "$2" in '') usage "$1 parameter requires further value" ;; esac
        attachHints+=("$2")
        shift
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --)
      stopOptions=1
      args+=("$1")
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          if [[ -z "$repoUrl" ]]; then
            args+=("$1")
            repoUrl="$1"
          elif [[ -z "$repoPath" ]]; then
            args+=("$1")
            repoPath="$1"
          fi
        fi
      elif [[ -z "${1%%-*}" ]]; then
        args+=("$1")
      elif [[ -z "$repoUrl" ]]; then
        args+=("$1")
        repoUrl="$1"
      elif [[ -z "$repoPath" ]]; then
        args+=("$1")
        repoPath="$1"
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done

if [[ -z ${repoUrl} ]]; then
  die "Repo parameter not recognized"
fi

if (( $branch )); then
  if (( $wrongBranch )) || [[ -z $branchName ]] ; then
    die "Wrong branch name"
  else
    args+=(--branch "$branchName")
  fi
fi


if (( "$name" )); then
  if (( "$wrongName" )) || [[ -z "$nameName" ]] ; then
    die "Wrong module name"
  else
    # TODO check name for uniqueness before allow make the git submodule add --name
    args+=(--name "$nameName")
  fi
fi


################################ MAIN SCRIPT LOGIC ################################
#
# callback to detect what command should be called
#
typeset parentGitDir

dispatch_subaction() {
  local parentGitDir=$( git rev-parse --git-dir 2>/dev/null)
  if [[ -n "$parentGitDir" ]]; then
    echo "submodule_add"
  else
    echo "clone"
  fi
}


# instead of cloning as a separate repo, redirect to 'git submodule add' and
# this repo as a submodule in git-lego construction
cmd_submodule_add() {
#echo "$FUNCNAME() $@" >&2
echo "$FUNCNAME() args from command line: ${args[@]}" >&2

  umbrella_bootstrap
  cmd_default 0

  local ret=$?
  if (( ! $ret )); then
    local parentModule=0
    local index=0
    local found=0

    for gitDir in "${g_git_dirs[@]}"; do

      if [[ "$gitDir" == "$parentGitDir" ]]; then
        local parentPath="${g_module_paths[$index]}"

        if [[ "$parentPath" == "/" ]]; then
          parentModule="root project"
        else
          parentModule="'${g_module_name[$index]}'"
        fi
        found=1

        break
      fi

      index=$(( $index + 1 ))
    done

    cw_echo "Repo $repoUrl was added as a submodule to $parentModule"
    ### TODO stop working on git clone -> git submodule add...
    ## there ar a ton of possible improvements, like
    #    * fix cached arrays for further processing
    #    * attain after adding
    #    * checkout with submodules, if added repos has submodules as well
    #    *
    #    *
    #  But all of this not urgent necessary. It can be completed with 'git-lego attain --branch= ...'
    #  git-lego checkout ...
    #  etc.
    #
    # Maybe later...
    #
    #
  fi

  return "$ret"
}


cmd_clone() {
#echo "$FUNCNAME() args from command line: ${args[@]}" >&2
  cmd_default 1
}


cmd_default() {
  declare ret=0
  declare doClone="$1"

  # no explicit destination repository given
  # take from last created directory
  local lsBefore=()
  if [[ -z "$repoPath" ]]; then
    while read -d $'\0' fn; do
      lsBefore+=("$fn")
    done < <( find . -maxdepth 1 -type d -print0 )
  fi
  echo "${lsBefore[@]}"

  if (( "$doClone" )); then
    cw_echo "Redirect to 'git clone'"
    git clone "${args[@]}"
    ret=$?

    if (( "$ret" )); then
       die "Unrecoverable error by 'git clone ${args[@]}'"
    fi

  else
    cw_echo "Redirect to 'git submodule add ...'"
    git submodule add "${args[@]}"
    ret=$?

    if (( "$ret" )); then
       die "Unrecoverable error by 'git submodule add ${args[@]}' "
    fi
  fi

  if [[ -z "$repoPath" ]]; then
    while read -d $'\0' after; do
      local found=0

      for before in "${lsBefore[@]}"; do
        if [[ "$before" == "$after" ]]; then
          found=1
          break
        fi
      done

      if (( ! $found )); then
        repoPath="$after"
        break
      fi

    done < <(find . -maxdepth 1 -type d -print0 )
  fi


  if (( "$doClone" )); then
    cd "$repoPath"

    umbrella_bootstrap

    local moduleFilePath="${globals[$G_ROOT_DIR]}"
    local moduleName="${globals[$G_ROOT_NAME]}"
    local modulePath="/"

    splash "$modulePath"

    if [[ -z "$branchName" ]]; then
      read branchName type < <( evaluate_refname )
    fi

    typeset attainOnCheckout=1
    typeset updateManagedRef=0
    checkout_level "$branchName" "branch" "$moduleName" "$modulePath"  "$moduleFilePath"
    ret=$?
  fi
#  update_level "$moduleFilePath" "$moduleName" "$modulePath" "." "$branchName"


  umbrella_finalize
  exit "$ret"
}

cmd_help() {
	usage
	exit 0
}