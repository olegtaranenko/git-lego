#!/usr/bin/env bash
set +o posix
################################ OPTIONAL INPUT PARAMETERS ################################
typeset repoUrl
typeset repoPath


usage() {
  if test -n $1; then
    echo $1
  fi
  cat << EOF

    usage: ${FLAGS_PREFIX} [--[no-]auto-attach|-a|-A] [--attach-hint <module:branch>...] [-- <git-parameters-for-git-clone>]
EOF
  exit
}

typeset autoAttach=0
typeset attachHints=()
typeset doForce=0
typeset verbose=0
typeset doInit=0
typeset branchName wrongBranch branch=0
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      usage
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

		-f | --force)
			doForce=$1
			;;

		-b | --branch)
			branch=1
			case $2 in
        '' | -*)
          wrongBranch=1
          ;;
        *)
			    branchName=$2
          shift
          ;;
			esac
			;;
		--branch=*)
			branchName="${1#--branch=}"
			;;


    --auto-attach|-a)
      autoAttach=1
      ;;
    --no-auto-attach|-A)
      autoAttach=0
      ;;
    --attach-hint)
        case "$2" in '') usage "$1 parameter requires further value" ;; esac
        attachHints+=("$2")
        shift
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --)
      stopOptions=1
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${repoUrl} ]]; then
        args+=($1)
        repoUrl=$1
      elif [[ -z ${repoPath} ]]; then
        args+=($1)
        repoPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done

if [[ -z ${repoUrl} ]]; then
  die "Repo paramenter not recognized"
fi

if (( $branch )); then
  if (( $wrongBranch )) || [[ -z $branchName ]] ; then
    die "Wrong branch name"
  else
    args+=(--branch $branchName)
  fi
fi



cmd_default() {
  ################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
    #
    ## Exit code of the script
    ## 0 - success
    ## 1 - un-success (bad options/... etc)
    ## 2 - unexpected error (wrong code)
    #
  declare ret=0

  #set -x

  # Maybe we trying to cloning inside of the existing branding repo?
  # Right now it doesn't permitted
  git rev-parse --git-dir &> /dev/null
  if (( ! $? )); then
    # TODO instead of 'cloning' add repo as submodule
  #  die "It's not permitted to clone inside of an existing git repo. Look in "$(dirname $0)"/Readme.MD for more information"
    exit 0
  fi

  #set -x
#  echo ${args[@]} >&2

  # no explicit destination repository given
  # take from last created directory
  local lsBefore=()
  if [[ -z "$repoPath" ]]; then
    while read -d $'\0' fn; do
      lsBefore+=("$fn")
    done < <( find . -type d -maxdepth 1 -print0 )
  fi
  echo "${lsBefore[@]}"

  cw_echo "Redirect to 'git clone'"
  git clone "${args[@]}"
  ret=$?

  if (( $ret )); then
     die "Unrecoverable error by cloning"
  fi

  if [[ -z "$repoPath" ]]; then
    while read -d $'\0' after; do
      local found=0

      for before in "${lsBefore[@]}"; do
        if [[ "$before" == "$after" ]]; then
          found=1
          break
        fi
      done

      if (( ! $found )); then
        repoPath="$after"
        break
      fi

    done < <(find . -type d -maxdepth 1 -print0 )
  fi


  cd "$repoPath"

  umbrella_bootstrap

  local moduleFilePath="${globals[$G_ROOT_DIR]}"
  local moduleName="${globals[$G_ROOT_NAME]}"
  local modulePath="/"

  splash "$modulePath"

  if [[ -z "$branchName" ]]; then
    read branchName type < <( evaluate_refname )
  fi

  typeset attainOnCheckout=1
  typeset updateManagedRef=0
  checkout_level "$branchName" "branch" "$moduleName" "$modulePath"  "$moduleFilePath"
#  update_level "$moduleFilePath" "$moduleName" "$modulePath" "." "$branchName"


  umbrella_finalize
  exit ${ret}
}

cmd_help() {
	usage
	exit 0
}