#!/usr/bin/env bash
set +o posix

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} status in git umbrella-managed modules

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'
    '${FLAGS_PREFIX} [--force|-f] [--all|-a|--solo|--versioned] [--[no-]recursive|-R|-r] [<module-path>]'

DESCRIPTION:

EXAMPLES:


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset verbose=0
typeset afterDash=()
typeset stopOptions=0
typeset initialPath doRecursive=1 doForce=1 cleanSolo=0 cleanVersioned=0

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force)
      doForce=0
      ;;

    --all|-a)
      cleanSolo=1
      cleanVersioned=1
      ;;
    --solo)
      cleanSolo=1
      ;;
    --versioned)
      cleanVersioned=1
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=($1)
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done
#set +x

declare modesMask=0

#set -x
if (( ! $cleanSolo )) && (( ! $cleanVersioned )); then
  currentMode="${g_lego_mode}"
  case $currentMode in
    solo)
      cleanSolo=1
      ;;
    versioned)
      cleanVersioned=1
      ;;
    *)
      die "Looks like the repositories already cleaned. '${FLAGS_PREFIX} --help' for other options"
  esac
fi

if (( $cleanSolo )) || (( $cleanVersioned )); then
  (( $cleanSolo )) && modesMask=$(( $modesMask | $G_MODE_MASK_SOLO ))
  (( $cleanVersioned )) && modesMask=$(( $modesMask | $G_MODE_MASK_VERSIONED ))
fi

################################ SCRIPT SPECIFIC METHODS ################################


clean_level() {
#echo "$FUNCNAME()" $@ >&2
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"

  local moduleName="$2"
  local modulePath="$3"

  local ret=0   # return code
  local childRet # child return code

#  set -x
#  pwd >&2

  if (( $cleanVersioned )); then
    if [[ -e .gitlego ]]; then
      rm -f .gitlego
    fi
  fi

  if (( $cleanSolo )); then
    clean_git_config_section ${G_MODE_MASK_SOLO} lego
  fi

  if [ -f .gitmodules ]; then
    while read -a module; do
      childRet=0
      local moduleName="${module[0]}"
      local localPath="${module[1]}"
      local subRepoPath="${levelPath}"/"${localPath}"
      if [[ ${modulePath:(-1)} != "/" ]]; then
        modulePath+="/"
      fi

      modulePath+="$moduleName"

      clean_module_meta_mask "${moduleName}" "${modesMask}"

      read initialized < <( module_info ${modulePath} initialized )

      if (( $initialized )) ; then

        pushd "${subRepoPath}" &> /dev/null
        clean_level "$subRepoPath" "$moduleName" "$modulePath"
        childRet=$?

        (( $childRet > $ret )) && ret = ${childRet}
      fi
      popd  &> /dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi
}


################################ MAIN SCRIPT LOGIC ################################
#
# callback to detect what command should be called
#
#dispatch_subaction() {
#  echo clean
#}
cmd_default() {
  typeset modulePath=$(resolve_module_path "${initialPath}" /)
  read moduleName moduleFilePath < <(module_info "${modulePath}" "name" "path")

  pushd ${moduleFilePath} &>/dev/null
  clean_level "${moduleFilePath}" "${modulePath}"
  popd &>/dev/null

  umbrella_finalize
}