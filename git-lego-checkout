#!/usr/bin/env bash
set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
args=()

################################ STANDARD BOOTSTRAP CALL ################################
#set -x
umbrella_bootstrap
#set +x


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
# TODO staled help... need to be rewritten
cat << EOF

NAME:
    ${FLAGS_PREFIX} tool to checkout different version onto git-lego managed repositories

SYNOPSIS:
    ${FLAGS_PREFIX} [--[no-]recursive] ...] ([--[no-]push] | [--[no-]commit] | <revision|reference-resolution>) [<path-resolution>] [-- <module1> ... ]
    ${FLAGS_PREFIX} --follow-heads=[parent|managed] [-- <module1> <module2> ... ]

DESCRIPTION:
    Lego checkout handles slightly different from its 'git checkout' counterpart.

    First, it don\'t works with file or files after -- trigger. Instead git-lego works at modules\' level only and defines modules being affected.

    Second, git-lego is very sensitive to which type of reference is going to be checked out, either assigned to branch (headed mode) or
      to the detached state via tag, remote branch, plain hash, etc. In case of headed references, checkout tries to attain or update
      sibling modules according to some useful conventions, which drastically spare time to further manipulating with submodules\' states.
      If outer module is


    git-lego checkout processing starts at current module, if no module resolution parameter is present.

    For solo mode all parameters except umbrella-specific will be used as parameters for usual 'git commit ... '
    command. For two other modes usual git checkout parameters are not permitted.


EXAMPLES:

OPTIONS:
      --help|-h|-\?
          get this help

      --[no]-commit]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --[no-]push[=<remote>]
          push (or prevent to push) to <remote> ('origin' by default) repository.

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

typeset verbose=0  stopOptions=0
#typeset doAdd=0 # by default do not add
typeset revision
typeset commit=0 doForce=0
#typeset fallbacks=()
typeset initialPath

# possible values for follow-heads option
#   parent - update sibling
#   mananged - for versioned version only, update
#   none - (default)
typeset followHeads=$( get_lego_setting "followHeads" )
followHeads=$( READ_string "$followHeads" "none" ) # by default - do not follow heads

typeset autoAttain=$(get_lego_setting "autoAttain")
autoAttain=$(READ_boolean ${autoAttain} 1) # 1 === true
typeset paramAutoAttain implicitAuto=0


################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --)
      stopOptions=1
      ;;

    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;

    --follow-heads=*)
      followHeads="${1#--follow-heads=}"
      ;;
    --no-follow-heads)
      followHeads=0
      ;;

    --auto-attain|-a)
      paramAutoAttain=1
      ;;
    --no-auto-attain|-A)
      paramAutoAttain=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force|-F)
      doForce=0
      ;;

    -b|-B|--orphan)
      die "$1 options is not supported for now. Create new branches using 'branch ...' command" >&2
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        die "Unknown option '$1'"
      elif [[ -z ${revision} ]]; then
        revision=$1
        noAppendArg=1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac

#  (( ${noAppendArg} )) && args+=($1)
  shift
done


if [[ -z "$revision" ]]; then
  die "Parameter revision/branch required"
fi
#set -x

################################ SCRIPT SPECIFIC METHODS ################################
checkout_level () {
echo "$FUNCNAME()" $@ >&2

  local revision="$1"
  local moduleName="$2"
#  [[ "$moduleName" == "macosx" ]] && set -x
  local modulePath="$3"
  local levelPath="$4"
  local parentRefname="$5"
  local parentRefType="$6"

  if [[ -z "$parentRefname" && "$revision" != "-" ]]; then
    parentRefname="$revision"
  fi
  if [[ -n "$parentRefname" && -z "$parentRefType" ]]; then
    parentRefType=$( get_reftype_of_refname "$parentRefname" )
  fi
  local refType="$parentRefType"

  pushd "$levelPath" &>/dev/null

  local modulesBefore=()
  local modulePathsBefore=()
  local modulesAfter=()
  local modulePathsAfter=()
  local hashesAfter=()
  local addedModules=()
  local deletedModules=()
  local movedModules=()

  local ret=0
  
  prepare_checkout_level "$revision" "$moduleName" "$modulePath" "$levelPath" "$parentRefname" "$parentRefType"
  ret=$?

#  echo "before: ${modulesBefore[@]}" >&2
#  echo "paths before: ${modulePathsBefore[@]}" >&2
#  echo "after: ${modulesAfter[@]}" >&2
#  echo "paths after: ${modulePathsAfter[@]}" >&2
#  echo "to add: ${addedModules[@]}" >&2
#  echo "to delete: ${deletedModules[@]}" >&2
#  echo "ret: ${ret}" >&2

  if (( ! $ret )); then

    local addedFound
    local beforeIndex afterIndex
    local added deleted before subModule before pathAdded
    if (( "${#deletedModules[@]}" )); then
      local deletedIndex=0

      for deleted in "${deletedModules[@]}"; do
        local deletedFound=0
        local beforeIndex=0

        for subModule in "${modulesBefore[@]}"; do
          if [[ "$subModule" == "$deleted" ]]; then
            pathDeleted="${modulePathsBefore[$beforeIndex]}"
            deletedFound=1
            break
          fi
          beforeIndex=$(( $beforeIndex + 1 ))
        done

        if (( $deletedFound )); then
          read initialized < <(module_info "$pathDeleted" "initialized")
          if (( $initialized )) ; then
            git submodule deinit -- "$deleted"
          fi
        fi

        deletedIndex=$(( $deletedIndex + 1 ))
      done
    fi

    if [[ -n "${MODULE_STATUS[$MS_MANAGED_REFNAME]}" && "$revision" == "-" ]]; then
      revision="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
      managed="${MODULE_STATUS[$MS_MANAGED]}"
      refType="${g_lego_aware_tokens_gitmodules[$managed]}"
    fi

    git checkout "$revision"
    ret=$?

    if (( $ret )); then
      dieMsg="Unrecoverable error by checkout $revision for module $moduleName ($modulePath)"
    else

      if [[ "$modulePath" != "/" ]]; then
        local legoMode="$g_lego_mode"
        [[ "$legoMode" != "versioned" ]] && legoMode="solo"

        persist_attain_hint "0" "$moduleName" "$revision" "$refType" "$legoMode"
        ret=$?
      fi

      if (( ! "$ret" )); then

        local index=0
        local doUpdateInit=0
        local doAppendNewModule=0
        local doRecreateCache=()

        for after in "${modulesAfter[@]}"; do
          local pathAfter="${modulePathsAfter[$index]}"
          doUpdateInit=0

          initialized=$(module_info "$pathAfter" "initialized")

          if [[ -z "$initialized" || "$initialized" == 0 ]]; then
            git submodule update --init -- "$after"
            ret=$?
            if [[ -z "$initialized" ]]; then
              # 'module' is an external array is being used in investigate_module function
              local localPath="${pathAfter:1}"
              local module=("$after" "$localPath")
              investigate_module "$after" "$localPath"

              cache_module_descriptor "${module[@]}"

            else
              local moduleIndex=0
              for cachedPath in "${g_module_paths[@]}"; do
                if [[ "$cachedPath" == "$pathAfter" ]]; then
                  g_module_inited["$moduleIndex"]=1
                  doRecreateCache+=("$cachedPath")
                  break
                fi

                moduleIndex=$(( "$moduleIndex" + 1 ))
              done
            fi
          else
            git submodule update
            ret=$?
          fi

          index=$(( $index + 1 ))
        done

        if (( "${#doRecreateCache[@]}" )); then
          recreate_modules_cache "${doRecreateCache[@]}"
        fi

        # remove folders of deleted modules
        if (( "${#deletedModules[@]}" )); then
          index=0

          for deleted in "${deletedModules[@]}"; do
            for before in "${modulesBefore[@]}"; do
              if [[ "$before" == "$deleted" ]]; then
                rm -rf "${modulePathsBefore[$index]}" &>/dev/null
                break
              fi
            done

            index=$(( $index + 1 ))
          done
        fi

        unset modulesBefore
        unset modulePathsBefore
        unset modulesAfter
        unset modulePathsAfter
        unset hashesAfter
        unset addedModules
        unset deletedModules
        unset movedModules

        if [ -f .gitmodules ]; then
          while read -a module; do
            local subModule="${module[0]}"
            local localPath="${module[1]}"
            subRepoPath="$levelPath/$localPath"

            local subModulePath="$modulePath"
            [[ ${subModulePath:(-1)} != "/" ]] && subModulePath+="/"
            subModulePath+="$subModule"

            checkout_level "-" "$subModule" "$subModulePath" "$subRepoPath" "$parentRefname" "$parentRefType"

          done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
        fi
      fi
    fi
  fi
  popd &>/dev/null
}  ## of checkout_level



################################ MAIN SCRIPT LOGIC ################################
cmd_default() {
  local modulePath=$(resolve_module_path "$initialPath" "/")
  read moduleName moduleFilePath < <(module_info "$modulePath" "name" "path")

  local dieMsg
  local skippedModules=()
  local affected=0
  local vetoed=0
  ret=0

  #pushd ${path} &>/dev/null
#  cd ${moduleFilePath}

#  git rev-parse "$revision" &> /dev/null
#  if (( $? )); then
#    git rev-parse "origin/${revision}" &> /dev/null
#    if (( $? )); then
#      die "Revision '$revision' not exists in the module '$moduleName'"
#    fi
#  fi
#
#set -x
  if [[ -z "$moduleFilePath" ]]; then
    see_help "Wrong module specification"
  fi

  if [[ "$modulePath" != "/" ]]; then
    module_up
  fi

  read refName refType isExists full < <( evaluate_refname "$revision" "" "1")

  if (( ! "$isExists" )); then
    die "Incorrect revision '$revision' in module '$moduleName'"
  fi

  if [[ "$refType" == "branch" ]]; then
    implicitAutoAttain=1
  fi

  checkout_level "$revision" "$moduleName" "$modulePath" "$moduleFilePath"
  ret=$?

  umbrella_finalize
  exit ${ret}
}