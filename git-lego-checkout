#!/usr/bin/env bash
set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
args=()

################################ STANDARD BOOTSTRAP CALL ################################
#set -x
umbrella_bootstrap
#set +x


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} tool to manage checkouts different version onto umbrella-managed git repositories

SYNOPSIS:
    ${FLAGS_PREFIX} --[no-]current [--[no-]recursive] ...] [[--fallback <branch1> ...] ([--[no-]push] | [--[no-]commit] | <revision|reference-resolution>) [<path-resolution>] -- <module1> ...

DESCRIPTION:
    Checkout in umbrella mode handles slightly differ from its 'git checkout' counterpart.
    First it don\'t works with file or files after -- trigger. In umbrella it will works with
    modules\' list. In absolute convention it defines modules affecting on checkout.

    Umbrella checkout processing falling into three different modes.
    1) solo mode is just revision-resolution direct or inderect reference to specific commit,
        rather than symbolic ref aka branch.
    2) if no solo mode - relative mode, if path-resolution follows to be a path relative to current directory.
    3) if path-resolution directs to the umbrella module, it will be an absolute mode, or setting it to '/'
        or if path-resolution parameter just omitted.

    For solo mode all parameters except umbrella-specific will be used as parameters for usual 'git commit ... '
    command. For two other modes usual git checkout parameters are not permitted.

    CAUTION!
    Umbrella checkout does NOT supports --branch|--orphan functionality. It is moved to
    'branch <branch-name>' to avoid over-complicated scenarios can happening in multi-repo architecture.


EXAMPLES:
    '${FLAGS_PREFIX} master /' -> absolute mode, --no-recursive, --current, --no-commit, --no-push
        ACTION: if umbrella module branch is different from master, it will be checked out to master,
        all sub-modules will be updated to master as well

    '${FLAGS_PREFIX} master' -> same as above

    '${FLAGS_PREFIX} develop .' -> relative mode, --no-recursive, --current, --commit, --push
        This action may cause (or may not) enclosed module to be dirty, if previous commit differs to develop.
        ACTION: if umbrella module branch differs from develop, it will be checked out to develop,
        all sub-modules have to be updated to develop as well. If there is any module having no develop branch,
        getting warning about this, no commit (if no --force given), state of that module is not changed.

    '${FLAGS_PREFIX} --fallback=develop qa' -> absolute mode, --recursive, --current, --commit, --push
        ACTION: if umbrella module branch differs from develop, it will be checked out to develop,
        all sub-modules have to be updated to develop as well. Any of module has no develop branch,
        but has develop, will be checked out to develop.

    '${FLAGS_PREFIX} --fallback=develop --fallback=master qa' -> same as above, but if no qa and develop exists,
        change to master

    '${FLAGS_PREFIX} master .' -> relative mode, --no-recursive, --current, --no-commit, --no-push
        Change for current module to master branch. Get warning, if enclosing repo not referencing to master.
        All options except umbrella-specific will be passed to underlying 'git checkout ...' command.

    '${FLAGS_PREFIX} release . --commit --push' -> solo mode, --no-recursive, --current, --push
        all predecessor modules will be updated to new state, if required. After they will be committed and
        pushed to origin.

    '${FLAGS_PREFIX} release ./wiki' -> relative mode, change branch for first sibling wiki module to 'release', --commit

    '${FLAGS_PREFIX} release -- wiki docs' -> absolute, looking from umbrella root, doesn\'t matter deep of module.


OPTIONS:
      --help|-h|-\?
          get this help

      --[no-]push[=<remote>]
          push (or prevent) to <remote> ('origin' by default) repository.

      --[no]-commit]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --fallback[=| ]<branch>
          fallback branch name used instead of <fork-branch>, if last does not exists in sub-module

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

typeset verbose=0
typeset doAdd=0 # by default do not add
typeset revision
typeset commit=1 doForce=0
typeset fallbacks=()
typeset initialPath 

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --fallback)
      if [ -n "$2" ]; then
        noAppendArg=1
        ${fallbacks[${#fallbacks[@]}]}=$2
        shift
      else
        die "--fallback requires a non-empty option argument."
      fi
      ;;
    --fallback=?*)
      noAppendArg=1
      ${fallbacks[${#fallbacks[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --fallback=)         # Handle the case of an empty --fallback=
      die "--fallback requires a non-empty option argument."
      ;;


    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force|-F)
      doForce=0
      ;;

    -b|-B|--orphan)
      die "$1 options is not supported for now. Create new branches using CW 'branch ...' command" >&2
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        die "Unknown option '$1'"
      elif [[ -z ${revision} ]]; then
        revision=$1
        noAppendArg=1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac
  (( ${noAppendArg} )) && args+=$1
  shift
done


if [[ -z $revision ]]; then
  die "Parameter revision/branch required"
fi
#set -x

################################ SCRIPT SPECIFIC METHODS ################################
checkout_level () {
echo "$FUNCNAME()" $@ >&2

  local levelRevision="$1"
  local modulePath="$2"
  local moduleName="$3"
  local levelPath="$4"
  local parentRefname="$5"
  local parentRefType="$6"
#  local doUpdate="$5"

  pushd "${levelPath}" &>/dev/null

#  (( "${#addedModules[@]}" )) && git submodule update --init
#
#  #By change branch can happen that submodules can't be removed (usually can) if, for example, if submodule has its own submodule.
#  (( "${#removedModules[@]}" )) && git clean -d -f -f &> /dev/null


  prepare_checkout_level "${revision}" "${modulePath}" "${moduleName}" "${levelPath}" 0
  ret=$?

  echo "before: ${modulesBefore[@]}" >&2
  echo "paths before: ${modulePathsBefore[@]}" >&2
  echo "after: ${modulesAfter[@]}" >&2
  echo "paths after: ${modulePathsAfter[@]}" >&2
  echo "to add: ${modulesAdded[@]}" >&2
  echo "hashes: ${hashesAfter[@]}" >&2
  echo "to delete: ${deletedModules[@]}" >&2
  echo "vetoed: ${vetoed}" >&2
  echo "ret: ${ret}" >&2

  if (( ! $ret )); then

    local found
    local beforeIndex afterIndex
    local added deleted before subModule pathBefore pathAdded

    if (( "${#deletedModules[@]}" )); then
      local deletedIndex=0
      for deleted in "${deletedModules[@]}"; do
        afterIndex=0
        found=0
        for subModule in "${modulesAfter[@]}"; do
          if [[ "$subModule" == "${deleted}" ]]; then
            pathDeleted="${modulePathsAfter[$afterIndex]}"
            found=1
            break
          fi
          afterIndex=$(( $afterIndex + 1 ))
        done

        read initialized < <(module_info "${pathDeleted}" "initialized")
        if (( $initialized )) ; then
          git submodule deinit -- "${deleted}"
        fi

        deletedIndex=$(( $deletedIndex + 1 ))
      done
    fi

    git checkout "${revision}"
    ret=$?

    if (( $ret )); then
      dieMsg="Unrecoverable Error by checkout $revision for module $moduleName ($modulePath)"
    else

      # auto-attain
      ## TODO create a lego setting for attain auto-update
      typeset doUpdate=1
#      attain_module_mode "${levelPath}" "${modulePath}" "${refname}" "${refType}"
      if [[ "$modulePath" != "/" ]]; then
        local legoMode="${g_lego_mode}"
        [[ "$legoMode" != "versioned" ]] && legoMode="solo"
        attain_module_mode "$moduleName" "$legoMode" "$parentRefname" "$parentRefType" "$levelPath"
      fi

      if (( "${#modulesAfter[@]}" )); then
        local afterIndex=0
        local subModule localPath refType refname

        read refType refname < <( get_refname_from_head )

        for subModule in "${modulesAfter[@]}"; do
          localPath="${modulePathsAfter[$afterIndex]}"

          local path+="${levelPath}${localPath}"
          local childModulePath="${modulePath}"
          [[ ${childModulePath:(-1)} != "/" ]] && local childModulePath+="/"
          childModulePath+="$subModule"
          local hash="${hashesAfter[$afterIndex]}"

          module_porcelain_status "$childModulePath" "update"

          do_module_update "$path" "$subModule" "$childModulePath" "$levelPath" "$hash"
          popd &>/dev/null

          checkout_level "$hash" "${childModulePath}" "${subModule}" "${path}" "$refType" "$refname"

          afterIndex=$(( $afterIndex + 1 ))
        done
      fi
    fi
  fi

  popd &>/dev/null
}  ## of checkout_level



################################ MAIN SCRIPT LOGIC ################################
cmd_default() {
  local modulePath=$(resolve_module_path "${initialPath}" "/")
  read moduleName filePath < <(module_info "${modulePath}" "name" "path")

  local dieMsg
  local skippedModules=()
  local affected=0
  local vetoed=0
  ret=0

  #pushd ${path} &>/dev/null
  cd ${filePath}
  git rev-parse "${revision}" &> /dev/null
  if (( $? )); then
    git rev-parse "origin/${revision}" &> /dev/null
    if (( $? )); then
      die "Revision '$revision' not exists in the module '$moduleName'"
    fi
  fi

  local -a modulesBefore
  local -a modulePathsBefore
  local -a modulesAfter
  local -a modulePathsAfter

  local -a modulesAfter
  local -a hashesAfter
  local -a deletedModules
  local -a movedModules

  checkout_level "${revision}" "${modulePath}" "${moduleName}" "${filePath}"
  ret=$?

  umbrella_finalize
  exit ${ret}
}