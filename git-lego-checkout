#!/usr/bin/env bash
set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
args=()

################################ STANDARD BOOTSTRAP CALL ################################
#set -x
umbrella_bootstrap
#set +x


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
# TODO staled help... need to be rewritten
cat << EOF

NAME:
    ${FLAGS_PREFIX} tool to checkout different version onto git-lego managed repositories

SYNOPSIS:
    ${FLAGS_PREFIX} [--[no-]recursive] ...] ([--[no-]push] | [--[no-]commit] | <revision|reference-resolution>) [<path-resolution>] [-- <module1> ... ]
    ${FLAGS_PREFIX} --update-heads=[parent|managed] [-- <module1> <module2> ... ]

DESCRIPTION:
    Lego checkout handles slightly different from its 'git checkout' counterpart.

    First, it don\'t works with file or files after -- trigger. Instead git-lego works at modules\' level only and defines modules being affected.

    Second, git-lego is very sensitive to which type of reference is going to be checked out, either assigned to branch (headed mode) or
      to the detached state via tag, remote branch, plain hash, etc. In case of headed references, checkout tries to attain or update
      sibling modules according to some useful conventions, which drastically spare time to further manipulating with submodules\' states.
      If outer module is


    git-lego checkout processing starts at current module, if no module resolution parameter is present.

    For solo mode all parameters except umbrella-specific will be used as parameters for usual 'git commit ... '
    command. For two other modes usual git checkout parameters are not permitted.


EXAMPLES:

OPTIONS:
      --help|-h|-\?
          get this help

      --[no]-commit]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --[no-]push[=<remote>]
          push (or prevent to push) to <remote> ('origin' by default) repository.

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

typeset verbose=0  stopOptions=0
#typeset doAdd=0 # by default do not add
typeset revision
typeset commit=0 doForce=0
#typeset fallbacks=()
typeset initialPath

typeset modulePath
typeset moduleName
typeset moduleFilePath
typeset moduleLocalPath

# possible values for update-heads option
#   parent - update sibling
#   mananged - for versioned version only, update
#   none - (default)
typeset updateHeads=$( get_lego_setting "updateHeads" )
updateHeads=$( READ_string "$updateHeads" "managed" ) # by default - do not update heads

typeset autoAttain=$(get_lego_setting "autoAttain")
autoAttain=$(READ_boolean ${autoAttain} 1) # 1 === true
typeset paramAutoAttain

typeset attainOnCheckout=1

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --)
      stopOptions=1
      ;;

    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;

    --update-heads=*)
      updateHeads="${1#--update-heads=}"
      ;;
    --no-update-heads)
      updateHeads=0
      ;;

    --auto-attain|-a)
      paramAutoAttain=1
      ;;
    --no-auto-attain|-A)
      paramAutoAttain=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force|-F)
      doForce=0
      ;;

    -b|-B|--orphan)
      die "$1 options is not supported for now. Create new branches using 'branch ...' command" >&2
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        die "Unknown option '$1'"
      elif [[ -z ${revision} ]]; then
        revision=$1
        noAppendArg=1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac

#  (( ${noAppendArg} )) && args+=($1)
  shift
done


if [[ -z "$revision" ]]; then
  die "Parameter revision/branch required"
fi


################################ SCRIPT SPECIFIC METHODS ################################
checkout_level () {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
#if [[ $4 == "/" ]]; then
#  set -x
#fi

  local ret=0

  local revision="$1"
  local revisionType="$2"
  local moduleName="$3"
  local modulePath="$4"
  local levelPath="$5"
  local parentRefName="$6"
  local parentRefType="$7"
  local moduleLocalPath="${8:-.}"

  local topLevelModule=1

  if [[ "$revision" == "-" ]]; then
    topLevelModule=0
  fi

  local parentFilePath
#  local levelPath=$( pwd 2>/dev/null )
  if [[ "$modulePath" != "/" ]]; then
    local parentModulePath=$(get_module_path_up "$modulePath")
    parentFilePath=$( module_info "$parentModulePath" "full" )
  fi

  if [[ -z "$parentRefName" && "$revision" != "-" && -n "$revision" ]]; then
    parentRefName="$revision"
  fi

  if [[ -z "$parentRefType" && "$revisionType" != "-" && -n "$revisionType"  ]]; then
    parentRefType="$revisionType"
  fi

  if [[ -n "$parentRefName" && -z "$parentRefType" ]]; then
    parentRefType=$( get_reftype_of_refname "$parentRefName" )
  fi

  local refType="$revisionType"
  local blobRevision="$revision"

  if (( ! "$attainOnCheckout" )) && (( ! "$topLevelModule" )); then
    local moduleCommit=($( git cat-file -p HEAD | grep -E "^tree [[:xdigit:]]{40}$" | cut -d' ' -f2 | xargs git cat-file -p | grep -E "^160000\s*commit\s*[[:xdigit:]]{40}\s*${moduleName}" ))
    ret=$?

    blobRevision="${moduleCommit[2]}"

#      revision=$( git_submodule_blob_sha "$moduleName" )
  fi

  pushd "$levelPath" &>/dev/null

  local modulesBefore=()
  local modulePathsBefore=()
  local modulesAfter=()
  local refnamesAfter=()
  local modulesNamesAfter=()
  local modulePathsAfter=()
  local hashesAfter=()
  local addedModules=()
  local deletedModules=()
  local movedModules=()
  local postBlobModules=()
  local postBlobRefs=()

  local noSubmodules noLego

  read initialized checkoutRef < <(module_info "$modulePath" "initialized" "checkout" )

  if [[ "$initialized" == 1 ]]; then

    if [[ -n "$checkoutRef" && "$checkoutRef" != "-" && "$attainOnCheckout" == 1 ]]; then
      read revision refType < <( evaluate_refname "$checkoutRef" )
      ret=$?
    fi

    if [[ "$revision" != "-" && "$ret" == 0 && "$attainOnCheckout" == 1 ]]; then
      blobRevision=$( get_blob_revision "$revision" )
      ret=$?
    fi

    noSubmodules=$(git cat-file -s "$blobRevision":.gitmodules &>/dev/null; echo $?)
    noLego=$(git cat-file -s "$blobRevision":.gitlego &>/dev/null; echo $?)

    if (( ! $noSubmodules )) && (( ! $ret )); then
      while read -a module; do
        local blobRefName
        local after="${module[0]}"
        modulesNamesAfter+=("$after")
        # modulesAfter keeps module local path instead of just module name
        modulesAfter+=("${module[1]}")
        local pathAfter="${modulePath}"
        [[ "${pathAfter:-1}" != "/" ]] && pathAfter+="/"
        pathAfter+="${after}"
        modulePathsAfter+=("$pathAfter")
        local notUpdated

        if (( ! $noLego )); then
          blobRefName=$( git config --blob ${blobRevision}:.gitlego "submodule.$after.refname" 2>/dev/null )
          blobRefName="${blobRefName:--}"
          refnamesAfter+=("$blobRefName")
          update_module_cache "$pathAfter" "g_checkout_refnames" "$blobRefName"
          notUpdated=$?
          if (( "$notUpdated" )); then
            postBlobModules+=("$pathAfter")
            postBlobRefs+=("$blobRefName")
          fi
        else
          update_module_cache "$pathAfter" "g_module_managed" "unmanaged" "g_managed_refnames" "$NA"
#          notUpdated=$?
        fi
      done < <(git config --blob ${blobRevision}:.gitmodules --get-regexp "submodule.*.path" 2>/dev/null | sed -E "s/submodule\.(.*)\.path/\1/" )
    fi

    local found
    local moduleIndex=0

    while read -a module; do
      local before="${module[0]}"
      local localPath="${module[1]}"
      modulesBefore+=("$localPath")
      local pathBefore="$modulePath"
      [[ "${pathBefore:-1}" != "/" ]] && pathBefore+="/"
      pathBefore+="$before"
      modulePathsBefore+=("$pathBefore")

      found=0
      if (( ! $noSubmodules )); then
        local pathAfter
        for pathAfter in "${modulePathsAfter[@]}"; do
          if [[ "$pathAfter" == "$pathBefore" ]]; then
            found=1
            break
          fi
        done
      fi

      if (( ! $found )); then
        deletedModules+=("$pathBefore")
        local DELETED_STATUS=()
        pushd "$localPath" &>/dev/null
        module_porcelain_status "$pathBefore" "checkout" "DELETED_STATUS"
        popd  &>/dev/null

        if [[ 0 == ${doForce} && ( 1 == "${DELETED_STATUS[$MS_COMMITABLE]}" || 1 == "${DELETED_STATUS[$MS_UNTRACKED]}" || 1 == "${DELETED_STATUS[$MS_PUSHABLE]}" ) ]]; then
          dieMsg+="Module '$before' (maybe others as well) has not committed or not pushed changes, but intended to be deleted as it does not exists in revision '$revision'"
          return 1
        else
          if [[ "${DELETED_STATUS[$MS_UNINITIALIZED]}" == 0 ]]; then
            git submodule deinit -- "$localPath"
          else
            rm -rf "$localPath" &>/dev/null
          fi
        fi

#      else
#        local foundPath="${modulePathsAfter[$moduleIndex]}"
#        if [[ "$foundPath" != "$localPath" ]]; then
#          movedModules+=("$localPath")
#        fi
      fi
      moduleIndex=$(( $moduleIndex + 1 ))
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    if (( ! $noSubmodules )); then
      moduleIndex=0
      local pathAfter pathBefore
      for pathAfter in "${modulePathsAfter[@]}"; do
        local after="${modulesAfter[$moduleIndex]}"

        found=0
        for pathBefore in "${modulePathsBefore[@]}"; do
          if [[ "$pathBefore" == "$pathAfter" ]]; then
            found=1
            break
          fi
        done

        if (( ! $found )); then
          addedModules+=("$after")
        fi

        moduleIndex=$(( $moduleIndex + 1 ))
      done
    fi

    if [[ "$modulePath" != "/" && -n "$moduleLocalPath" && "$revision" == "-" ]]; then
      git -C "$parentFilePath" submodule update -- "$moduleLocalPath"
      ret=$?

      # module sha have to be changed in cache arrays
      local sha=$( git rev-parse HEAD )
      update_module_cache "$modulePath" "g_module_shas" "$sha"
    fi

#    echo "before: ${modulesBefore[@]}" >&2
#    echo "paths before: ${modulePathsBefore[@]}" >&2
#    echo "after: ${modulesAfter[@]}" >&2
#    echo "names after: ${modulesNamesAfter[@]}" >&2
#    echo "paths after: ${modulePathsAfter[@]}" >&2
#    echo "to add: ${addedModules[@]}" >&2
#    echo "to delete: ${deletedModules[@]}" >&2


   module_porcelain_status "${modulePath}" checkout

    if [[ "$revision" == "-" && "$attainOnCheckout" == 1 ]]; then
      local type

      local checkoutRefName="${MODULE_STATUS[$MS_CHECKOUT_REFNAME]}"
      local checkoutRefType="${MODULE_STATUS[$MS_CHECKOUT_REFTYPE]}"

      if [[ -z "$checkoutRefName" || -z "$checkoutRefType" || "$checkoutRefName" == "-" || "$checkoutRefName" == "$NA" ]]; then
        # TODO auto-attain setting/parameter ??
        local guessedRefnames=()
        read revision type < <( evaluate_attain_hint  "$parentRefName" "$parentRefType" )
        type=$( ref_type_index "$type")
      else
        MODULE_STATUS[$MS_UNMANAGED]=0
        revision="$checkoutRefName"
        type="$checkoutRefType"
      fi

      MODULE_STATUS["$MS_MANAGED_REFNAME"]="$revision"
      MODULE_STATUS["$MS_MANAGED_REFTYPE"]="$type"
    fi

    if (( ! $ret )); then
      local addedFound
      local beforeIndex afterIndex
      local added deleted before subModule before pathAdded

      if [[ -n "${MODULE_STATUS[$MS_MANAGED_REFNAME]}" && "$revision" == "-" && "${MODULE_STATUS[$MS_UNMANAGED]}" == 0 ]]; then
        revision="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
        refTypeIndex="${MODULE_STATUS[$MS_MANAGED_REFTYPE]}"
        refType="${G_REFTYPE_TOKENS[$refTypeIndex]}"
      fi

      if [[ -n "$refType" ]]; then
        if [[ "$refType" != "-" && (("$refType" != "sha" && "$attainOnCheckout" == 1) || "$topLevelModule" == 1) ]]; then
          git checkout "$revision"
          ret=$?

          if (( $ret )); then
            dieMsg="Unrecoverable error by checkout $revision for module $moduleName ($modulePath)"
          else

            if [[ "$modulePath" != "/" ]]; then
              read legoMode modeImplicit < <( get_lego_mode "1" "$parentFilePath" )

              if [[ "$legoMode" != "versioned" || "$modeImplicit" == "1" ]]; then
                legoMode="solo"
              fi
              persist_attain_hint "0" "$moduleName" "$revision" "$refType" "$legoMode"
              ret=$?
            fi
          fi
        fi

        if (( ! "$ret" )); then
          local index=0
          local doUpdateInit=0
          local doAppendNewModule=0
          local recreatedModules=()

          local pathAfter

          for pathAfter in "${modulePathsAfter[@]}"; do
            local localPath="${modulesAfter[$index]}"
            local afterName="${modulesNamesAfter[$index]}"
            doUpdateInit=0
            local doRecreateCache=0

            initialized=$(module_info "$pathAfter" "initialized")

            if [[ -z "$initialized" || "$initialized" == 0 ]]; then
              git submodule update --init -- "$localPath"
              ret=$?
              if [[ -z "$initialized" ]]; then
                # 'module' is an external array is being used in investigate_module function
                local module=("$afterName")
                module+=("$localPath")
                local subModulePath="$modulePath"
                [[ "${subModulePath:(-1)}" != "/" ]] && subModulePath+="/"
                subModulePath+="$afterName"
                investigate_module "$afterName" "$localPath" "$subModulePath"

                cache_module_descriptor "${module[@]}"

              else
                update_module_cache "$pathAfter" "g_module_inited" 1
                doRecreateCache=1
              fi

              if (( "${#postBlobModules[@]}" )); then
                local blobIndex=0
                for blobModule in "${postBlobModules[@]}"; do

                  if [[ "$pathAfter" == "$blobModule" ]]; then
                    local blobRef="${postBlobRefs[$blobIndex]}"
                    update_module_cache "$pathAfter" "g_checkout_refnames" "$blobRef"
                    doRecreateCache=1
                  fi

                  blobIndex=$(( "$blobIndex" + 1 ))
                done
              fi
              if (( "$doRecreateCache" )); then
                recreatedModules+=("$pathAfter")
              fi

            fi

            index=$(( $index + 1 ))
          done

          if (( "${#recreatedModules[@]}" )); then
            recreate_modules_cache "${recreatedModules[@]}"
          fi

          if [ -f .gitmodules ]; then
            if (( ! "$topLevelModule" )); then
              parentRefName="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
              parentRefTypeIndex="${MODULE_STATUS[$MS_DETACHED]}"
              parentRefType="${G_REFTYPE_TOKENS[$parentRefTypeIndex]}"
            fi
            while read -a module; do
              local subModule="${module[0]}"
              local localPath="${module[1]}"
              subRepoPath="$levelPath/$localPath"

              local subModulePath="$modulePath"
              [[ ${subModulePath:(-1)} != "/" ]] && subModulePath+="/"
              subModulePath+="$subModule"

              checkout_level "-" "-" "$subModule" "$subModulePath" "$subRepoPath" "$parentRefName" "$parentRefType" "$localPath"

            done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
          fi
        fi
      fi
    else
      die "$dieMsg"
    fi
    popd &>/dev/null
  fi
#if [[ $4 == "/" ]]; then
#  set +x
#fi
}  ## of checkout_level


prepare_checkout_level() {
#echo "$FUNCNAME()" $@ >&2
  local ret=0

  local moduleName="$1"
  local modulePath="$2"
  local levelFilePath="$3"
  local moduleLocalPath="${4:-.}"

  pushd "$levelFilePath" &>/dev/null
  module_porcelain_status "$modulePath" "noguess"

  if (( "${MODULE_STATUS[$MS_COMMITABLE]}" )) || (( "${MODULE_STATUS[$MS_UNTRACKED]}" )) ; then
    if [[ "$modulePath" != "/" ]]; then
      dirtyModules+=("$moduleName")
    fi
    ret=1
  fi

  if [ -f .gitmodules ]; then
    while read -a module; do
      local childRet=0
      local subModule="${module[0]}"
      local localPath="${module[1]}"
      subRepoPath="$levelFilePath/$localPath"

      local subModulePath="$modulePath"
      [[ ${subModulePath:(-1)} != "/" ]] && subModulePath+="/"
      subModulePath+="$subModule"

      prepare_checkout_level "$subModule" "$subModulePath" "$subRepoPath" "$localPath"
      childRet=$?
      (( "$childRet" > "$ret" )) && ret="$childRet"

    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  popd &>/dev/null
  return "$ret"
}


################################ MAIN SCRIPT LOGIC ################################
cmd_default() {

#  local modulePath=$( resolve_module_path "$initialPath" "." )
#  read moduleName moduleFilePath moduleLocalPath < <(module_info "$modulePath" "name" "path")
  local parentFilePath

  local dieMsg
  local skippedModules=()
  local dirtyModules=()
  local affected=0
  local vetoed=0
  ret=0

  cd "$moduleFilePath"

  if [[ -z "$moduleFilePath" ]]; then
    see_help "Wrong module specification"
  fi

  prepare_checkout_level "$moduleName" "$modulePath" "$moduleFilePath" "$moduleLocalPath"
  vetoed=$?

  if (( ! "$vetoed" )); then

    if [[ "$modulePath" != "/" ]]; then
      pushd ${moduleFilePath} &>/dev/null
      module_up
      parentFilePath=$( pwd &>/dev/null )

      read parentRefName parentRefType < <( evaluate_refname )
      ret=$?

      popd &>/dev/null
    fi

    if (( ! $ret )); then
      read refName refType isExists distinctRefName fullRefname < <( evaluate_refname "$revision" "1")
      ret=$?

      if (( ! $ret )) && (( ! "${isExists:-0}" )); then
        die "Incorrect revision '$revision' in module '$moduleName'"
      else
        if [[ "$refType" != "branch" ]]; then
          attainOnCheckout=0
        fi
        checkout_level "$refName" "$refType" "$moduleName" "$modulePath" "$moduleFilePath" "$parentRefName" "$parentRefType" "$moduleLocalPath"
        ret=$?
      fi
    fi
  else
    local dirties="'${dirtyModules[@]}'"
    die "git-lego detected ${dirties:-some} module(s) have not committed changes. Please stash or commit your changes before continue. Use git-lego checkout --force to "
  fi

  umbrella_finalize
  exit "$ret"
}
