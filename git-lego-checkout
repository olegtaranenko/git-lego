#!/usr/bin/env bash
set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
args=()

################################ STANDARD BOOTSTRAP CALL ################################
#set -x
umbrella_bootstrap
#set +x


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} tool to manage checkouts different version onto umbrella-managed git repositories

SYNOPSIS:
    ${FLAGS_PREFIX} --[no-]current [--[no-]recursive] ...] [[--fallback <branch1> ...] ([--[no-]push] | [--[no-]commit] | <revision|reference-resolution>) [<path-resolution>] -- <module1> ...

DESCRIPTION:
    Checkout in umbrella mode handles slightly differ from its 'git checkout' counterpart.
    First it don\'t works with file or files after -- trigger. In umbrella it will works with
    modules\' list. In absolute convention it defines modules affecting on checkout.

    Umbrella checkout processing falling into three different modes.
    1) solo mode is just revision-resolution direct or inderect reference to specific commit,
        rather than symbolic ref aka branch.
    2) if no solo mode - relative mode, if path-resolution follows to be a path relative to current directory.
    3) if path-resolution directs to the umbrella module, it will be an absolute mode, or setting it to '/'
        or if path-resolution parameter just omitted.

    For solo mode all parameters except umbrella-specific will be used as parameters for usual 'git commit ... '
    command. For two other modes usual git checkout parameters are not permitted.

    CAUTION!
    Umbrella checkout does NOT supports --branch|--orphan functionality. It is moved to
    'branch <branch-name>' to avoid over-complicated scenarios can happening in multi-repo architecture.


EXAMPLES:
    '${FLAGS_PREFIX} master /' -> absolute mode, --no-recursive, --current, --no-commit, --no-push
        ACTION: if umbrella module branch is different from master, it will be checked out to master,
        all sub-modules will be updated to master as well

    '${FLAGS_PREFIX} master' -> same as above

    '${FLAGS_PREFIX} develop .' -> relative mode, --no-recursive, --current, --commit, --push
        This action may cause (or may not) enclosed module to be dirty, if previous commit differs to develop.
        ACTION: if umbrella module branch differs from develop, it will be checked out to develop,
        all sub-modules have to be updated to develop as well. If there is any module having no develop branch,
        getting warning about this, no commit (if no --force given), state of that module is not changed.

    '${FLAGS_PREFIX} --fallback=develop qa' -> absolute mode, --recursive, --current, --commit, --push
        ACTION: if umbrella module branch differs from develop, it will be checked out to develop,
        all sub-modules have to be updated to develop as well. Any of module has no develop branch,
        but has develop, will be checked out to develop.

    '${FLAGS_PREFIX} --fallback=develop --fallback=master qa' -> same as above, but if no qa and develop exists,
        change to master

    '${FLAGS_PREFIX} master .' -> relative mode, --no-recursive, --current, --no-commit, --no-push
        Change for current module to master branch. Get warning, if enclosing repo not referencing to master.
        All options except umbrella-specific will be passed to underlying 'git checkout ...' command.

    '${FLAGS_PREFIX} release . --commit --push' -> solo mode, --no-recursive, --current, --push
        all predecessor modules will be updated to new state, if required. After they will be committed and
        pushed to origin.

    '${FLAGS_PREFIX} release ./wiki' -> relative mode, change branch for first sibling wiki module to 'release', --commit

    '${FLAGS_PREFIX} release -- wiki docs' -> absolute, looking from umbrella root, doesn\'t matter deep of module.


OPTIONS:
      --help|-h|-\?
          get this help

      --[no-]push[=<remote>]
          push (or prevent) to <remote> ('origin' by default) repository.

      --[no]-commit]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --fallback[=| ]<branch>
          fallback branch name used instead of <fork-branch>, if last does not exists in sub-module

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

typeset verbose=0
typeset doAdd=0 # by default do not add
typeset revision
typeset commit=1 doForce=0
typeset fallbacks=()
typeset initialPath 

################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --fallback)
      if [ -n "$2" ]; then
        noAppendArg=1
        ${fallbacks[${#fallbacks[@]}]}=$2
        shift
      else
        die "--fallback requires a non-empty option argument."
      fi
      ;;
    --fallback=?*)
      noAppendArg=1
      ${fallbacks[${#fallbacks[@]}]}=${1#*=} # Delete everything up to "=" and assign the remainder.
      ;;
    --fallback=)         # Handle the case of an empty --fallback=
      die "--fallback requires a non-empty option argument."
      ;;


    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force|-F)
      doForce=0
      ;;

    -b|-B|--orphan)
      die "$1 options is not supported for now. Create new branches using CW 'branch ...' command" >&2
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        die "Unknown option '$1'"
      elif [[ -z ${revision} ]]; then
        revision=$1
        noAppendArg=1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac
  (( ${noAppendArg} )) && args+=$1
  shift
done


if [[ -z $revision ]]; then
  die "Parameter revision/branch required"
fi
#set -x

################################ SCRIPT SPECIFIC METHODS ################################
checkout_level () {
echo "$FUNCNAME()" $@ >&2

  local moduleName="$3"
  [[ "$moduleName" == "viatra" ]] && set -x
  local revision="$1"
  local modulePath="$2"
  local levelPath="$4"
  local parentRefname="$5"
  local parentRefType="$6"
#  local doUpdate="$5"

  if [[ -z "$parentRefname" && "$revision" != "-" ]]; then
    parentRefname="$revision"
  fi
  if [[ -n "$parentRefname" && -z "$parentRefType" ]]; then
    parentRefType=$( get_reftype_of_refname "$parentRefname" )
  fi
  local reftype="$parentRefType"

  pushd "$levelPath" &>/dev/null

  local modulesBefore=()
  local modulePathsBefore=()
  local modulesAfter=()
  local modulePathsAfter=()
  local hashesAfter=()
  local addedModules=()
  local deletedModules=()
  local movedModules=()

  local ret=0
  
  prepare_checkout_level "$revision" "$modulePath" "$moduleName" "$levelPath" "$parentRefname" "$parentRefType"
  ret=$?

  echo "before: ${modulesBefore[@]}" >&2
  echo "paths before: ${modulePathsBefore[@]}" >&2
  echo "after: ${modulesAfter[@]}" >&2
  echo "paths after: ${modulePathsAfter[@]}" >&2
  echo "to add: ${addedModules[@]}" >&2
#  echo "hashes: ${hashesAfter[@]}" >&2
  echo "to delete: ${deletedModules[@]}" >&2
#  echo "vetoed: ${vetoed}" >&2
  echo "ret: ${ret}" >&2

  if (( ! $ret )); then

    local addedFound
    local beforeIndex afterIndex
    local added deleted before subModule before pathAdded

    if (( "${#deletedModules[@]}" )); then
      local deletedIndex=0
      for deleted in "${deletedModules[@]}"; do
        afterIndex=0
        addedFound=0
        for subModule in "${modulesAfter[@]}"; do
          if [[ "$subModule" == "$deleted" ]]; then
            pathDeleted="${modulePathsAfter[$afterIndex]}"
            addedFound=1
            break
          fi
          afterIndex=$(( $afterIndex + 1 ))
        done

        read initialized < <(module_info "$pathDeleted" "initialized")
        if (( $initialized )) ; then
          git submodule deinit -- "$deleted"
        fi

        deletedIndex=$(( $deletedIndex + 1 ))
      done
    fi

    if [[ -n "${MODULE_STATUS[$MS_MANAGED_REFNAME]}" && "$revision" == "-" ]]; then
      revision="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
      managed="${MODULE_STATUS[$MS_MANAGED]}"
      reftype="${g_lego_aware_tokens_gitmodules[$managed]}"
    fi

    git checkout "$revision"
    ret=$?

    if (( $ret )); then
      dieMsg="Unrecoverable error by checkout $revision for module $moduleName ($modulePath)"
    else

      if [[ "$modulePath" != "/" ]]; then
        local legoMode="$g_lego_mode"
        [[ "$legoMode" != "versioned" ]] && legoMode="solo"

        persist_attain_hint "0" "$moduleName" "$revision" "$parentRefType" "$legoMode"
        ret=$?
      fi

#      local blobRevision=$( get_blob_revision "$levelRevision" )
#      ret=$?

      if (( ! "$ret" )); then

        local index=0
        local doUpdateInit=0
        local doAppendNewModule=0
        local doRecreateCache=()

#        local addedFound=0
        pwd >&2

        for after in "${modulesAfter[@]}"; do
          local pathAfter="${modulePathsAfter[$index]}"
          doUpdateInit=0

          initialized=$(module_info "$pathAfter" "initialized")

          if [[ -z "$initialized" || "$initialized" == 0 ]]; then
            git submodule update --init -- "$after"
            ret=$?
            if [[ -z "$initialized" ]]; then
              # 'module' is an external array is being used in investigate_module function
              local localPath="${pathAfter:1}"
              local module=("$after" "$localPath")
              investigate_module "$after" "$localPath"

              cache_module_descriptor "${module[@]}"

            else
              local moduleIndex=0
              for cachedPath in "${g_module_paths[@]}"; do
                if [[ "$cachedPath" == "$pathAfter" ]]; then
                  g_module_inited["$moduleIndex"]=1
                  doRecreateCache+=("$cachedPath")
                  break
                fi
                moduleIndex=$(( "$moduleIndex" + 1 ))
              done
            fi
          else
            git submodule update
            ret=$?
          fi

          index=$(( $index + 1 ))
        done

        if (( "${#doRecreateCache[@]}" )); then
          recreate_modules_cache "${doRecreateCache[@]}"
cat ${globals[$G_MODULES_FN]} >&2
        fi

        # remove folders of deleted modules
        if (( "${#deletedModules[@]}" )); then

          for deleted in "${deletedModules[@]}"; do

          index=0
            for before in "${modulesBefore[@]}"; do
              if [[ "$before" == "$deleted" ]]; then
                rm -rf "${modulePathsBefore[$index]}" &>/dev/null
                break
              fi
            done

            index=$(( $index + 1 ))
          done
        fi

pwd >&2
#set -x
        local subModule localPath refType refname
#        read refType refname < <( get_refname_from_head )
        unset modulesBefore
        unset modulePathsBefore
        unset modulesAfter
        unset modulePathsAfter
        unset hashesAfter
        unset addedModules
        unset deletedModules
        unset movedModules

        if [ -f .gitmodules ]; then
          while read -a module; do
            subModule="${module[0]}"
            localPath="${module[1]}"
            subRepoPath="$levelPath/$localPath"

            local subModulePath="$modulePath"
            [[ ${subModulePath:(-1)} != "/" ]] && local subModulePath+="/"
            subModulePath+="$subModule"
#            pushd "$levelPath$subModulePath" &>/dev/null

            checkout_level "-" "$subModulePath" "$subModule" "$subRepoPath" "$parentRefname" "$parentRefType"
#            popd &>/dev/null
          done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

#set +x
        fi
      fi
    fi
  fi

  popd &>/dev/null
}  ## of checkout_level



################################ MAIN SCRIPT LOGIC ################################
cmd_default() {
  local modulePath=$(resolve_module_path "$initialPath" "/")
  read moduleName filePath < <(module_info "$modulePath" "name" "path")

  local dieMsg
  local skippedModules=()
  local affected=0
  local vetoed=0
  ret=0

  #pushd ${path} &>/dev/null
  cd ${filePath}
  git rev-parse "$revision" &> /dev/null
  if (( $? )); then
    git rev-parse "origin/${revision}" &> /dev/null
    if (( $? )); then
      die "Revision '$revision' not exists in the module '$moduleName'"
    fi
  fi

  checkout_level "$revision" "$modulePath" "$moduleName" "$filePath"
  ret=$?

  umbrella_finalize
  exit ${ret}
}