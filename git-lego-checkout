#!/usr/bin/env bash
set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################
args=()

################################ STANDARD BOOTSTRAP CALL ################################
#set -x
umbrella_bootstrap
#set +x


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
# TODO staled help... need to be rewritten
cat << EOF

NAME:
    ${FLAGS_PREFIX} tool to checkout different version onto git-lego managed repositories

SYNOPSIS:
    ${FLAGS_PREFIX} [--[no-]recursive] ...] ([--[no-]push] | [--[no-]commit] | <revision|reference-resolution>) [<path-resolution>] [-- <module1> ... ]
    ${FLAGS_PREFIX} --update-heads=[parent|managed] [-- <module1> <module2> ... ]

DESCRIPTION:
    Lego checkout handles slightly different from its 'git checkout' counterpart.

    First, it don\'t works with file or files after -- trigger. Instead git-lego works at modules\' level only and defines modules being affected.

    Second, git-lego is very sensitive to which type of reference is going to be checked out, either assigned to branch (headed mode) or
      to the detached state via tag, remote branch, plain hash, etc. In case of headed references, checkout tries to attain or update
      sibling modules according to some useful conventions, which drastically spare time to further manipulating with submodules\' states.
      If outer module is


    git-lego checkout processing starts at current module, if no module resolution parameter is present.

    For solo mode all parameters except umbrella-specific will be used as parameters for usual 'git commit ... '
    command. For two other modes usual git checkout parameters are not permitted.


EXAMPLES:

OPTIONS:
      --help|-h|-\?
          get this help

      --[no]-commit]
          valid with --view option only. Attempts to fix the branding modules hierarchy
          if possible. By default --sync is not performed

      --[no-]push[=<remote>]
          push (or prevent to push) to <remote> ('origin' by default) repository.

      --
          marks state after which only affected repositories will be enumerated. Actual with --[no-]current
          options only.

          ...

          to be continued

EOF
}

typeset verbose=0  stopOptions=0
#typeset doAdd=0 # by default do not add
typeset revision
typeset commit=0 doForce=0
#typeset fallbacks=()
typeset initialPath

typeset modulePath
typeset moduleName
typeset moduleFilePath
typeset moduleLocalPath

# possible values for update-heads option
#   parent - update sibling
#   mananged - for versioned version only, update
#   none - (default)
typeset updateHeads=$( get_lego_setting "updateHeads" )
updateHeads=$( READ_string "$updateHeads" "managed" ) # by default - do not update heads

typeset autoAttain=$(get_lego_setting "autoAttain")
autoAttain=$(READ_boolean ${autoAttain} 1) # 1 === true
typeset paramAutoAttain

typeset attainOnCheckout=1
typeset updateManagedRef=0


################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  (( $stopOptions )) && [[ -z ${1%%-*}  ]] && die "after '--' additional options ($1) are not allowed "
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      noAppendArg=1
      ;;

    --)
      stopOptions=1
      ;;

    --commit)
      commit=1
      ;;
    --no-commit)
      commit=0
      ;;

    --update-heads=*)
      updateHeads="${1#--update-heads=}"
      ;;
    --no-update-heads)
      updateHeads=0
      ;;

    --auto-attain|-a)
      paramAutoAttain=1
      ;;
    --no-auto-attain|-A)
      paramAutoAttain=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force|-F)
      doForce=0
      ;;

    -b|-B|--orphan)
      die "$1 options is not supported for now. Create new branches using 'branch ...' command" >&2
      ;;
    *)
      if [[ -z ${1%%-*} ]]; then
        die "Unknown option '$1'"
      elif [[ -z ${revision} ]]; then
        revision=$1
        noAppendArg=1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      fi
      ;;
  esac

#  (( ${noAppendArg} )) && args+=($1)
  shift
done


if [[ -z "$revision" ]]; then
  die "Parameter revision/branch required"
fi


################################ SCRIPT SPECIFIC METHODS ################################
prepare_checkout_level() {
#echo "$FUNCNAME()" $@ >&2
  local ret=0

  local moduleName="$1"
  local modulePath="$2"
  local levelFilePath="$3"
  local moduleLocalPath="${4:-.}"
  local wrongRepo=0

  pushd "$levelFilePath" &>/dev/null
  wrongRepo=$?

  if (( ! $wrongRepo )); then
    module_porcelain_status "$modulePath" "noguess"

    if [[ ( "${MODULE_STATUS[$MS_COMMITABLE]}" == 1 || "${MODULE_STATUS[$MS_UNTRACKED]}" == 1 ) && "$doForce" == 0 ]] ; then
      dirtyModules+=("$moduleName")
      ret=1
    fi

    if [ -f .gitmodules ]; then
      while read -a module; do
        local subModule="${module[0]}"
        local localPath="${module[1]}"
        subRepoPath="$levelFilePath/$localPath"

        local subModulePath="$modulePath"
        [[ "${subModulePath:(-1)}" != "/" ]] && subModulePath+="/"
        subModulePath+="$subModule"

        prepare_checkout_level "$subModule" "$subModulePath" "$subRepoPath" "$localPath"
        ret=$?
        (( "$ret" )) && break

      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi

    popd &>/dev/null
  fi
  return "$ret"
}





################################ MAIN SCRIPT LOGIC ################################
cmd_default() {

#  local modulePath=$( resolve_module_path "$initialPath" "." )
#  read moduleName moduleFilePath moduleLocalPath < <(module_info "$modulePath" "name" "path")
  local parentFilePath

  local dieMsg
  local skippedModules=()
  local dirtyModules=()
  local affected=0
  local ret=0

  cd "$moduleFilePath"

  if [[ -z "$moduleFilePath" ]]; then
    see_help "Wrong module specification"
  fi

  prepare_checkout_level "$moduleName" "$modulePath" "$moduleFilePath" "$moduleLocalPath"
  ret=$?

  if (( ! "$ret" )); then

    if [[ "$modulePath" != "/" ]]; then
      pushd "$moduleFilePath" &>/dev/null
      module_up
      parentFilePath=$( pwd &>/dev/null )

      read parentRefName parentRefType < <( evaluate_refname )
      ret=$?

      popd &>/dev/null
    fi

    if (( ! $ret )); then
      read refName refType isExists distinctRefName fullRefname < <( evaluate_refname "$revision" "1")
      ret=$?
      if (( ! $ret )) && (( ! "${isExists:-0}" )); then
        die "Incorrect revision '$revision' in module '$moduleName'"
      else
        if [[ "$refType" != "branch" ]]; then
          attainOnCheckout=0
        else
          updateManagedRef=1
        fi
        checkout_level "$refName" "$refType" "$moduleName" "$modulePath" "$moduleFilePath" "$parentRefName" "$parentRefType" "$moduleLocalPath" "$parentFilePath"
        ret=$?
      fi
    fi
  else
    local dirties="${dirtyModules[@]}"
    die "'${dirties:-some}' module(s) have not committed changes. " "Stash or commit your changes before continue." "Use git-lego checkout --force to override current changes"
  fi

  umbrella_finalize
  exit "$ret"
}
