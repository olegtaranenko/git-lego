#!/usr/bin/env bash
set +o posix
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################

  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
declare ret=0

args=()

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap



################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX}

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'

DESCRIPTION:

EXAMPLES:
    '${FLAGS_PREFIX} --auto' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset currentLegoMode

typeset verbose=0
typeset doUpdate=1

typeset autoAttach=$(get_lego_setting "autoAttach")
autoAttach=$(READ_boolean ${autoAttach} 1) # 1 === true

#typeset doRecursive=0
typeset initialPath doRecursive=1  doForce=1
typeset explicitModules=() explicitRefs=()

# format: git-lego attain master: reference will be 'master'
typeset reference

typeset BAD_EXPLICIT_PARAM="Wrong format of explicit module -> reference parameter."

################################ PARAMETERS PARSING ################################
#      set -x
while [[ -n $1 ]]; do
  noAppendArg=0
  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force)
      doForce=0
      ;;

    --update|-u)
      doUpdate=1
      ;;
    --no-update)
      doUpdate=0
      ;;

    *\^*)
      theModuleName="${1%%\^*}"
      theRefName="${1#*\^}"
      if [[ -n "$theModuleName" && -n "$theRefName" ]]; then
        explicitModules+=("$theModuleName")
        explicitRefs+=("$theRefName")
      else
        see_help "$BAD_EXPLICIT_PARAM"
      fi
      ;;

    *=*)
      theModuleName="${1%%=*}"
      theRefName="${1#*=}"
      if [[ -n "$theModuleName" && -n "$theRefName" ]]; then
        explicitModules+=("$theModuleName")
        explicitRefs+=("$theRefName")
      else
        see_help "$BAD_EXPLICIT_PARAM"
      fi
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          see_help "after '--' additional options ($1) are not allowed "
        else
          explicitModules+=($1)
        fi
#      elif [[ -z ${1%%-*} ]]; then
#        args+=($1)
      elif [[ -z ${reference} ]]; then
        reference=$1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done


if (( ${#explicitModules[@]} )); then
  modulesLen=${#explicitModules[@]}
  refsLen=${#explicitRefs[@]}
  if (( ! $refsLen )); then
    see_help "Wrong reference for explicit modules"
  fi
  if [[ "$modulesLen" != "$refsLen" ]]; then
    index=0
    total="$modulesLen"
    if [[ "$refsLen" > "$modulesLen" ]]; then
      total="$refsLen"
    fi
    while [[ "$index" < "$total" ]]; do
#      if [[ -z ${explicitModules[@]} ]]; then
#      fi
      index=$(( $index + 1 ))
    done
  fi
fi

if [[ -n "$reference" ]]; then
  explicitRefs+=("$reference")
fi


################################ SCRIPT SPECIFIC METHODS ################################


attain_module_mode() {
echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local moduleName="$1"
  local modulePath="$2"
  local parentRefname="$3"
  local parentRefType="$4"

  local legoMode=${g_lego_mode}

  if [[ $legoMode != "versioned" ]]; then
    legoMode="solo"
  fi

  local initRequired=1
  local ret=0

  module_porcelain_status "$modulePath" "attain"

  local detached="${MODULE_STATUS[$MS_DETACHED]}"
  local moduleRefType="${g_lego_aware_tokens_gitmodules[$detached]}"

  if [[ "$moduleRefType" == "$parentRefType" ]]; then
    initRequired=0
  fi

  local uninitialized="${MODULE_STATUS[$MS_UNINITIALIZED]}"
  local unmanaged="${MODULE_STATUS[$MS_UNMANAGED]}"

#set -x
  if [[ "$modulePath" != "/" ]] && (( ! "$uninitialized" )); then
    if (( "$unmanaged" )); then
      local guessedRefname
      local guessedReftype

      local guessedRefnames=()
      read guessedRefname guessedReftype < <(evaluate_attain_hint "$parentRefname" "$parentRefType")

      if [[ -n "$guessedRefname" && -n "$guessedReftype" ]] ; then
        if (( "$doUpdate" )); then
          persist_attain_hint "1" "$moduleName" "$guessedRefname" "$guessedReftype" "$legoMode"
        else
          local hint="Module $moduleName can be "
          if [[ "${guessedReftype}" == "branch" ]]; then
            hint+="attained"
          else
            hint+="pinned"
          fi
          hint+=" to ${guessedRefname}, but --update option required"
          ## exclude $guessedRefname
          if [[ "${#guessedRefnames[@]}" > 1 ]]; then
            local asWellRefs=()
            calculate_as_well_refnames "$guessedRefname"
            hint+=". Other possible attainable (or pinnable) options are: ${asWellRefs[@]}"
          fi
          cw_echo "$hint"
          cw_echo "See '$FLAGS_PREFIX --help' for more information"
        fi
      fi
    fi
  fi
  return "$ret"
}

attain_level() {
#echo "$FUNCNAME()" $@ >&2

  local parentName="$1"
  local levelPath="$2"
  local modulePath="$3"
  local refName="$4"
  local refType="$5"

  local legoMode="${g_lego_mode}"
  local ret=0

  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  if [[ -z "$refName" || -z "$refType" ]]; then
    local refsCount=${#explicitRefs[@]}

    if [[ -z "$refName" ]] && (( "$refsCount" )); then
      refName=${explicitRefs[$refsCount-1]}
    fi

    read currentRefType currentRefName < <( evaluate_refname "$refName" )
    if [[ -z "$refName" ]]; then
      refName="$currentRefName"
    fi
    
    if [[ -z "$refType" ]]; then
      refType="$currentRefType"
    fi
  fi
  local ret=0   # return code, 0 - OK
  local childRet # sub-lever return code

  pushd "$levelPath" &>/dev/null
  attain_module_mode "$parentName" "$modulePath" "$refName" "$refType"
  ret=$?

  if (( ! $ret )); then

    local detached="${MODULE_STATUS[$MS_DETACHED]}"
    local refName="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
    local refType="${g_lego_aware_tokens_gitmodules[$detached]}"

    if [ -f .gitmodules ]; then
      while read -a module; do
        childRet=0
        local moduleName="${module[0]}"
        local localPath="${module[1]}"
        local subModuleFilePath="$levelPath"/"$localPath"

        local subModulePath="$modulePath"
        if [[ ${subModulePath:(-1)} != "/" ]]; then
          subModulePath+="/"
        fi
        subModulePath+="$moduleName"

        local initialized=$( module_info "${subModulePath}" "initialized" )

        if (( $initialized )) ; then

          attain_level "$moduleName" "$subModuleFilePath" "$subModulePath" "$refName" "$refType"
          local childRet=$?

          (( "$childRet" > "$ret" )) && ret = "$childRet"
        else
          ret=1
          warnMsg="One or more modules are uninitialized!"
        fi
      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi
  fi

  popd  &>/dev/null

  return "$ret"
}


################################ MAIN SCRIPT LOGIC ################################

cmd_default() {
  typeset modulePath=$(resolve_module_path "$initialPath" ".")
  read moduleName moduleFilePath < <(module_info "$modulePath" "name" "path")
  typeset affected=0
  typeset onEmptyMessage
  typeset skippedModules=()
  typeset warnMsg

  local ret

#  pushd "$moduleFilePath" &>/dev/null
  if [[ -z "$moduleFilePath" ]]; then
    see_help "Wrong specification of the module"
  fi
  attain_level "$moduleName" "$moduleFilePath" "$modulePath" #"$refName" "$refType"
  ret=$?

  if (( $verbose )); then
    if [[ -n $warnMsg ]]; then
      cw_verbose "$warnMsg"
    fi
  fi

#  popd &>/dev/null
  umbrella_finalize
  return $ret
}
