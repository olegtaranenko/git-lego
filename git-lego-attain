#!/usr/bin/env bash
set +o posix
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################

args=()

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap



################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX}

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'

DESCRIPTION:

EXAMPLES:
    '${FLAGS_PREFIX} --auto-attain' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset currentLegoMode

typeset verbose=0 stopOptions=0
typeset doUpdate=1

#
# de-attain module, make it detached. Technically this is just remove managed reference from .gitlego or .git/config
# TODO not implemented yet
# TODO redirect from 'git-lego detain ...' command
# TODO add config setting
typeset doDetain=0

# attain to current state
# TODO add config setting
typeset doCurrent=1

typeset autoAttain=$(get_lego_setting "autoAttain")
autoAttain=$(READ_boolean ${autoAttain} 1) # 1 === true
typeset paramAutoAttain implicitAutoAttain=0

typeset initialPath doRecursive=1 doForce=0

typeset explicitModules=() explicitRefs=() explicitTypes=()

typeset reference referenceType

typeset BAD_EXPLICIT_PARAM="Wrong format of explicit module -> reference parameter."
typeset WRONG_FORMAT_REF="Wrong format of explicit reference"
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0

  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --)
      stopOptions=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force)
      doForce=0
      ;;

    --auto-attain|-a)
      paramAutoAttain=1
      ;;
    --no-auto-attain|-A)
      paramAutoAttain=0
      ;;

    --update|-u)
      doUpdate=1
      ;;
    --no-update)
      doUpdate=0
      ;;

    --detain|-d)
      doDetain=1
      ;;
    --no-detain|-D)
      doDetain=0
      ;;

    --current|-c)
      doCurrent=1
      ;;
    --no-current|-C)
      doCurrent=0
      ;;

    --to|--branch|-b|--headed|--tag|-t|--pinned|--sha|-s)
			case "$2" in
        '' | -*)
          see_help "$WRONG_FORMAT_REF"
          ;;
        *)
			    reference=$2
			    case "$1" in
			      --branch|-b|--headed)
    			    referenceType="branch"
			        ;;
			      --tag|-t|--pinned)
    			    referenceType="pinned"
			        ;;
			      --sha|-s)
    			    referenceType="sha"
			        ;;
			      --to)
    			    referenceType="auto"
			        ;;
          esac
          shift
          ;;
			esac
			;;

		--branch=*)
			reference="${1#--branch=}"
			referenceType="branch"
			;;

		--headed=*)
			reference="${1#--headed=}"
			referenceType="branch"
			;;

		--tag=*)
			reference="${1#--tag=}"
			referenceType="pinned"
			;;

		--pinned=*)
			reference="${1#--pinned=}"
			referenceType="pinned"
			;;

		--sha=*)
			reference="${1#--sha=}"
			referenceType="sha"
			;;

		--to=*)
			reference="${1#--to=}"
			referenceType="auto"
			;;


    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          see_help "after '--' additional options ($1) are not allowed "
        else
          explicitModules+=($1)
        fi
#      elif [[ -z ${1%%-*} ]]; then
#        args+=($1)
#      elif [[ -z ${reference} ]]; then
#        reference=$1
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift

  if [[ -n "$reference" ]]; then
    explicitRefs+=("$reference")
    explicitTypes+=("$referenceType")
    unset reference
  fi
done


if (( ${#explicitModules[@]} )); then
  modulesLen=${#explicitModules[@]}
  refsLen=${#explicitRefs[@]}
  if (( ! $refsLen )); then
    see_help "Wrong reference for explicit modules"
  fi
  if [[ "$modulesLen" != "$refsLen" ]]; then
    index=0
    total="$modulesLen"
    if [[ "$refsLen" > "$modulesLen" ]]; then
      total="$refsLen"
    fi
    while [[ "$index" < "$total" ]]; do
#      if [[ -z ${explicitModules[@]} ]]; then
#      fi
      index=$(( $index + 1 ))
    done
  fi
fi


################################ SCRIPT SPECIFIC METHODS ################################


#
# Should be called after  module_porcelain_status && pushd
# Externals: 
#  
#
is_module_attainable() {
echo "$FUNCNAME()" $@ >&2
  local moduleName="$1"
  local modulePath="$2"
  local parentRefName="$3"
  local parentRefType="$4"

  local ret=0
  local explicits=()
  local refsCount=${#explicitRefs[@]}

  local detached="${MODULE_STATUS[$MS_DETACHED]}"
  local moduleRefType="${G_REFTYPE_TOKENS[$detached]}"

  local uninitialized="${MODULE_STATUS[$MS_UNINITIALIZED]}"

  local moduleAffected="$doCurrent"

  if (( ! "$uninitialized" )) && [[ "$modulePath" != "/" ]]; then
    # from settings
    local moduleAutoAttain="$autoAttain"
    if [[ -n "$paramAutoAttain" ]]; then
      # from cmd parameters
      moduleAutoAttain="$paramAutoAttain"
#    else
#      # from started module: true, if it is 'headed' (branch)
#      moduleAutoAttain="$implicitAutoAttain"
    fi

    local explicitRef explicitType
    local currentRefName currentRefType exists distinctRefName fullRefName

    local guessedRefNames=()
    local refIndex=0
    for refName in "${explicitRefs[@]}"; do
      local refType="${explicitTypes[$refIndex]}"
      read currentRefName currentRefType exists distinctRefName fullRefName < <( evaluate_refname "$refName" "1" "$refType")
      ret=$?
      if (( ! "$ret" )) && (( "$exists" )); then
        case "$currentRefType" in
          branch)
            guessedRefNames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
            ;;
          pinned)
            guessedRefNames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
            ;;
          sha)
            moduleAffected=1
            ;;
        esac

        if (( "${#guessedRefNames[@]}" )); then
          for guessed in "${guessedRefNames[@]}"; do
            if [[ "$guessed" == "$currentRefName" ]]; then
              moduleAffected=1
              explicitRef="$currentRefName"
              explicitType="$currentRefType"
              break
            fi
          done
        fi
      fi

      refIndex=$(( $refIndex + 1 ))
    done
    explicits+=("$moduleAffected")

    if [[ -n "$explicitRef" || -n "$explicitType" ]]; then
      explicits+=("${explicitRef:-$NA}")
      explicits+=("${explicitType:-$NA}")
    fi

  else
    explicits+=("$moduleAffected")
  fi
  echo "${explicits[@]}"
  return "$ret"
}


attain_module_mode() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local moduleName="$1"
  local modulePath="$2"
  local parentRefName="$3"
  local parentRefType="$4"

  local legoMode="${g_lego_mode}"

  if [[ "$legoMode" != "versioned" ]]; then
    legoMode="solo"
  fi

  local ret=0

  module_porcelain_status "$modulePath" "attain"

  local detached="${MODULE_STATUS[$MS_DETACHED]}"
  local moduleRefType="${G_REFTYPE_TOKENS[$detached]}"

  local uninitialized="${MODULE_STATUS[$MS_UNINITIALIZED]}"
  local unmanaged="${MODULE_STATUS[$MS_UNMANAGED]}"

  local alreadyAttained=0

  if [[ "$uninitialized" == 0 && "$unmanaged" == 0 && "$doForce" == 0 ]]; then
    alreadyAttained=1
  fi

  if (( ! $alreadyAttained )); then
    read affected explicitRef explicitType < <( is_module_attainable "$@" )
    ret=$?
  fi
  if (( ! "$ret" )) ; then
    if (( "$affected" )) && (( ! "$alreadyAttained" )); then

      if [[ "$modulePath" != "/" && "$uninitialized" != 1 ]]; then

        if [[ -n "$explicitRef" && -n "$explicitType" ]]; then
          persist_attain_hint "1" "$moduleName" "$explicitRef" "$explicitType" "$legoMode"
        elif (( "$unmanaged" )); then
          local guessedRefname
          local guessedReftype

          local guessedRefnames=()
          read guessedRefname guessedReftype < <(evaluate_attain_hint "$parentRefName" "$parentRefType")

          if [[ -n "$guessedRefname" && -n "$guessedReftype" ]] ; then
            if (( "$doUpdate" )); then
              persist_attain_hint "1" "$moduleName" "$guessedRefname" "$guessedReftype" "$legoMode"
            else
              local hint="Module $moduleName can be "
              if [[ "${guessedReftype}" == "branch" ]]; then
                hint+="attained"
              else
                hint+="pinned"
              fi
              hint+=" to ${guessedRefname}, but --update option required"
              ## exclude $guessedRefname
              if [[ "${#guessedRefnames[@]}" > 1 ]]; then
                local asWellRefs=()
                calculate_as_well_refnames "$guessedRefname"
                hint+=". Other possible attainable (or pinnable) options are: ${asWellRefs[@]}"
              fi
              cw_echo "$hint"
              cw_echo "See '$FLAGS_PREFIX --help' for more information"
            fi
          fi
        fi
      fi
    elif [[ "$modulePath" != "/" ]]; then
      cw_echo "Module $moduleName skipped"
    fi
  fi
  return "$ret"
}


attain_level() {
#echo "$FUNCNAME()" $@ >&2
  local parentName="$1"
  local levelPath="$2"
  local modulePath="$3"
  local refName="$4"
  local refType="$5"

  local legoMode="${g_lego_mode}"
  local ret=0

  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"

  local ret=0   # return code, 0 - OK
  local childRet # sub-lever return code

  pushd "$levelPath" &>/dev/null
  attain_module_mode "$parentName" "$modulePath" "$refName" "$refType"
  ret=$?

  if (( ! $ret )); then

    local detached="${MODULE_STATUS[$MS_DETACHED]}"
    local refName="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
    local refType="${G_REFTYPE_TOKENS[$detached]}"

    if [ -f .gitmodules ]; then
      while read -a module; do
        childRet=0
        local moduleName="${module[0]}"
        local localPath="${module[1]}"
        local subModuleFilePath="$levelPath"/"$localPath"

        local subModulePath="$modulePath"
        if [[ ${subModulePath:(-1)} != "/" ]]; then
          subModulePath+="/"
        fi
        subModulePath+="$moduleName"

        local initialized=$( module_info "${subModulePath}" "initialized" )

        if (( $initialized )) ; then

          attain_level "$moduleName" "$subModuleFilePath" "$subModulePath" "$refName" "$refType"
          local childRet=$?

          (( "$childRet" > "$ret" )) && ret="$childRet"
        else
          ret=1
          warnMsg="One or more modules are uninitialized!"
        fi
      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi
  fi

  popd  &>/dev/null

  return "$ret"
}


################################ MAIN SCRIPT LOGIC ################################

cmd_default() {
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
  local ret=0

  typeset modulePath=$(resolve_module_path "$initialPath" ".")

  read moduleName moduleFilePath < <(module_info "$modulePath" "name" "path")

#  splash "$globals[$G_ROOT_DIR]" "$globals[$G_LEGO_MODE_IMPLICIT]"

  typeset affected=0
  typeset onEmptyMessage
  typeset skippedModules=()
  typeset warnMsg
#  typeset initialRefType initialRefName
  

  if [[ -z "$moduleFilePath" ]]; then
    see_help "Wrong module specification"
  fi

  cd "$moduleFilePath"
  if [[ "$modulePath" != "/" ]]; then
    module_up
  fi
  read refName refType < <( evaluate_refname )
#  initialRefType="$refType"
#  initialRefName="$refName"
  if [[ "$refType" == "branch" ]]; then
    implicitAutoAttain=1
  fi

  attain_level "$moduleName" "$moduleFilePath" "$modulePath" "$refName" "$refType"
  ret=$?

  if (( "$verbose" )) && [[ -n "$warnMsg" ]]; then
    cw_verbose "$warnMsg"
  fi

  umbrella_finalize
  return $ret
}
