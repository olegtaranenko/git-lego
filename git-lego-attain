#!/usr/bin/env bash
set +o posix
################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################

args=()

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap



################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX}

SYNOPSIS:
    '${FLAGS_PREFIX} [options] [-v|--verbose]'

DESCRIPTION:

EXAMPLES:
    '${FLAGS_PREFIX} --auto-attain' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

EOF
}

typeset currentLegoMode

typeset verbose=0
typeset doUpdate=1

#
# de-attain module, make it detached. Technically this is just remove managed reference from .gitlego or .git/config
# TODO not implemented yet
# TODO redirect from 'git-lego detain ...' command
# TODO add config setting
typeset doDetain=0

# attain to current state
# TODO add config setting
typeset doCurrent=0

typeset autoAttain=$(get_lego_setting "autoAttain")
autoAttain=$(READ_boolean ${autoAttain} 1) # 1 === true
typeset paramAutoAttain implicitAutoAttain=0

typeset initialPath
typeset modulePath
typeset moduleName
typeset moduleFilePath
typeset moduleLegoMode

typeset explicitModules=() explicitRefs=() explicitTypes=()

typeset reference referenceType

typeset warnDoForce=()
#typeset WARN_FORCE="Modules ${warnDoForce[*]} can be re-attained, use 'git-lego attain ... --force' option to apply"

typeset BAD_EXPLICIT_PARAM="Wrong format of explicit module -> reference parameter."
typeset WRONG_FORMAT_REF="Wrong format of explicit reference"
#set -x
################################ PARAMETERS PARSING ################################
while [[ -n $1 ]]; do
  noAppendArg=0

  case $1 in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --auto-attain|-a)
      paramAutoAttain=1
      ;;
    --no-auto-attain|-A)
      paramAutoAttain=0
      ;;

    --update|-u)
      doUpdate=1
      ;;
    --no-update)
      doUpdate=0
      ;;

    --detain|-d)
      doDetain=1
      ;;

    --current|-c)
      doCurrent=1
      ;;
    --no-current|-C)
      doCurrent=0
      ;;

    --to|--branch|-b|--headed|--tag|-t|--pinned|--sha|-s)
			case "$2" in
        '' | -*)
          see_help "$WRONG_FORMAT_REF"
          ;;
        *)
			    reference=$2
			    case "$1" in
			      --branch|-b|--headed)
    			    referenceType="branch"
			        ;;
			      --tag|-t|--pinned)
    			    referenceType="pinned"
			        ;;
			      --sha|-s)
    			    referenceType="sha"
			        ;;
			      --to)
    			    referenceType="auto"
			        ;;
          esac
          shift
          ;;
			esac
			;;

		--branch=*)
			reference="${1#--branch=}"
			referenceType="branch"
			;;

		--headed=*)
			reference="${1#--headed=}"
			referenceType="branch"
			;;

		--tag=*)
			reference="${1#--tag=}"
			referenceType="pinned"
			;;

		--pinned=*)
			reference="${1#--pinned=}"
			referenceType="pinned"
			;;

		--sha=*)
			reference="${1#--sha=}"
			referenceType="sha"
			;;

		--to=*)
			reference="${1#--to=}"
			referenceType="auto"
			;;


    *)
      if [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift

  if [[ -n "$reference" ]]; then
    explicitRefs+=("$reference")
    explicitTypes+=("$referenceType")
    unset reference
  fi
done
#set +x

if (( ${#explicitModules[@]} )) && (( ! "$doDetain" )); then
  modulesLen=${#explicitModules[@]}
  refsLen=${#explicitRefs[@]}
  if (( ! $refsLen )); then
    see_help "Wrong reference for explicit modules"
  fi
  if [[ "$modulesLen" != "$refsLen" ]]; then
    index=0
    total="$modulesLen"
    if [[ "$refsLen" > "$modulesLen" ]]; then
      total="$refsLen"
    fi
    while [[ $index < $total ]]; do
#      if [[ -z ${explicitModules[@]} ]]; then
#      fi
      index=$(( $index + 1 ))
    done
  fi
fi


################################ SCRIPT SPECIFIC METHODS ################################


#
# Should be called after  module_porcelain_status && pushd
# Externals: 
#  
#
is_module_attainable() {
#echo "$FUNCNAME()" $@ >&2
  local moduleName="$1"
  local modulePath="$2"
  local parentRefName="$3"
  local parentRefType="$4"

  local ret=0
  local explicits=()
  local refsCount=${#explicitRefs[@]}

  local detached="${MODULE_STATUS[$MS_DETACHED]}"
  local moduleRefType="${G_REFTYPE_TOKENS[$detached]}"

  local uninitialized="${MODULE_STATUS[$MS_UNINITIALIZED]}"

  local moduleAffected=0

  if (( ! "$uninitialized" )) && [[ "$modulePath" != "/" ]]; then

    moduleAffected="$doCurrent"
    # from settings
    local moduleAutoAttain="$autoAttain"
    if [[ -n "$paramAutoAttain" ]]; then
      # from cmd parameters
      moduleAutoAttain="$paramAutoAttain"
#    else
#      # from started module: true, if it is 'headed' (branch)
#      moduleAutoAttain="$implicitAutoAttain"
    fi

    local explicitRef explicitType
    local currentRefName currentRefType exists distinctRefName fullRefName

    local guessedRefNames=()
    local refIndex=0

    for refName in "${explicitRefs[@]}"; do
      local refType="${explicitTypes[$refIndex]}"
      read currentRefName currentRefType exists distinctRefName fullRefName < <( evaluate_refname "$refName" "1" "$refType")
      ret=$?
      if (( ! "$ret" )) && (( "$exists" )); then
        case "$currentRefType" in
          branch)
            # DO NOT QUOTE
            guessedRefNames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
            ;;
          pinned)
            # DO NOT QUOTE
            guessedRefNames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
            ;;
          sha)
            moduleAffected=1
            ;;
        esac
        if (( "${#guessedRefNames[@]}" )); then
          for guessed in "${guessedRefNames[@]}"; do
            if [[ "$guessed" == "$currentRefName" ]]; then
              moduleAffected=1
              explicitRef="$currentRefName"
              explicitType="$currentRefType"
              break
            fi
          done
        fi
      fi

      refIndex=$(( $refIndex + 1 ))
    done
    explicits+=("$moduleAffected")

    if [[ -n "$explicitRef" || -n "$explicitType" ]]; then
      explicits+=("${explicitRef:-$NA}")
      explicits+=("${explicitType:-$NA}")
    fi

  else
    explicits+=("$moduleAffected")
  fi
  echo "${explicits[@]}"
  return "$ret"
#set +x
}


detain_module_mode() {
#echo "$FUNCNAME()" $@ >&2;pwd >&2
  local moduleName="$1"
  local modulePath="$2"
  local isManaged="$3"
  local moduleRefName="$4"
  local legoMode="${5:-$g_lego_mode}"

  local ret=0

  if (( $isManaged )); then

    if [[ "$legoMode" != "versioned" ]]; then
      legoMode="solo"
    fi


    local section="submodule.$moduleName"
    local key="refname"

    wipe_lego_setting_at_mode "$key" "$section" "$legoMode" ".."
    ret=$?
    if (( ! $ret)); then
        cw_echo "Module $moduleName was detained from $moduleRefName at $legoMode scope"
    fi

    if (( $verbose )); then
      local checkExistsAfterWipe=$( get_lego_setting_mode "$key" "$section" "$legoMode" ".." )
      if (( $checkExistsAfterWipe )); then
        cw_verbose "Module $moduleName was not detained"
      fi
    fi
  else
    cw_echo "Module $moduleName skipped"
  fi

  return "$ret"
}


attain_module_mode() {
echo "$FUNCNAME()" $@ >&2;pwd >&2
  local moduleName="$1"
  local modulePath="$2"
  local parentRefName="$3"
  local parentRefType="$4"
  local legoMode="${5:-$g_lego_mode}"

  if [[ "$legoMode" != "versioned" ]]; then
    legoMode="solo"
  fi

  local ret=0

  module_porcelain_status "$modulePath" "attain"

  local detached="${MODULE_STATUS[$MS_DETACHED]}"
  local moduleRefType="${G_REFTYPE_TOKENS[$detached]}"

  local uninitialized="${MODULE_STATUS[$MS_UNINITIALIZED]}"
  local unmanaged="${MODULE_STATUS[$MS_UNMANAGED]}"

  read affected explicitRef explicitType < <( is_module_attainable "$@" )
  ret=$?
#  echo "affected" "$affected" "explicitRef" "$explicitRef" "explicitType" "$explicitType"
  if (( ! "$ret" )) ; then
    if (( "$affected" )) && [[ "$unmanaged" == 1 || "$doForce" == 1  && "$uninitialized" != 1 ]] ; then
      if [[ "$modulePath" != "/" ]]; then

        if [[ -n "$explicitRef" && -n "$explicitType" ]]; then
          persist_attain_hint "1" "$moduleName" "$explicitRef" "$explicitType" "$legoMode"
        elif (( "$unmanaged" )); then
          local guessedRefname
          local guessedReftype

          local guessedRefnames=()
          read guessedRefname guessedReftype < <(evaluate_attain_hint "$parentRefName" "$parentRefType")

          if [[ -n "$guessedRefname" && -n "$guessedReftype" ]] ; then
            if (( "$doUpdate" )); then
              persist_attain_hint "1" "$moduleName" "$guessedRefname" "$guessedReftype" "$legoMode"
            else
              local hint="Module $moduleName can be "
              if [[ "${guessedReftype}" == "branch" ]]; then
                hint+="attained"
              else
                hint+="pinned"
              fi
              hint+=" to ${guessedRefname}, but --update option required"
              ## exclude $guessedRefname
              if [[ "${#guessedRefnames[@]}" > 1 ]]; then
                local asWellRefs=()
                calculate_as_well_refnames "$guessedRefname"
                hint+=". Other possible attainable (or pinnable) options are: ${asWellRefs[@]}"
              fi
              cw_echo "$hint"
              cw_echo "See '$FLAGS_PREFIX --help' for more information"
            fi
          fi
        fi
      fi
    else
      if [[ "$modulePath" != "/" ]]; then
        cw_echo "Module $moduleName skipped"

        if [[ "$uninitialized" == 0 && "$unmanaged" == 0 ]] && (( "$affected" )); then
          warnDoForce+=("$moduleName")
        fi
      fi

    fi
  fi

  return "$ret"
}


attain_level() {
#echo "$FUNCNAME()" $@ >&2
  local moduleName="$1"
  local levelPath="$2"
  local modulePath="$3"
  local refName="$4"
  local refType="$5"
  local parentLegoMode="$6"

  local ret=0
  local wrongRepo=0

  [[ -z "$levelPath" ]] && panic "$FUNCNAME()... parameter 'path' is required"

  local ret=0   # return code, 0 - OK
  local childRet # sub-lever return code
  local initialized legoMode isManaged moduleRefName
  read initialized legoMode isManaged moduleRefName < <( module_info "${modulePath}" "initialized" "lego_mode" "managed" "refname" )

  if (( $initialized )) ; then

    pushd "$levelPath" &>/dev/null
    wrongRepo=$?

    if (( ! $wrongRepo )); then
      if  (( ! $doDetain )); then
        attain_module_mode "$moduleName" "$modulePath" "$refName" "$refType" "$parentLegoMode"
      else
        detain_module_mode "$moduleName" "$modulePath" "$isManaged" "$moduleRefName" "$parentLegoMode"
      fi
      ret=$?

      if (( ! $ret )) && (( "$doRecursive" )); then
        local detached="${MODULE_STATUS[$MS_DETACHED]}"
        local refName="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
        local refType="${G_REFTYPE_TOKENS[$detached]}"

        if [ -f .gitmodules ]; then
          while read -a module; do
            childRet=0
            local subModuleName="${module[0]}"
            local localPath="${module[1]}"
            local subModuleFilePath="$levelPath"/"$localPath"

            local subModulePath="$modulePath"
            if [[ ${subModulePath:(-1)} != "/" ]]; then
              subModulePath+="/"
            fi
            subModulePath+="$subModuleName"

            attain_level "$subModuleName" "$subModuleFilePath" "$subModulePath" "$refName" "$refType" "$legoMode"
            local childRet=$?

            (( "$childRet" > "$ret" )) && ret="$childRet"

          done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
        fi
      fi

      popd  &>/dev/null
    fi
  fi

  return "$ret"
}


################################ MAIN SCRIPT LOGIC ################################
cmd_default() {
  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
  local ret=0

  typeset affected=0
  typeset onEmptyMessage
  typeset skippedModules=()
  typeset warnMsg

  if [[ -z "$moduleFilePath" ]]; then
    see_help "Wrong module specification"
  fi

  cd "$moduleFilePath"
  if [[ "$modulePath" != "/" ]]; then
    module_up
  fi
  read refName refType < <( evaluate_refname )
  if [[ "$refType" == "branch" ]]; then
    implicitAutoAttain=1
  fi

  attain_level "$moduleName" "$moduleFilePath" "$modulePath" "$refName" "$refType"
  ret=$?

  if (( "${#warnDoForce[@]}" )); then
    IFS=","; cw_echo "Modules ${warnDoForce[*]} can be re-attained, use 'git-lego attain ... --force' option to apply"
  fi
  if (( "$verbose" )) && [[ -n "$warnMsg" ]]; then
    cw_verbose "$warnMsg"
  fi

  umbrella_finalize
  return "$ret"
}
