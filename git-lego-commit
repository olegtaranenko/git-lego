#!/usr/bin/env bash
set +o posix

################################ LIBRARIES SHARED OVER ALL CW SCRIPTS ################################

  #
  ## Exit code of the script
  ## 0 - success
  ## 1 - un-success (bad options/... etc)
  ## 2 - unexpected error (wrong code)
  #
#declare ret=0

################################ STANDARD BOOTSTRAP CALL ################################
umbrella_bootstrap


################################ BRANCH-SPECIFIC HELP ################################
function show_help() {
cat << EOF

NAME:
    ${FLAGS_PREFIX} commit current lego

SYNOPSIS:
    '${FLAGS_PREFIX} [<any-git-commit-options>] [-v|--verbose] [<path-resolution>] -- [[<module-name>] ...]'

DESCRIPTION:


EXAMPLES:
    '${FLAGS_PREFIX} -v .' -> show verbose status for current module only


OPTIONS:
      --help|-h|-\?
          get this help

      --
          marks state after which repositories will be shown in status.


EOF
}

typeset args=()

typeset verbose=0
typeset afterDash=()
typeset stopOptions=0

typeset initialPath
typeset modulePath
typeset moduleName
typeset moduleFilePath
typeset moduleInitialized

typeset doRecursive=0 doForce=0
typeset doAmend=0
typeset doForceAmend=0
typeset warningAmend=()
typeset commitMessage commitTemplate
typeset doAppendUntracked=1

typeset messageDefined=0
typeset messageRequired=1
typeset allowEmptyMessage=0
#set -x

################################ PARAMETERS PARSING ################################
while [[ -n "$1" ]]; do
  noAppendArg=0
  case "$1" in
    -h|-\?|--help)
      show_help
      exit
      ;;
    -v|--verbose)
      verbose=$(("$verbose" + 1)) # Each -v argument adds 1 to verbosity.
      ;;

    --amend)
      doAmend=1
      args+=("$1")
      ;;

    --force|-f)
      doForce=1
      ;;
    --no-force)
      doForce=0
      ;;
    -ff)
      doForce=1
      doForceAmend=1
      ;;

    --recursive|-r)
      doRecursive=1
      ;;
    --no-recursive|-R)
      doRecursive=0
      ;;

    -[amFtscC]+)
      args+=($1)
      #getopts emulation -am...
      lastOption=${1:(-1)}
      if [[ "$lastOption" == "m" ]]; then
        args+=("$2")
        commitMessage="$2"
        messageDefined=1
        shift
      elif [[ "$lastOption" == "t" ]]; then
        args+=("$2")
        commitTemplate="$2"
        shift
      elif [[ "$lastOption" == "c" || "$lastOption" == "C"  || "$lastOption" == "F" ]]; then
        args+=("$2")
        shift
      fi
      ;;

    --message)
      args+=("$1")
      args+=("$2")
      commitMessage="$2"
      messageDefined=1
      shift
      ;;
    --message=*)
      commitMessage="${1#*=}"
      messageDefined=1
      (( ! "$#commitMessage" )) && messageDefined=0
      args+=("$1")
      ;;
    --allow-empty-message)
      messageRequired=0
      allowEmptyMessage=1
      ;;


    --template)
      args+=("$1")
      commitTemplate="$2"
      shift
      ;;
    --template=*)
      commitTemplate="${1#*=}"
      [ -z "$commitTemplate" ] && die "template is not given $1"
      args+=($1)
      ;;

    --append-untracked|-u)
      doAppendUntracked=1
      ;;
    --no-append-untracked|-U)
      doAppendUntracked=0
      ;;

    --)
      stopOptions=1
      ;;

    *)
      if (( $stopOptions )); then
        if [[ -z ${1%%-*} ]]; then
          die "after '--' additional options ($1) are not allowed "
        else
          afterDash+=($1)
        fi
      elif [[ -z ${1%%-*} ]]; then
        args+=("$1")
        if (( ! "$messageDefined" )) ; then
          messageDefined=$( echo "$1" | grep -c m 2>/dev/null )
          if (( "$messageDefined" )); then
            shift
            if [[ -z "$1" ]]; then
               die "$emptyMsgNotAllowed"
            fi
            args+=("$1")
          fi
        fi
      elif [[ -z ${initialPath} ]]; then
        initialPath=$1
      else
        die "error in parameters [$1]"
      fi
      ;;
  esac
  shift
done


################################ SCRIPT SPECIFIC METHODS ################################
function prepare_commit_level() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local modulePath="$3"

  local repoBranch
  local ret=0   # return code, 0 - the repo is syncronized
  local ret # child return code

  module_porcelain_status "$modulePath" "commit"
  local applied=1

  if [[ "${MODULE_STATUS[$MS_COMMITABLE]}" == 1 ]]; then
    if [[ "${MODULE_STATUS[$MS_DETACHED]}" == 0  || "$doForce" == 1 ]]; then

      if (( "$doAmend" )) && (( "${MODULE_STATUS[$MS_UPSTREAM_AHEAD]}" == 0 )) && (( ! "$doForceAmend" )); then
        warningAmend+=("$moduleName")
        ret=1
      else
        drop_to_affected "$levelPath"
        applied=$?

        if (( ! "$applied" )); then
          affectedModules+=("$moduleName")
#          affected=1
#          if [[ -z "$commitMessage" && "$modulePath" != "/" ]]; then
#            onEmptyMessage+="$moduleName, "
#          fi
        fi
      fi
    else
      warningDetached+=("$moduleName")
    fi
  fi

  if (( $applied )); then
    skippedModules+=("$moduleName")
  fi

  if [ -f .gitmodules ] && (( ! "$ret" )); then
    while read -a module; do
      subModule="${module[0]}"
      localPath="${module[1]}"
      subRepoPath="${levelPath}"/"${localPath}"

      pushd "${subRepoPath}" &>/dev/null
      local subModulePath="$3" #/$subModule"
      [[ ${subModulePath:(-1)} != "/" ]] && subModulePath+="/"

      subModulePath+="$subModule"
      prepare_commit_level "$subRepoPath" "$subModule" "$subModulePath"
      ret=$?

      if (( "$ret" )) ; then
        break
      fi
      popd  &>/dev/null
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  fi

  return "$ret"
}

################################ MAIN SCRIPT LOGIC ################################
cmd_default() {

  typeset affectedModules=()
  typeset onEmptyMessage
  typeset skippedModules=()
  typeset warningDetached=()
  local ret=0

#  [[ -z "$commitMessage" ]] && onEmptyMessage="commit for ${globals[$G_ROOT_NAME]}, affected modules: "

  if (( "$moduleInitialized" )) ; then

    cd "$moduleFilePath" &>/dev/null

    prepare_commit_level "$moduleFilePath" "$moduleName" "$modulePath"
    ret=$?

    local backIFS="$IFS"; IFS=","
    if (( "${#warningDetached}" )); then
      cw_echo "To commit detached dirty module(s) use --force option: ${warningDetached[*]}"
      ret=1
    fi

    if (( "${#warningAmend}" )); then
      cw_echo "--amend option should not to be used for module(s): ${warningAmend[*]}"
      ret=1
    fi
    local eAffected="${affectedModules[*]}"

    IFS="$backIFS"

    if (( ! "$ret" ))&& (( "${#affectedModules[@]}" )); then

      if (( "$messageRequired" )) && (( ! "$messageDefined" )) && (( ! "$allowEmptyMessage" )); then
        local editMsgFile="${globals[$G_SCRIPT_TMP_DIRECTORY]}/COMMIT_EDITMSG"

        cat << EOT >> "$editMsgFile"
commit via ${0##*/}, affected modules:  $eAffected
# Lines starting with '#' will be ignored.
EOT

        git_editor "$editMsgFile"
        ret=$?

        if (( ! $ret )); then
          message=$( cat "$editMsgFile" | grep -vE "^#.*$" )
          if (( ! "${#message}" )); then
            dieMsg="$emptyMsgNotAllowed"
            ret=1
          else
            echo "$message" > "$editMsgFile"
            args+=("-F")
            args+=("$editMsgFile")
          fi
        fi
      fi

#cat ${globals[$G_AFFECTED_MODULES]} >&2

      while read -a module; do
        cd "${module[$MFS_FULL_PATH]}"
        level_verbose_about_to ${module[@]}

        (( "$doAppendUntracked" )) && git add . -A
#set -x
        git commit "${args[@]}"
#set +x
      done < <(cat ${globals[$G_AFFECTED_MODULES]} | (tac 2> /dev/null || tail -r))
    fi


    IFS=","
    if (( "${#skippedModules}" )); then
      cw_echo "Not affected modules: ${skippedModules[*]}"
    fi

  fi
  umbrella_finalize

  exit "$ret"
}