#!/usr/bin/env bash

  # After call to 'umbrella_bootstrap' this array contains following predefined values.
  #
  ## "${globals[$G_ROOT_DIR]}" [cwRoot]             - file system path to root repository
  ## "${globals[$G_MODULES_FN]}" [cwTmpSubmodules]  - temporary file name, which listed all current repositories
  #                                                   with additional information
  ## "${globals[$G_MODULE_GIT_DIR]}" [gitDir]       - current repository
  #

##############################
#
# FOUND DEBUG OUTPUT TO STDERR
# Occurrences of '^ *(cat|echo).[\w\"\$\{\}\[\]\@\#\*\/\\\:\.\d \'\(\)]*>&2' in Project
#
##############################
EMPTY_TREE_HASH=$(git hash-object -t tree /dev/null)
## Global arrays for quick access of frequently used parameters
## There are basically a cache
g_module_name=()
g_relative_paths=()
g_git_dirs=()
g_full_paths=()
g_module_paths=()
g_module_inited=()
g_module_shas=()
g_module_managed=()
g_managed_refnames=()

declare -a g_lego_aware_tokens_gitmodules=("branch" "pinned" "sha")

declare -a g_lego_modes=("solo" "versioned")
G_MODE_MASK_SOLO="0x1"
G_MODE_MASK_VERSIONED="0x2"

declare NA="n/a"

# keeps some global settings during git-lego script execution
# initialized at startup
globals=()
  ################################## CONSTANTS FOR globals array ##########################################
  #
  ## Root repo path
  #
G_ROOT_DIR=0
  #
  ## reference to git directory for current submodule.
  #
G_MODULE_GIT_DIR=1
  #
  ## Human-readable name of root repository path
  #
G_ROOT_NAME=2
  #
  ## Temporary folder owned by script invocation
G_SCRIPT_TMP_DIRECTORY=3
  #
  ## Reference to temporary file which keeps all submodules' path in reversed order
  ##  It is useful to apply regular actions against all modules, like bulk commit,push,etc
  #
G_MODULES_FN=4
  #
  ## Reference to temporary file which keeps modules' paths, which are effectively affected by
  # applying bulk operations such pull, commit, etc
  # They are in 'absolute' module structure form like /, or /macosx/docs
  #
G_AFFECTED_MODULES=5

  # Remote reference used in git-lego. By default, of course, 'origin'
G_LEGO_REMOTE=6

  # if root repository is headed (checked out to branch) it contains branch name, otherwise hash of the current HEAD
G_HEADED_REF=7

#################### CONSTANTS for MODULE STATUS (see function module_porcelain_status() ####################
#
MS_BRANCH_INFO=0   # String
MS_UNTRACKED=1     # N
MS_MODIFIED=2      # M
MS_MODIFIED_SUBMODULE=28 #S
MS_DELETED=3       # D
MS_ADDED=4         # A
MS_RENAMED=5       # R
MS_COPIED=6        # C
MS_UNMERGED=7      # U
MS_PUSHABLE=8      # 1/0
MS_PULLABLE=9      # 1/0
MS_COMMITABLE=10   # 1/0
MS_SUBMODULES=11   # S
#
# After clone/update submodules always are in the *detached* state. That means, no symbolic reference points to inner module's HEAD.
# At the same time, outer module can have (or not) is't own expectation, which inner module should have, branch or tag.
# If outer module specifies the hint, *managed link*, branch or tag or just sha1 for inner module, let we say the inner module is "managed".
# Otherwise the inner module is *unmanaged* by outer module.
#
# If module is managed, but points to other sha1, than expected, the module's state is *mismatched*.
# Git-lego warns, if inner module is unmanaged or mismatched, and enumerates, to which symbolic links the inner module can be *attained*.
#
# Attain process means change hint in the scope of outer module, so that inner can match to the inner module state. Worktree of inner module is not changed,
# but worktree of outer module can be changed, if git-lego mode is *versioned*. If git-lego mode is set to *solo*, no worktree changes happens as well.
#
# Git-lego has an *auto-attain* setting, in which allow it can attains unmanaged or mismatched modules if no ambiguous symbolic links the inner module has.
#
# In case of mismatched state, there are possible either "attain" inner to outer, or update inner module to the state, referenced in outer hint.
# There are situation though, if outer hint is stale, and inner branch has no such ref. Let say the inner module is not *updateable*
# In this case only attaining will be advised
#
# Module is not initialized yet or git submodule deinit was applied
MS_UNINITIALIZED=14   # 1/0
#
# Unmanaged mean, git-lego has no idea what inner module should be stick on.
MS_UNMANAGED=15       # 1 - inner module is unmanaged, 0 - managed
#
# In case the module is managed
# 0 - inner module not detached (attached to any refs/heads/branch), 1 is detached to tag, 2 is detached to bare sha1
MS_DETACHED=16
#
# Hint of outer
# 0 - managed with a branch head, 1 - pinned to tag, 2 - pinned to bare sha1
MS_MANAGED=17
#
# 0 - Inner module both outer hint and inner state are matched (branch -> branch or tag -> tag), but references are different
# ie, hint is branch develop, but inner state is master. In this case either git-lego update or git-lego attain are required
#
MS_MISMATCHED=18
#
# In case the module has managed, but mismatched state, whether or not it is updateable, to be syncronized with outer hint.
# Does not matter as branch or tag or ever sha1 situation.
MS_UPDATEABLE=19
#
# Outer module hint for inner one, symbolic reference (tag or branch) or just bare sha1, the inner module expected to be.
MS_MANAGED_REFNAME=20
MS_MANAGED_REFTYPE=29
#
# One or more branches referencing on the inner:HEAD, which can be synchronized to the branch after attaining without getting outer repo dirty
# strings' array
MS_GUESSED_BRANCHES=22

# One or more tags referencing to the inner module:HEAD, which can be synchronized with outer hint without making outer submodule reference dirty
# strings' array
MS_GUESSED_TAGS=23
#
# Modules symbolic name, or sha, if module HEAD is detached.
# For getting this info the 'git status --long' command is used. git status takes this information from git reflog,
# then this is not 100% reliable. For example in some cases it can show wrong last 'git tag'
MS_MODULE_REFNAME=24

# Module's upstream branch
MS_UPSTREAM=25

# How many revisions ahead & behind to the module's upstream
MS_UPSTREAM_AHEAD=26
MS_UPSTREAM_BEHIND=27

###############
# LAST MS_=29 #
###############


########################### CONSTANTS FOR MODULE FILE SYSTEM  ###############################################
## Array is filled up in function umbrella_bootstrap () and serves for path resolution
#
MFS_MODULE_NAME=0
MFS_RELATIVE_PATH=1
MFS_GIT_DIR=2
MFS_FULL_PATH=3
MFS_MODULE_PATH=4
MFS_MODULE_INITIALIZED=5
MFS_MODULE_SHA=6
MFS_MODULE_MANAGED=7
MFS_MANAGED_REFNAME=8

# set this to workaround expr problems in shFlags on freebsd
#if uname -s | egrep -iq 'bsd'; then export EXPR_COMPAT=1; fi



typeset g_lego_mode
#set -x
umbrella_bootstrap (){
  local legoRemote=$(get_lego_setting "remote")
  local gitDir
  local umbrellaRepoDir
  local tmpDir=$(mktemp -q -d -t "$(basename "$0")" 2>/dev/null || mktemp -q -d)
  globals[$G_SCRIPT_TMP_DIRECTORY]=${tmpDir}
  globals[$G_LEGO_REMOTE]=${legoRemote:-origin}
  legoRemote="${globals[$G_LEGO_REMOTE]}"

  _m_not_git_repository; (( $? )) && exit 1

  gitDir=$(git rev-parse --git-dir)
  normalizedGitDir=${gitDir##*/}
  if [[ ${normalizedGitDir} == ".git" ]]; then
    umbrellaRepoDir=$(git rev-parse --show-toplevel)
  else
    pushd "${gitDir%%/.git/*}"  &>/dev/null
    umbrellaRepoDir=$(git rev-parse --show-toplevel)
    popd  &>/dev/null
  fi

#  rm ${cwTmpSubmodules} &>/dev/null
  pushd ${umbrellaRepoDir} &>/dev/null


#  local remoteOrigin=$(git remote show)
  local umbrellaOriginUrl umbrellaRepoName
#  if [[ -n ${legoRemote} ]]; then
#    local url=$(get_repo_url "$umbrellaRepoDir")
#
#    umbrellaOriginUrl=$(git remote get-url "${legoRemote}")
#    umbrellaRepoName=${umbrellaOriginUrl##*:}
#    umbrellaRepoName=${umbrellaRepoName##*/}
#
#  else
#    umbrellaOriginUrl=$(pwd)
#    umbrellaRepoName=${umbrellaOriginUrl##*/}
#  fi

  umbrellaOriginUrl=$(pwd)
  umbrellaRepoName=${umbrellaOriginUrl##*/}

  globals[$G_AFFECTED_MODULES]=${tmpDir}/affected
  globals[$G_MODULES_FN]=${tmpDir}/modules

  #globals is an array defined in the caller of this method
  globals[$G_ROOT_DIR]=${umbrellaRepoDir}
  globals[$G_MODULE_GIT_DIR]=${gitDir}
  globals[$G_ROOT_NAME]=${umbrellaRepoName}
  local sha=$( git rev-parse HEAD )

  ##
  local implicit
  read g_lego_mode implicit < <(get_lego_mode 1)
#  echo $g_lego_mode ${implicit:-2}

  module_startup_investigate "${umbrellaRepoName}" "/" ".git" "${umbrellaRepoDir}" "/" 1 "${sha}" 1 "$NA"
#  cat ${globals[$G_MODULES_FN]} >&2
#  echo ${g_module_name[@]} >&2
#  echo ${g_module_inited[@]} >&2
#  echo ${g_module_managed[@]} >&2
  popd &>/dev/null

  splash ${umbrellaRepoName} ${implicit}

  return 0
}


recreate_modules_cache() {
#echo "$FUNCNAME() $@" >&2
  local modulePaths=("$@")
#echo "${modulePaths[@]}" >&2
  local tmpDir="${globals[$G_SCRIPT_TMP_DIRECTORY]}"
  local originalModules="${globals[$G_MODULES_FN]}"
  local backup="$tmpDir/modules.bak"
  local newCache="$tmpDir/modules.new"

  local index=0
  while read -a module; do
    found=0
    local modulePath=${module[$MFS_MODULE_PATH]}
    
    for changedPath in "${modulePaths[@]}"; do
      if [[ "$changedPath" == "$modulePath" ]]; then
        found=1
        break
      fi
    done
    
    if (( $found )); then
      local l_module_name="${g_module_name[$index]}"
      local l_relative_paths="${g_relative_paths[$index]}"
      local l_git_dirs="${g_git_dirs[$index]}"
      local l_full_paths="${g_full_paths[$index]}"
      local l_module_paths="${g_module_paths[$index]}"
      local l_module_inited="${g_module_inited[$index]}"
      local l_module_shas="${g_module_shas[$index]}"
      local l_module_managed="${g_module_managed[$index]}"
      local l_managed_refnames="${g_managed_refnames[$index]}"


      echo "$l_module_name" "$l_relative_paths" "$l_git_dirs" "$l_full_paths" "$l_module_paths" "$l_module_inited" "$l_module_shas" "$l_module_managed" "$l_managed_refnames">>$newCache
    else
      echo "${module[@]}">>$newCache
    fi

    index=$(( $index + 1 ))
  done < <(cat $originalModules)

  mv $originalModules $backup
  mv $newCache $originalModules
}

cache_module_descriptor() {
  local tmpModules=${globals[$G_MODULES_FN]}
  echo "$@">>${tmpModules}
  # keep all module descriptors' values in the global arrays for cached access
  # basically they will be used in 'module_info' method
  g_module_name+=($1)
  g_relative_paths+=($2)
  g_git_dirs+=($3)
  g_full_paths+=($4)
  g_module_paths+=($5)
  g_module_inited+=($6)
  g_module_shas+=($7)
  g_module_managed+=($8)
  g_managed_refnames+=($9)
}

function module_startup_investigate() {
#echo "$FUNCNAME() $@" >&2

  cache_module_descriptor $@

  local module=()

  while read -a module
  do
    local subModule="${module[$MFS_MODULE_NAME]}"       #0
    local localPath="${module[MFS_RELATIVE_PATH]}"      #1

    investigate_module "$subModule" "$localPath"

    pushd ${localPath} &>/dev/null
    module_startup_investigate ${module[@]}
    popd &>/dev/null
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
}


#
# EXTERNAL: module :: array(2), prepared with moduleName & modulePath
#
investigate_module() {
#echo "$FUNCNAME() $@" >&2
  local moduleName="$1"
  local localPath="$2"
#    local parentFilePath="$4"
#    local pushPath
#
#    [[ -n "$parentFilePath" ]] && pushPath="$parentFilePath"
#    [[ ${pushPath:-1} != "/" && ${localPath:0:1} != "/" ]] && pushPath+="/"
#    pushPath+="$localPath"

  local is_initialized=1
  local moduleStatus=($(git submodule status -- ${moduleName}))
  local managed=($(resolve_module_managed "${moduleName}" "${localPath}"))


  pushd ${localPath} &>/dev/null
  module+=($(get_repo_git_dir))             # MFS_GIT_DIR=2
  module+=($(pwd))                          # MFS_FULL_PATH=3

  if [[ $5 == "/" ]]; then                  # MFS_MODULE_PATH = 4
    module+=("/$moduleName")
  else
    module+=("$5/$moduleName")
  fi
  if [[ ${moduleStatus:0:1} == "-" ]]; then
    is_initialized=0
  fi
  module+=(${is_initialized})               #MFS_MODULE_INITIALIZED=5
  local statusLine=("${moduleStatus}")
  local sha=${statusLine[0]}
  if [[ ${sha:0:1} == - || ${sha:0:1} == + ]]; then
    sha=${sha:1}
  fi
  module+=(${sha})                          # MFS_MODULE_SHA 6
  module+=("${managed[0]}")                 # MFS_MODULE_MANAGED 7
  module+=("${managed[1]}")                 # MFS_MANAGED_REFNAME 8
  popd &>/dev/null
}


function umbrella_finalize() {
  rm -rf ${globals[$G_SCRIPT_TMP_DIRECTORY]}
  _m_finalize
}

warn() { echo "$@" >&2; }
#die() { warn "$@"; exit 1; }

function die() {
  local msg="$1"
  [ -z "${msg}" ] && msg="Something goes wrong."
  cw_echo "${msg}"
  exit 1
}

function see_help() {
  local msg=$1
  if [[ -n "$msg" ]]; then
    msg+=" Type '$FLAGS_PREFIX --help' for more information"
  fi

  die "$msg"
}

function panic() {
  local msg="$1"
  [ -z "${msg}" ] && "Unexpected error. Please check the code or file bug to the forum/github/etc"
  echo "panic: ${msg}"
  exit 2
}

typeset cwVerboseContinue=0

function cw_cr() {
  printf "\n" >&2

}

function cw_echo() {
  echo "${0##*/}: $1"
  if [[ -n "$2" ]]; then
    shift
    cw_verbose_start
    while [ -n "$1" ]; do
      cw_verbose "$1\n"
      shift
    done
    cw_verbose_stop
  fi
}

function cw_verbose_start () {
  cwVerboseContinue=1
}


function cw_verbose () {
  if (( $verbose )); then
    printf "verbose: $1" >&2
    (( ! $cwVerboseContinue )) && printf "\n" >&2
  fi
}

function cw_verbose_stop () {
  if (( $verbose )); then
    if (( $cwVerboseContinue )); then
      printf "\n" >&2
    fi
    cwVerboseContinue=0
  fi
}

function splash() {
  (( $skipSplash )) && return
  local url=$1
  local implicit=$2
  local legoMode=${g_lego_mode}
  if [[ $legoMode == empty ]]; then
    legoMode='none'
  fi

  local msg="project: $url, lego mode: $legoMode"
  (( $implicit )) &&  [[ $g_lego_mode != empty ]] && [[ $g_lego_mode != detached ]]  && msg+=" (guessed)"

  local currentGitDir=$(get_repo_git_dir)
  local currentRepoName=${currentGitDir##*/modules/}
  [[ -n ${currentRepoName} && ${url} != ${currentRepoName} && $currentGitDir != ".git" ]] && msg+=", current module '"${currentRepoName}"'"
  cw_echo "${msg}"
}

get_possible_tag_unsafe() {
  local ret=0
  local tag
  ## git status --porcelain does not shows get tag version
  ## so we need to use 'old good' git status --long for that
  while read -a output; do
    # find out tag or has
    # format HEAD detached at 23a34b or HEAD detached at refs/heads/master
    local parsedLength="${#output[@]}"
    tag="${output[$parsedLength-1]}"
  done < <(git status --long -uno | grep "HEAD detached at")

  echo "$tag"
  return "$ret"
}


get_reftype_of_refname() {
  local ret=0
  local refType
  local refName=$1
#  local blobName=$( get_blob_revision "$refName" )
  local fullRefname=$( git rev-parse --symbolic-full-name HEAD 2>/dev/null )
  ret=$?
  if (( ! $ret )); then
    case "$fullRefname" in
      HEAD|'')
        local possibleTag=$( get_possible_tag_unsafe )
        ret=$?
        if (( ! "$ret" )); then

          local possibleSha=$( git rev-parse --short HEAD)
          ret=$?

          if [[ "$possibleSha" == "$possibleTag" ]]; then
            refType="sha"
          else
            refType="pinned"
          fi
        fi
        ;;
      *)
        refType="branch"
        ;;
    esac
  fi

  echo "$refType"
  return "$ret"
}


#
# Evaluate and return refname and type of the repository.
# The repo's head can be either detached ('tag' or plain 'sha' or git checkout ... --detach or git checkout origin/master)
# or headed to some 'branch' (possible values for reftype)
# If reftype is branch, we checking remote branches as well, which names are equals.
#
function evaluate_refname() {
#  local type=${1:-full}
#  if [[ $type == full ]]; then
#    option=--symbolic-full-name
#  fi
  local refName=${1:-HEAD}
  local fullRefname=$( git rev-parse --symbolic-full-name "$refName" 2>/dev/null )
  local ret=()
  local abbrevRefCheck=0
  local token="sha"
  case ${fullRefname} in
    refs/tags/*)
      abbrevRefCheck=1
      refname="${fullRefname#refs/tags/}"
      token="pinned"
      ;;
    refs/heads/*)
      abbrevRefCheck=1
      refname="${fullRefname#refs/heads/}"
      token="branch"
      ;;
    refs/remotes/$legoRemote/*)
      abbrevRefCheck=1
      refname="${fullRefname#refs/remotes/$legoRemote/}"
      token="branch"
      ;;
#    HEAD)
  esac
  ret+=("$token")

  local option
  if (( $abbrevRefCheck )); then
    option="--abbrev-ref"
  else
    option="--short"
  fi

  fullRefname=$( git rev-parse "$option" "$refName" 2>/dev/null )
  ret+=("$fullRefname")

#  echo "${ret[@]}" >&2
  echo "${ret[@]}"
}


function get_repo_url() {
  [[ -n $1 && $1 != "." ]] && pushd $1  &>/dev/null
  local url=$(git remote get-url ${globals[$G_LEGO_REMOTE]} &> /dev/null)
  [[ -n $1 && $1 != "." ]] && popd  &>/dev/null
  echo ${url}
}

function get_repo_name_from_path() {
  [[ -n $1 && $1 != "." ]] && pushd $1  &>/dev/null
  local gitDir=$(get_repo_git_dir)
  [[ -n $1 && $1 != "." ]] && popd  &>/dev/null
  local name="${gitDir##*/modules/}"
  [[ $name == ".git" ]] && echo "/" || echo "$name"
}

function get_repo_git_dir() {
  [[ -n $1 && $1 != "." ]] && pushd $1  > /dev/null
  local url=$(git rev-parse --git-dir)
  [[ -n $1 && $1 != "." ]] && popd  &>/dev/null
  echo ${url}
}

function get_module_path_up() {
  local ret=1
  local path

  if [[ $1 != "/" ]]; then
    path=${1%/*}

    (( ! ${#path} )) && path="/"
    ret=0

  fi

  (( ! $ret )) && echo "${path}"
  return ${ret}
}


function level_verbose_about_to {

  local path=$4
  local info="about to ${SUBCOMMAND} module '${1}'"
  # global
  verboseMsg=([1]="path: $path")
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local fineIssues infoIssues
  verboseMsg[0]=${info}
#set +x
  cw_echo "${verboseMsg[@]}"

}


#
## Checks affected modules, which can be set after double dash
## ie. status / -- libs will check only libs module
#
# Parameters
#     $1 Module's full path to be tested on existence in afterDash array
#
# Returns
#     0 - module is found and listed in after dash parameters, or after-dash parameters are not set
#     1 - module is found but not listed in after dash parameters (out-filtered)
#     2 - N/A module is not found or wrong argument
#
# Globals using
#     $afterDash - array, which contains restricted module list, can be given after double dash or some other manner
#     $affected  - this variable should be defined outside of this function (output variable)
#
# TODO take into account --recursive flag
#
function drop_to_affected() {
  local path=$1
  local found=0
  local ret=1

#  affected=0

  [[ -z ${path} ]] && panic "$FUNCNAME() missed parameter 'path'"

  while read -a module; do
    found=0
    local moduleName=${module[$MFS_MODULE_NAME]}
    if [[ "$path" == ${module[$MFS_FULL_PATH]} || "$path" == ${module[$MFS_MODULE_PATH]} ]]; then
      found=1
      if (( ${#afterDash[@]} )); then
        found=0
        for branch in "${afterDash[@]}"; do
          # exact comparison, not matching
          if [ "${moduleName}" == ${branch} ]; then
            found=1
            break
          fi
        done
      fi
    fi

    if (( ${found} )); then
      affected=1
      ret=0
      echo ${module[@]} >> ${globals[$G_AFFECTED_MODULES]}
      break
    fi

  done < <(cat ${globals[$G_MODULES_FN]})
#  echo "${ret}"
  return ${ret}
}

function module_descriptor() {
  local levelPath=$1
  local found=0

  while read -a module; do
    found=0
    local moduleName=${module[$MFS_MODULE_NAME]}
    local fullPath=${module[MFS_FULL_PATH]}
    if [ "$levelPath" == "$fullPath" ]; then
      found=1
    fi

    if (( ${found} )); then
      echo ${module[@]}
      break
    fi

  done < <(cat ${globals[$G_MODULES_FN]})
}


function get_module_path_down() {
  local path
  local originPath="$1"
  local reminder="$2"
  if [[ ${originPath:(-1)} == "/" ]]; then
    path="$originPath$reminder"
  else
    path="$originPath/$reminder"
  fi

  local ret=1

  for mp in ${g_module_paths[@]}; do
    if [[ ${mp} == ${path} ]]; then
      ret=0
      break
    fi
  done

  (( ! $ret )) && echo "${path}"
  return ${ret}
}


function resolve_module_path() {
  cantResolve="Can't resolve module path '$1'"
  local originPath reminder="$1"
  local default="$2"

  if [[ -z ${reminder} ]]; then
    reminder=$default
  fi

  if [[ -n ${reminder} ]]; then
    if [[ -n ${reminder%%/*} && -n ${reminder%%../*} && $reminder != ".." && -n ${reminder%%./*} && $reminder != "." ]]; then
      reminder="./$reminder"
    fi

    if [[ -z ${reminder%%/*} ]]; then
      originPath="/"
      reminder=${reminder:1}
    elif [[ -z ${reminder%%../*} || $reminder == ".." ]]; then
      reminder=${reminder:3}
      originPath=$(_m_pmd)
      originPath=$(get_module_path_up ${originPath})
      (( $? )) && die "${cantResolve}"
    elif [[ -z ${reminder%%./*} || $reminder == "." ]]; then
      reminder=${reminder:2}
      originPath=$(_m_pmd)
    fi

    if (( ${#reminder} )); then
      IFS="/" read -a parts <<< $reminder
      for part in $parts; do
        case $part in
          \.\.\.)
            die "${cantResolve}"
          ;;
          \.\.)
            originPath=$(get_module_path_up ${originPath})
            (( $? )) && die "${cantResolve}"
          ;;
          \.)
            ## nothing
          ;;
          *)
            originPath=$(get_module_path_down ${originPath} ${part})
            (( $? )) && die "${cantResolve}"
          ;;
        esac
      done
    fi
  fi

  [[ -z $originPath ]] && originPath="${default}"

  echo "${originPath}"
}

function module_info () {
  local modulePath="$1"
  shift
  local index=0
  local ret=1
  local results=()
  for mp in ${g_module_paths[@]}; do
    if [[ ${mp} = ${modulePath} ]]; then
      ret=0
      break
    fi
    index=$(( index + 1 ))
  done


  while [[ -n $1 ]]; do
    case $1 in
      index)
        results+=($index)
        ;;
      name)
        results+=(${g_module_name[$index]})
        ;;
      relative|local)
        results+=(${g_relative_paths[$index]})
        ;;
      full|path)
        results+=(${g_full_paths[$index]})
        ;;
      gitdir)
        results+=(${g_git_dirs[$index]})
        ;;
      sha)
        results+=(${g_module_shas[$index]})
        ;;
      initialized)
        results+=(${g_module_inited[$index]})
        ;;
      managed)
        results+=(${g_module_managed[$index]})
        ;;
      refname)
        results+=(${g_managed_refnames[$index]})
        ;;
      *)
        ret=2
        break
    esac
    shift
  done

  (( ${#results[@]} )) && echo ${results[@]}
  return ${ret}
}


#
#
#
function is_branch_exists() {
  [[ -z $1 ]] && (panic "'branch' argument for is_branch_exists() should be given")
  local branchName="$1"
  local metrics="${2:-0}"

  local remote="${globals[$G_LEGO_REMOTE]}"
  local checkingPlaces=()


  if (( "${#remote}" )); then
    local givenRemote=0

    if [[ "${branchName#refs/remotes/$remote/}" != "$branchName" || "${branchName#remotes/$remote/}" != "$branchName" || "${branchName#$remote/}" != "$branchName" ]]; then
      givenRemote=1
    fi

    if (( ! $givenRemote )); then
      checkingPlaces+=("")
    fi

    checkingPlaces+=("$remote/")
  fi

  if (( ! "${#checkingPlaces[@]}" )); then
    checkingPlaces+=("")
  fi

  local ret=0

  local found=(0)
  for prefix in "${checkingPlaces[@]}"; do
    local prefixBranch="${prefix}${branchName}"
    git rev-parse --no-revs "$prefixBranch" &>/dev/null
    local ret=$?

    if (( ! $ret )); then
      found[0]=1

      if (( "$metrics" )); then
        found+=("$prefixBranch")

        if [[ -n "$prefix" ]]; then
          found+=(1)
        else
          found+=(0)
        fi
      fi
      break
    fi
  done

  echo "${found[@]}"
  return ${ret}
}


typeset MODULE_STATUS=()
#
##  Get status for current module
#
#     Filling up $MODULE_STATUS array with parsed information about current module state.
#     Information in the array will be valid till next call of the method.
#     Directory of module should be set outside this function.
#
## Parameters
#     $1  - file path of current module
#     $2  - caller, which indicated the caller script, ie. "status"/"commit"/..
#     ... - other parameters relevant to its caller
#       For 'status' mode
#           $3 - stick-on-branches, branch which outer module expects inner module to be
#
## Globals affected
#     $MODULE_STATUS array
#
function module_porcelain_status() {

  local remoteInteraction=0 managedBranch guessedBranched=()
  unset MODULE_STATUS

  local modulePath="$1"
  local caller=$2

  [[ -z ${modulePath} ]] && panic "$FUNCNAME(): missed parameter 'path'"

  [[ $caller == push || $caller == pull ]] && remoteInteraction=1

  local moduleSha
  local managed
  local guessing=1

  read initialized managedReftype managedRefname < <(module_info ${modulePath} "initialized" "managed" "refname")
  if [[ -z $initialized ]]; then
    panic "$FUNCNAME(): Variable \$initialized is empty. Check code!"
  fi

  if [[ "$managedReftype" == "unmanaged" ]]; then
    MODULE_STATUS[$MS_UNMANAGED]=1
  else
    MODULE_STATUS[$MS_UNMANAGED]=0
    MODULE_STATUS[$MS_MANAGED]=$( ref_type_index "$managedReftype")

    if [[ -n "$managedRefname" && "$managedRefname" != "$NA" ]]; then
      MODULE_STATUS[$MS_MANAGED_REFNAME]="$managedRefname"
    fi

  fi

  local moduleRefname
  declare -a output

  if (( ! $initialized )) ; then
    MODULE_STATUS[$MS_UNINITIALIZED]=1
  else
    MODULE_STATUS[$MS_UNINITIALIZED]=0

    while read switch line; do
#      echo $switch >&2
#      echo $line >&2
      # parse line into array or words
      output=(${line})

      case $switch in
        \#)
          case ${output[0]} in
            branch\.oid)
              moduleSha=${output[1]}
              # TODO do this at bootstrap
              MODULE_STATUS[$MS_MODULE_REFNAME]=$( git rev-parse --short "$moduleSha" )
              ;;
            branch\.head)

              if [[ ${output[1]} == \(detached\) ]]; then
                MODULE_STATUS[$MS_DETACHED]=1
                moduleRefname=$( get_possible_tag_unsafe )
                if [[ -n ${moduleRefname} ]] ; then
                  MODULE_STATUS[$MS_MODULE_REFNAME]="${moduleRefname}"

                  local plainSha=$( git rev-parse --short "$moduleRefname" )
                  if [[ "$moduleRefname" == "$plainSha" ]] ; then
                    # specifies it's plain sha, not tag or detached head
                    MODULE_STATUS[$MS_DETACHED]=2
                  fi
                fi
              else
                MODULE_STATUS[$MS_DETACHED]=0
                MODULE_STATUS[$MS_MODULE_REFNAME]=${output[1]}
              fi

              if [[ ( ${MODULE_STATUS[$MS_DETACHED]} != ${MODULE_STATUS[$MS_MANAGED]} ||  ${MODULE_STATUS[$MS_MANAGED_REFNAME]} != ${MODULE_STATUS[$MS_MODULE_REFNAME]} ) \
                  && ${MODULE_STATUS[$MS_UNMANAGED]} == 0 \
                  && $modulePath != "/" ]]
              then
                MODULE_STATUS[$MS_MISMATCHED]=1

                if (( ${MODULE_STATUS[$MS_DETACHED]} > 0 )) && [[ -n ${managedRefname} ]]; then
                  calculate_ab_for_tag "${managedRefname}"
                fi
              else
                MODULE_STATUS[$MS_MISMATCHED]=0
              fi
              ;;

            branch\.upstream)
              MODULE_STATUS[$MS_UPSTREAM]=${output[1]}
              ;;
            branch\.ab)
              MODULE_STATUS[$MS_UPSTREAM_AHEAD]=${output[1]:1}
              MODULE_STATUS[$MS_UPSTREAM_BEHIND]=${output[2]:1}
              if (( ${MODULE_STATUS[$MS_UPSTREAM_AHEAD]} )); then
                MODULE_STATUS[$MS_PUSHABLE]=1
              fi
              if (( ${MODULE_STATUS[$MS_UPSTREAM_BEHIND]} )); then
                MODULE_STATUS[$MS_PULLABLE]=1
              fi
              ;;
          esac
          ;;
        \?)
          local entryName="${output[0]}" #.gitmodule or .gitlego
          if [[ ${entryName} == \.gitmodules  || ${entryName} == \.gitlego ]]; then
            MODULE_STATUS[$MS_MODIFIED_SUBMODULE]=$(( MODULE_STATUS[$MS_MODIFIED_SUBMODULE] + 1 ))
            MODULE_STATUS[$MS_COMMITABLE]=1
          else
            MODULE_STATUS[$MS_UNTRACKED]=$(( MODULE_STATUS[$MS_UNTRACKED] + 1 ))
          fi
          ;;

        1|2|u)
          local fileState=${output[0]}
          local fChar=${fileState:0:1} sChar=${fileState:1:1}
          local submoduleToken=${output[1]}
          local entryName=${output[7]} #.gitmodule or .gitlego or submodule name
          if [[ ${entryName} == \.gitmodules  || ${entryName} == \.gitlego  || ${submoduleToken:0:1} == S ]]; then MODULE_STATUS[$MS_MODIFIED_SUBMODULE]=$(( MODULE_STATUS[$MS_MODIFIED_SUBMODULE] + 1 )) ; MODULE_STATUS[$MS_COMMITABLE]=1;
          elif [[ ${fChar} == M || ${sChar} == M ]] ; then MODULE_STATUS[$MS_MODIFIED]=$(( MODULE_STATUS[$MS_MODIFIED] + 1 )) ; MODULE_STATUS[$MS_COMMITABLE]=1;
          elif [[ ${fChar} == A || ${sChar} == A ]] ; then MODULE_STATUS[$MS_ADDED]=$(( MODULE_STATUS[$MS_ADDED] + 1 )); MODULE_STATUS[$MS_COMMITABLE]=1;
          elif [[ ${fChar} == D || ${sChar} == D ]] ; then MODULE_STATUS[$MS_DELETED]=$(( MODULE_STATUS[$MS_DELETED] + 1 )); MODULE_STATUS[$MS_COMMITABLE]=1;
          elif [[ ${fChar} == R || ${sChar} == R ]] ; then MODULE_STATUS[$MS_RENAMED]=$(( MODULE_STATUS[$MS_RENAMED] + 1 )); MODULE_STATUS[$MS_COMMITABLE]=1;
          elif [[ ${fChar} == C || ${sChar} == C ]] ; then MODULE_STATUS[$MS_COPIED]=$(( MODULE_STATUS[$MS_COPIED] + 1 )); MODULE_STATUS[$MS_COMMITABLE]=1;
          elif [[ ${fChar} == U || ${sChar} == U ]] ; then MODULE_STATUS[$MS_UNMERGED]=$(( MODULE_STATUS[$MS_UNMERGED] + 1 )); MODULE_STATUS[$MS_COMMITABLE]=1; fi
          ;;
      esac
    done < <(git status -u --porcelain=2 -b)

    (( "$guessing" )) && guess_refnames_of_commit "$modulePath" HEAD

  fi
#  echo "$FUNCNAME(): ${MODULE_STATUS[@]}"
}


ref_type_index() {
  local managedReftype="$1"
  local index=0
  for reftype in "${g_lego_aware_tokens_gitmodules[@]}" ; do
    if [[ "$reftype" == "$managedReftype" ]]; then
      break
    fi
    index=$(( $index + 1 ))
  done

  echo $index
}

function module_up() {
  cd $(git rev-parse --show-toplevel)"/.."
  cd $(git rev-parse --show-toplevel)
}


#
# External arrays:
#     MODULE_STATUS
#
calculate_ab_for_tag() {
#  echo "$FUNCNAME()" >&2
  local rev=$1
  local against=${2:-HEAD}
  local ret=0
  local ab=()
  local reachable=$( git merge-base "$rev" "$against" 2>/dev/null | wc -l )
  ret=$?

  if (( ! "$ret" )); then
    if (( "$reachable" )); then
      local out=$( git rev-list "$against".."$rev" 2>/dev/null | wc -l )
      ret=$?
      if (( ! "$ret" )); then
        local a=$(( $out + 0 ))
        ab+=(+"$a")
        MODULE_STATUS[$MS_UPSTREAM_AHEAD]="$a"

        out=$( git rev-list "$rev".."$against" 2>/dev/null | wc -l )
        ret=$?

        if (( ! "$ret" )); then
          local b=$(( $out + 0 ))
          MODULE_STATUS[$MS_UPSTREAM_BEHIND]="$b"
          ab+=(-"$b")
        fi
      fi
    fi
  fi

  echo "${ab[@]}"
  return "$ret"
}


calculate_ab_for_branch() {
#  echo "$FUNCNAME()" >&2
  local branchName=$1
  local against=${2:-HEAD}

  local ab=()
  local ret=0

  read branchExists maybeRemoteBranch isRemote < <( is_branch_exists "$branchName" 1 )

  ab+=("$branchExists")

  if (( "$branchExists" )); then
    ab+=("$isRemote")
    ab+=("$maybeRemoteBranch")

    local reachable=$( git merge-base "$maybeRemoteBranch" "$against" 2>/dev/null | wc -l )
    ret=$?

    if (( ! "$ret" )) && (( $reachable )); then
      local out=$( git rev-list "$against".."$maybeRemoteBranch" 2>/dev/null | wc -l )
      ret=$?

      if (( ! "$ret" )); then
        local a=$(( $out + 0 ))
        ab+=(+"$a")
        MODULE_STATUS[$MS_UPSTREAM_AHEAD]="$a"

        out=$( git rev-list "$maybeRemoteBranch".."$against" 2>/dev/null | wc -l )
        ret=$?

        if (( ! "$ret" )); then
          local b=$(( $out + 0 ))
          MODULE_STATUS[$MS_UPSTREAM_BEHIND]="$b"
          ab+=(-"$b")
        fi
      fi
    fi
  fi

  echo "${ab[@]}"
  return "$ret"
}


#
# External arrays:
#     guessedRefnames
#     asWellRefs
#
calculate_as_well_refnames() {
  local refName=$1

  for asWell in ${guessedRefnames[@]} ; do
    [[ "${asWell}" != "${refName}" ]] && asWellRefs+=("$asWell")
  done
}


function guess_refnames_of_commit() {
  local modulePath="$1"
  local ret hash=${2:-HEAD}
  local branches=()
  local tags=()
  # const
  local legoRemote=${globals[$G_LEGO_REMOTE]}

  if [[ ${modulePath} != / ]]; then
    while read moduleSha commit ref; do
#      echo $ref >&2
      refParsed=$(git rev-parse --abbrev-ref=loose ${ref})
      found=0

      if [[ ${ref#refs/tags/} == ${refParsed} ]] ; then
        for tag in ${tags[@]}; do
          if [[ "${tag}" = ${refParsed} ]]; then
            found=1
            break
          fi
        done

        if [[ ${found} == 0 ]]; then
#          echo ${refParsed} >&2
          tags+=("${refParsed}")
        fi
      else
        if [[ ${refParsed#heads/} != $refParsed ]]; then
          # filter out heads/master
          refParsed=${refParsed#heads/}


        elif [[ ${refParsed#${legoRemote}/} != $refParsed ]]; then

          # filter out origin/master
          refParsed=${refParsed#${legoRemote}/}


        elif [[ ${ref#refs/remotes/} == $refParsed ]]; then

          # filter out heads/remotes/other_remote/master
          local otherRemote=${ref#refs/remotes/} # other_remote/master
          if [[ ${otherRemote#${legoRemote}/} == ${otherRemote} ]]; then
            found=1
          fi
        fi

        if (( ! $found )); then
          for branch in ${branches[@]}; do
            if [[ "${branch}" == ${refParsed} ]]; then
              found=1
              break
            fi
          done

          if (( ! $found )) ; then
#            echo ${refParsed#${legoRemote}/} >&2
            branches+=("${refParsed#${legoRemote}/}")
          fi

        fi

      fi

    done < <(git for-each-ref --points-at=${hash})

    MODULE_STATUS[$MS_GUESSED_BRANCHES]="${branches[@]}"
    MODULE_STATUS[$MS_GUESSED_TAGS]="${tags[@]}"
  fi
}


construct_section_name() {
  local modulePath="$1"
  local extension="$2"
  local dir="${globals[$G_SCRIPT_TMP_DIRECTORY]}"
  local fn once=0

  if [[ ${#modulePath} == 0 || ${modulePath:0:1} != "/" ]]; then
    fn+="/"
  fi
  (( ${#modulePath} )) && fn+=${modulePath}

  fn=$(echo ${fn} | tr "/" "_")
  echo "$dir/${fn}.${extension}"
}

function export_gitmodules_section {
#  echo ${FUNCNAME}": $@" >&2
  local modulePath="$1"
  local moduleName="$2"
  local revision="$3"
  local dumpFileName=$(construct_section_name "$1" "$3")
#  echo "${dumpFileName}"
#  pwd
  while  read -a module; do
    echo ${module[@]} >> ${dumpFileName}
  done < <(git config --file .gitmodules --get-regexp "submodule.${moduleName}.*")
#  cat "${dumpFileName}"
}

function import_gitmodules_section {
#  echo ${FUNCNAME}": $@" >&2
  local modulePath="$1"
  local moduleName="$2"
  local revision="$3"
  local dumpFileName=$(construct_section_name "$1" "$3")
#  echo "${dumpFileName}"
#  pwd
  while  read -a setting; do
    git conifg --file .gitmodules ${setting[@]}
  done < <(cat "${dumpFileName}")
}


function prepare_checkout_level() {
#  echo ${FUNCNAME}": $@" >&2
  pwd >&2

#  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local revision="$1"
  local modulePath="$2"
  local moduleName="$3"
  local levelPath="$4"
  local parentRefname="$5"
  local parentRefType="$6"

#TODO get it from array?
  local toBeDeleted=0
  local ret=0

  module_porcelain_status "${modulePath}" checkout
#  echo "parentRefname: $parentRefname  parentRefType: $parentRefType"
  if [[ "$revision" == "-" ]]; then
    local type
    local guessedRefnames=()
    read revision type < <( evaluate_attain_hint  "$parentRefname" "$parentRefType" )
    MODULE_STATUS[$MS_MANAGED_REFNAME]="$revision"
    MODULE_STATUS[$MS_MANAGED]=$( ref_type_index "$type")
    MODULE_STATUS[$MS_UNMANAGED]=0

  fi
  if (( $toBeDeleted )); then

    if [[ 0 == ${doForce} && (1 == ${MODULE_STATUS[$MS_COMMITABLE]} || 1 == ${MODULE_STATUS[$MS_UNTRACKED]} || 1 == ${MODULE_STATUS[$MS_PUSHABLE]}) ]]; then
      dieMsg+="Module '$moduleName' has not committed or not pushed changes, but intended to be deleted as it does not exists in revision "
      ret=1
    fi

  else
    pwd >&2
    ### Use case when in new checkout revision the submodule not exists, but in current branch it is change
    ### It should be vetoed, but this veto can be disclosed only on the next call for getting if sub-module is
    ### commitable.
    local blobRevision=$( get_blob_revision "$revision" )

    local noSubmodules=$(git cat-file -s "${blobRevision}":.gitmodules &>/dev/null; echo $?)
    if (( ! $noSubmodules )); then
      while read -a module; do
        local after="${module[0]}"
        modulesAfter+=("$after")
        local pathAfter="${modulePath}"
        [[ "${pathAfter:-1}" != "/" ]] && pathAfter+="/"
        pathAfter+="${after}"
        modulePathsAfter+=("$pathAfter")
      done < <(git config --blob ${blobRevision}:.gitmodules --get-regexp "submodule.*.path" 2>/dev/null | sed -E "s/submodule\.(.*)\.path/\1/" )
    fi

    local found
    local moduleIndex=0
    while read -a module; do
      local before="${module[0]}"
      modulesBefore+=("$before")
      local localPath="${module[1]}"
      local pathBefore="${modulePath}"
      [[ "${pathBefore:-1}" != "/" ]] && pathBefore+="/"
      pathBefore+="${localPath}"
      modulePathsBefore+=("$pathBefore")

      found=0
      if (( ! $noSubmodules )); then
        local after
        for after in "${modulesAfter[@]}"; do
          if [[ "$after" == "$before" ]]; then
            found=1
            break
          fi
        done
      fi

      if (( ! $found )); then
        deletedModules+=("${before}")

        ## TODO wrong stuff? MODULE_STATUS is populated now from deleted module (?!) should check!
        pushd "${localPath}" &>/dev/null
        module_porcelain_status "${pathBefore}" checkout
        popd  &>/dev/null

        if [[ 0 == ${doForce} && ( 1 == ${MODULE_STATUS[$MS_COMMITABLE]} || 1 == ${MODULE_STATUS[$MS_UNTRACKED]} || 1 == ${MODULE_STATUS[$MS_PUSHABLE]} ) ]]; then
          dieMsg+="Module '$before' (maybe others as well) has not committed or not pushed changes, but intended to be deleted as it does not exists in revision $revision"
          return 1
        fi
      else
        local foundPath="${modulePathsAfter[$moduleIndex]}"
        if [[ "$foundPath" != "${module[1]}" ]]; then
          movedModules+=("${before}")
        fi
      fi
      moduleIndex=$(( $moduleIndex + 1 ))
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

    if (( ! $noSubmodules )); then
      moduleIndex=0
      local pathAfter pathBefore
      for pathAfter in "${modulePathsAfter[@]}"; do
        local hash
        local after="${modulesAfter[${moduleIndex}]}"

        found=0
        for pathBefore in "${modulePathsBefore[@]}"; do
          if [[ "$pathBefore" == "$pathAfter" ]]; then
            found=1
            break
          fi
        done

        if (( ! $found )); then
          addedModules+=("${after}")
        fi

        moduleIndex=$(( $moduleIndex + 1 ))
      done
    fi
  fi

#  popd &>/dev/null
  return ${ret}
} ## of prepare_checkout_level



persist_attain_hint() {
  local doApply="$1"
  local moduleName="$2"
  local refName="$3"
  local refType="$4"
  local mode="${5:-${g_lego_mode}}"
  local ret=0

  # Do checkout for branches only.
  # currently tag or sha reference will not affect ot the reporting (possible bug, currently in 2.14.2)
  if (( "$doApply" )) && [[ "$refType" == "branch" ]]; then
    cw_echo "About to update $moduleName to $refName..."
    git checkout "$refName"
    ret=$?
  fi

  if (( "$ret" )); then
    dieMsg="$FUNCNAME(): unexpected error by 'git checkout $refName'"
  else
    local key="$refType"
    local section="submodule.$moduleName"
    cw_echo "Module '$moduleName' is attained to $refName [$refType]"
    set_module_meta_mode "$key" "$refName" "$section" ".." "$mode"
  fi

  return "$ret"
}


#
# EXTERNAL : guessedRefnames - array of branches of tags
#
evaluate_attain_hint() {
  local parentRefname="$1"
  local parentRefType="$2"
  local hint=()

  local guessedRefname
  local guessedReftype=${parentRefType}

  case ${parentRefType} in
    branch)
      guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
      if (( ! ${#guessedRefnames[@]} )); then
        guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
        if (( ${#guessedRefnames[@]} )); then
          guessedReftype="pinned"
        else
          guessedReftype="sha"
        fi
      fi
      ;;
    pinned)
      guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
      if (( ! ${#guessedRefnames[@]} )); then
        guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
        if (( ${#guessedRefnames[@]} )); then
          guessedReftype="branch"
        else
          guessedReftype="sha"
        fi
      fi
      ;;
#    sha)
#      guessedRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
#      ;;
  esac

  if [[ ${#guessedRefnames[@]} == 1 ]]; then
    guessedRefname="${guessedRefnames[0]}"
  elif [[ ${#guessedRefnames[@]} > 1 && -n "$parentRefname" ]]; then
    for myRefname in "${guessedRefnames[@]}"; do
      if [[ "$myRefname" == "$parentRefname" ]]; then
        guessedRefname="$myRefname"
      fi
    done
  fi

  if [[ -z "${guessedRefname}" && "${#guessedRefnames[@]}" ]]; then
    guessedRefname="${guessedRefnames[0]}"
  fi

  if [[ -z "${guessedRefname}" ]]; then
    guessedRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
  fi

  hint+=("$guessedRefname")
  hint+=("$guessedReftype")
  echo "${hint[@]}"
}


do_module_update() {
#echo "$FUNCNAME()" $@ >&2
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local modulePath="$3"
  local parentFullPath="$4"
  local revision="$5"

  if [[ $modulePath != / ]]; then
    local uninitialized=${MODULE_STATUS[$MS_UNINITIALIZED]}
    local unmanaged=${MODULE_STATUS[$MS_UNMANAGED]}
    local applied=0

    applied=1
    if (( "$uninitialized" )) || (( ! "$unmanaged" )) || [[ -n "$revision" ]] || (( $doForce )); then

      local managedRefname
      pushd "${parentFullPath}" &>/dev/null
      if (( $uninitialized )); then
        cw_echo "About to update module $moduleName..."
        git submodule update --init -- "${moduleName}"
        (( ! $? )) && cw_echo "... OK!"
      fi
      popd &>/dev/null

      if [[ -n "$revision" ]]; then
        managedRefname="$revision"
      elif (( ! $unmanaged )) ; then
        managedRefname=${MODULE_STATUS[$MS_MANAGED_REFNAME]}
#        else
#          managedRefname=$( get_attained_hint )
      fi
      if [[ -n "${managedRefname}" ]] ; then
        cw_echo "About to checkout to '$managedRefname' for '$moduleName' ..."
        git checkout "${managedRefname}"
        (( ! $? )) && cw_echo "... OK!"
      fi
    fi
  fi
}


update_level() {
#echo "$FUNCNAME()" $@ >&2
  local levelPath="$1"
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local modulePath="$3"

  local ret=0   # return code
  local childRet # child return code

  drop_to_affected "$levelPath"
  if (( ! $? )) ; then

    module_porcelain_status "${modulePath}" update

    do_module_update "$@"

    if [ -f .gitmodules ]; then
      while read -a module; do
        childRet=0
        moduleName="${module[0]}"
        localPath="${module[1]}"
        subRepoPath="${levelPath}"
        [[ ${subRepoPath:(-1)} != "/" ]] && subRepoPath+="/"
        subRepoPath+="${localPath}"

        local modulePath="$3"
        [[ ${modulePath:(-1)} != "/" ]] && modulePath+="/"
        modulePath+="$moduleName"

        pushd "${subRepoPath}" &>/dev/null
        update_level "${subRepoPath}" "${moduleName}" "${modulePath}" "$levelPath"
        childRet=$?

        (( $childRet > $ret )) && ret = ${childRet}
        popd  &>/dev/null
      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi
  fi
}

#
## DEPRECATED in favor of attain/update commands
#
## Checks branching state for current repository
## Let name the branch is synchronized if entry submodule.<module-name>.branch in .gitmodules is matched
## to the branch of the sub-repository, (what can be checked via 'cd module-path; git branch',
##
## It they are mismatched, 3 options are possible.
##
## 1. Sub-repo can be detached. In this case we are looking for value in the outer repo and doing git checkout branch
## 2. Sub-repo is pinned to another branch that is given in .gitmodules. To sync this we just changing value in .gitmodules file of outer repo
## 3. Sub-repo is detached, no value in .gitmodules. We are unable to re-syncronize, notify user about and exit.
## Parameters:
##      $1 path [required] - path getting started checking.
##      $2 doSync [optional, by default 0] - do synchronization (case 1) or not
##
## The function calls itself recursively to drill down to any leave repos.
##
## Returns
##
function check_branch_sync() {
  local levelPath="$1"
  local doSync=${2:-0}

  [[ -z ${levelPath} ]] && panic "check_branch_sync()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is synchronized
  local childRet # child return code
  cd "${levelPath}"

  while read -a repo; do
    childRet=0
    subRepoName="${repo[0]}"
    checkBranch=$(git config --file .gitmodules --get submodule."${subRepoName}".branch)
    checkPath="${repo[1]}"
    subRepoPath="${levelPath}"/"${checkPath}"

    #    echo "${subRepoName}" "${checkBranch}" "${checkPath}"

    pushd "${subRepoPath}" &>/dev/null
    #    pwd

    repoBranch=$(git rev-parse --abbrev-ref HEAD)
    local detached=0
    [[ "${repoBranch}" == "HEAD" ]] && detached=1

    #    echo "${repoBranch}"
    if [[ ${repoBranch} != ${checkBranch} ]]; then

      ret=1
      (( ! $doSync )) && cw_echo "Module ${subRepoName} is not synchronized"
      #      echo "$repoBranch != $checkBranch"

      #
      if [[ -n "${repoBranch}" && ${detached} == 0  ]]; then
        cd "${levelPath}"
        if (( $doSync )); then
          cw_echo "About to change reference in .gitmodules for submodule $subRepoName to branch $repoBranch"
          git config --file .gitmodules submodule."${subRepoName}".branch "${repoBranch}"
          ret=$?
        fi
      elif [[ -n "${checkBranch}" && ${detached} == 1 ]]; then
        cd "${subRepoPath}"
        if (( $doSync )); then
          cw_echo "About to checkout submodule $subRepoName to branch $checkBranch"
          git checkout ${checkBranch}
          ret=$?
        fi
      else
        cw_echo "Warning: submodule ${subRepoName} can't be synchronized"
        ret=2
      fi
    else
      (( $doView )) && cw_echo "Module '$subRepoName' at '$checkBranch' branch"
    fi

    if [[ -e .gitmodules ]]; then
      check_branch_sync "${subRepoPath}" ${doSync}
      childRet=$?
    fi
    (( $childRet )) && ret=1


    popd  &>/dev/null

    if (( $doSync )); then
      git diff --exit-code --quiet -- .gitmodules
      needToCommit=$?
      #echo "needToCommit=${needToCommit}"
      if (( $needToCommit)); then
        if (( $doAutoCommit )); then
          git add .gitmodules
          git commit -m "$subRepoName submodule configuration is changed"
        else
          needMessageToPush=1
        fi
      fi
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return "${ret}"
} ## of check_branch_sync



  ######################################################################################################################
  #################################################   MLS  #############################################################
  ######################################################################################################################



function _m_finalize() {
  unset strict
  unset verbose
  unset recursive
#  set +x
}

function _m_mls() {
  local ret=0
  while read -a module; do
    subModule="${module[0]}"
    localPath="${module[1]}"
    pushd "$localPath" &>/dev/null
    _m_pmd

# TODO recursive is not defined. should be parameter?
    if (( $recursive )); then
      _m_mls && ret=1
    fi

    popd &>/dev/null
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  return ${ret}
}

function _m_not_git_repository() {
  git rev-parse --git-dir &> /dev/null
  if (( $? )); then
    _m_die "Not a git repository"
    return 1
  fi
  return 0
}


function _m_pmd() {
  local gitDir=$(_m_git_dir)
  gitDir=${gitDir##*.git/}
  local path
  IFS="/" read -a names <<< ${gitDir}

  for name in ${names[@]}; do
    if [ ${name} != "modules" -a $name != ".git" ]; then
      path+=/"$name"
    fi
  done

  [[ -z $path ]] && path="/"
  echo  "${path}"
}


function _m_die() {
  echo $1 >&2
  _m_finalize
}


function _m_path_resolution() {
  local originPath reminder="$1"
  if [[ ${reminder} != "." && -n ${reminder} ]]; then
    local strict=$2

    if [[ -n ${reminder} ]]; then

      if [[ -z ${reminder%%/*} ]]; then
        _m_root 1; (( $? )) && return 1
        reminder=${reminder:1}
      elif [[ -z ${reminder%%../*} || $reminder == ".." ]]; then
        reminder=${reminder:3}
        _m_pwd 1
        _m_up 1; (( $? )) && return 1
      elif [[ -z ${reminder%%./*} || $reminder == "." ]]; then
        reminder=${reminder:2}
        _m_pwd 1
      fi

      if (( ${#reminder} )); then
        IFS="/" read -a parts <<< $reminder
        for part in $parts; do
          case $part in
            \.\.)
              _m_up 1; (( $? )) && return 1
            ;;
            \.)
              ## nothing
            ;;
            *)
              _m_down ${part} 1 $strict; (( $? )) && return 1
            ;;
          esac
        done
      fi
    fi
  else
    _m_pwd 1
  fi

  pwd
}


function _m_up() {
  local doCd=$1

  if [[ "$doCd" == 1 ]]; then
    if [[ $(_m_git_dir) == ".git" ]]; then
      echo "Can't get up at the root module" >&2
      return 1
    else
      _m_pwd 1
      cd ..
      _m_pwd 1
    fi
  else
    # TODO
    echo "mode '$FUNCNAME $1' not yet implemented" >&2
    return 1
  fi
}


function _m_down() {
  local path="$1"
  local doCd="$2"
  local ret=1
  local strict="$3"

  if [[ -n $strict ]]; then
    path=${strict}${path}
  fi

  while read -a module; do
    subModule="${module[0]}"
    localPath="${module[1]}"
    echo "$subModule" | grep "${path}" &> /dev/null
    local existsReverted=$?
    if (( ! $existsReverted )); then
      ret=0
      if (( $doCd )); then
        cd "$localPath"
      else
        echo $(_m_pwd)/"${localPath}"
      fi
      break
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return ${ret}
}


  #
  ## Print module directory
  ## just like Unix pwd, but for modules hierarchy
  #
function _m_pwd() {
  local path=$(git rev-parse --show-toplevel)
  local doCd="$1"
  if (( "$doCd" )); then
    cd "${path}"
  else
    echo "${path}"
  fi
}


function _m_git_dir() {
  local url=$(git rev-parse --git-dir)
  echo ${url}
}


function _m_root() {
  local doCd="$1"
  local gitDir=$(_m_git_dir)
  local rootGitDir=${gitDir##*/}
  local root

  if [[ ${rootGitDir} == ".git" ]]; then
    root=$(git rev-parse --show-toplevel)
  else
    root="${gitDir%%/.git/*}"  > /dev/null
  fi

  if (( "$doCd" )); then
    cd "${root}"
  else
    echo "${root}"
  fi
}


#
# Boolean treated as it does in Java/javascript where true == 1|false == 0,
# opposed to bash world, where true == 0|false=1
# Sorry for inconvenience ;)
#
READ_boolean() {
  local input=${1:-0};
  local default=${2}

  case "${input}" in
    true|t|1)
      input=1;
    ;;
    false|f|0)
      input=0
    ;;
    *) warn "wrong format for boolean value, defaulting to 0" ;;
  esac
  echo ${input}
}


#
# Print a submodule configuration setting
#
# $1 = submodule name
# $2 = option name
# $3 = default value
#
# Checks in the usual git-config places first (for overrides),
# otherwise it falls back on .gitmodules.  This allows you to
# distribute project-wide defaults in .gitmodules, while still
# customizing individual repositories if necessary.  If the option is
# not in .gitmodules either, print a default value.
#
get_submodule_config () {
	name="$1"
	option="$2"
	default="$3"
	value=$(git config --get submodule."$name"."$option" &>/dev/null)
	if test -z "$value"
	then
		value=$(git config -f .gitmodules --get submodule."$name"."$option" &>/dev/null)
	fi
	printf '%s' "${value:-$default}"
}

resolve_module_managed() {
  local module_name=$1
  local module_path=$2
  local mode="${3:-$g_lego_mode}"
  local ret=()
  local found=0

  for token in "${g_lego_aware_tokens_gitmodules[@]}" ; do
    local section="submodule.${module_name}"
    local value=$(get_lego_setting_mode "${token}" "$section" "${mode}")

    if (( ${#value} )) ; then
      ret+=("${token}")
      ret+=("${value}")
      found=1
      break
    fi
  done

  if (( ! $found )); then
      ret+=("unmanaged")
      ret+=("$NA")
  fi
  echo "${ret[@]}"
}

################################################### DELETING #################################################

clean_git_config_section() {
#echo "$FUNCNAME()" $@ >&2
  local legoModesMask=$1
  [[ -z ${legoModesMask} ]] && panic "$FUNCNAME()... parameter 'modesMask' is required"
  local section=$2
  [[ -z ${section} ]] && panic "$FUNCNAME()... parameter 'section' is required"
  local fileOption

  local index=0
  for mode in ${g_lego_modes[@]}; do
    local bitIndex=$((1 << $index))
    if (( $bitIndex & $legoModesMask )); then
      if [[ ${mode} == versioned ]]; then
        fileOption="-f .gitlego"
        if [[ ${section} == lego ]]; then
          section=core
        fi
      elif [[ ${mode} == solo && ${section} == core ]]; then
        section=lego
      fi

      if [[ $fileOption != '-f .gitlego' || -e .gitlego ]]; then
        git config ${fileOption} --remove-section "${section}" 2>/dev/null
      fi
    fi
    index=$(( $index + 1 ))
  done

}


clean_module_meta_mode() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local mode=$1
  local moduleName=$2
  local worktree=$3

  local section="submodule.${moduleName}"
  for token in ${g_lego_aware_tokens_gitmodules[@]}; do
    wipe_lego_setting_at_mode "${token}" "${section}" "${mode}" "${worktree}"
  done
}


clean_module_meta_mask() {
#echo "$FUNCNAME()" $@ >&2
  local moduleName=$1     # required
  local legoModesMask=${2:-0} # required as well, by default - nothing wiped
  local worktree=$3

  local index=0
  for mode in ${g_lego_modes[@]}; do
    local bitIndex=$((1 << $index))
    if (( $bitIndex & $legoModesMask )); then
      clean_module_meta_mode "$mode" "$moduleName" "$worktree"
    fi
    index=$(( $index + 1))
  done
}


wipe_lego_setting_at_mode() {
#echo "$FUNCNAME()" $@ >&2
  local key=$1
  local section=$2
  local mode=${3:-${g_lego_mode}}
  local worktree=${4:-.}
  local value

  if [[ ${mode} == solo ]] ; then
    wipe_lego_setting_concrete "$1" "${section}" "$worktree" "--local"
  elif [[ ${mode} == versioned ]] ; then
    wipe_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitlego"
    if [[ -z ${section##submodule.*} ]] ; then
      wipe_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitmodules"
    fi
  fi
}


wipe_lego_setting_concrete() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  [[ -z $key ]] && panic "$FUNCNAME() missing parameter 'key'"
  local section="${2:-core}"
  local worktree="${3:-.}"
  local fileOption="${4---}"

  if [[ $worktree == . ]]; then
    unset worktree
  fi

  if [[ -z "${fileOption##--*}" &&  ${section} == core ]] ; then
    section=lego
  elif [[ -n "${fileOption##--*}" &&  ${section} == lego ]] ; then
    section=core
  fi

  if [[ ${fileOption} == -- ]]; then
    unset fileOption
  fi


  if [[ -n ${worktree} ]]; then
    pushd "$worktree" &>/dev/null
  fi

  if [[ $fileOption != '-f .gitlego' || -e .gitlego ]]; then
    git config ${fileOption} --unset-all "${section}.$key"  2>/dev/null
  fi
  ret=$?

  wipe_section_if_empty "$section" "$fileOption"

  if [[ -n ${worktree} ]]; then
    popd &>/dev/null
  fi

}


wipe_section_if_empty () {
#echo "$FUNCNAME()" $@ >&2
  local section=$1
  local fileOption=${2:---}

  if [[ -z "${fileOption##--*}" &&  ${section} == core ]] ; then
    section=lego
  elif [[ -n "${fileOption##--*}" &&  ${section} == lego ]] ; then
    section=core
  fi

  if [[ ${fileOption} == -- ]]; then
    unset fileOption
  fi

  local keyRe="${section}.*"

  local notEmpty=$( git config $fileOption --get-regexp "$section" 2>/dev/null | wc -l )

  if (( ! $notEmpty )); then
    if [[ $fileOption != '-f .gitlego' || -e .gitlego ]]; then
      git config ${fileOption} --remove-section "${section}" 2>/dev/null
      read c fn < <(wc -w .gitlego 2>/dev/null)
      if (( ! "$c" )); then
        rm -f .gitlego &>/dev/null
      fi
    fi
  fi
}


##################################################### SETTING #################################################
set_module_meta_mode() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  local value="$2"
  local section="$3"
  local worktree="${4:-.}"
  local mode="${5:-${g_lego_mode}}"
  local ret=0

  if [[ ${mode} == solo ]] ; then
    value=$( set_lego_setting_concrete "$key" "$value" "$section" "$mode" "$worktree")
    ret=$? || $ret
  elif [[ ${mode} == versioned ]] ; then
    value=$( set_lego_setting_concrete "$key" "$value" "$section" "$mode" "$worktree" "-f .gitlego" )
    ret=$? || $ret
  fi
  return $ret
}


set_lego_setting_concrete() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  [[ -z $key ]] && panic "$FUNCNAME() missing parameter 'key'"
  local value="$2"
  local section="$3"
  local mode="$4"
  local worktree="$5"
  local fileOption="${6---}"

  if [[ $worktree == . ]]; then
    unset worktree
  fi

  if [[ -z "${fileOption##--*}" && ${section} == core ]] ; then
    section=lego
  elif [[ -n "${fileOption##--*}" &&  ${section} == lego ]] ; then
    section=core
  fi


  if [[ $fileOption == -- ]]; then
    fileOption=--local
  fi

  if [[ -n ${worktree} ]]; then
    pushd "$worktree" &>/dev/null
  fi
#  pwd >&2
#  echo "git config "$fileOption" "$section.$key" "$value"" >&2

  git config ${fileOption} --replace-all "$section.$key" $value
  ret=$?

  if [[ -n ${worktree} ]]; then
    popd &>/dev/null
  fi

  return $ret
}


##################################################### GETTING #################################################
get_lego_setting_mode() {
#echo "$FUNCNAME()" $@ >&2
  local key=$1
  local section=$2
  local mode=${3}
  local worktree=${4:-.}
  local value

  if [[ ${mode} == solo ]] ; then
    value=$( get_lego_setting_concrete "$1" "${section}" "$worktree")
  elif [[ ${mode} == versioned ]] ; then
    value=$( get_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitlego" )
    if [[ -z "$value" && -z ${section##submodule.*} ]]; then
      value=$( get_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitmodules" )
    fi
  fi
#  echo "$value" >&2
  echo "$value"
}


get_lego_setting() {
#echo "$FUNCNAME()" $@ >&2
  local key=${1}
  local section=${2:-core}
  local worktree=${3:-.}
  local value=$( get_lego_setting_concrete "$key" "${section}" "$worktree" "-f .gitlego" )
  [[ -z "$value" && -z ${section##submodule*} ]] && value=$( get_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitmodules")
  [[ -z "$value" ]] && value=$( get_lego_setting_concrete "$1" "${section}" "$worktree" )
#  [[ -z value ]] || value=$( get_lego_setting_concrete $1 ${section} "$worktree" "--local" } )
#  [[ -z value ]] && value=$( get_lego_setting_concrete $1 ${section} "$worktree" "--global"} )
#  [[ -z value ]] && value=$( get_lego_setting_concrete $1 ${section} "$worktree" "--system"} )
  echo "$value"
}


##
get_lego_setting_concrete() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local key="$1"
  [[ -z $key ]] && panic "$FUNCNAME() missing setting name"
  local section="${2:-core}"
  local worktree="${3:-.}"
  local fileOption="${4---}"

  if [[ $worktree == . ]]; then
    unset worktree
  fi

  if [[ -z "${fileOption##--*}" && ${section} == core ]] ; then
    section=lego
  elif [[ -n "${fileOption##--*}" &&  ${section} == lego ]] ; then
    section=core
  fi

  if [[ $fileOption == -- ]]; then
    unset fileOption
  fi

  if [[ -n ${worktree} ]]; then
    pushd "$worktree" &>/dev/null
  fi

  echo $(git config ${fileOption} --get "${section}.$key" 2>/dev/null)

  if [[ -n ${worktree} ]]; then
    popd &>/dev/null
  fi
}


##
get_lego_mode() {
  local verbose=$1
  local mode=$( get_lego_setting "mode")
  local implicit=0
  local results=()
  if [[ -z "$mode" ]] ; then
    mode=$( investigate_lego_mode )
    implicit=1
  fi
  results+=("$mode")
  if [[ $verbose == 1 ]] ; then
    results+=("${implicit}")
  fi
  echo ${results[@]}
}

get_blob_revision() {
  local ret=0
  local levelRevision="$1"
  [[ -z "$levelRevision" ]] && ( ret=2; dieMsg="$FUNCNAME(): missing parameter 'revision'")
  local blobRevision="$levelRevision"
  if [[ -n "$levelRevision" ]]; then
    local isBranchRemote=$( is_branch_remote "$levelRevision" )

    if (( ! $isBranchRemote )); then
      local untrackedBranches=($( retrieve_untracked_remote_branches 1))
      for branch in "${untrackedBranches[@]}"; do
        if [[ "$branch" == "$levelRevision" ]]; then
          blobRevision="${globals[$G_LEGO_REMOTE]}/$levelRevision"
          break
        fi
      done
    fi
  fi
  echo "$blobRevision"
  return "$ret"
}

is_branch_remote() {
  local ret=0
  local branch=${1}
  local isRemote=0
  [[ -z "$branch" ]] && ret=1
  if [[ ${branch#${legoRemote}/} != "$branch" || ${branch#remotes/${legoRemote}/} != "$branch" || ${branch#refs/remotes/${legoRemote}/} != "$branch" ]]; then
    isRemote=1
  fi
  echo "$isRemote"
  return ${ret}
}

retrieve_untracked_remote_branches() {
  local ret=0
  local stripped=${1:-0}
  local legoRemote="${2:-${globals[$G_LEGO_REMOTE]}}"
#  TODO think is there need?
#  [[ -z "$legoRemote" ]] && ( ret=2; dieMsg="Lego remote for is not set")

  local currentBranches=() remoteBranches=()
  while read -a branch; do
    if [[ "${branch[0]}" == "*" ]]; then
      currentBranches+=("${branch[1]}")
    else
      currentBranches+=("${branch[0]}")
    fi
  done < <(git branch --list | grep -v HEAD)

  while read rBranch; do
    if [[ "${rBranch#${legoRemote}/}" != "$rBranch" ]]; then
      local strippedBranch="${rBranch#${legoRemote}/}"

      local found=0
      for branch in "${currentBranches[@]}"; do
        if [[ "$strippedBranch" == "$branch" ]]; then
            found=1
            break;
        fi
      done
      if (( ! "$found" )); then
        if (( $stripped )); then
          remoteBranches+=("$strippedBranch")
        else
          remoteBranches+=("$rBranch")
        fi
      fi
    fi
  done < <(git branch -r | grep -v HEAD)

  echo "${remoteBranches[@]}"
  return "$ret"
}



investigate_lego_mode() {
  local mode
#  local ambiguous
  local module value
  local cwRoot="${globals[$G_ROOT_DIR]}"
  local headed

  pushd ${cwRoot} &>/dev/null

  local fullRefname=$( git rev-parse --symbolic-full-name HEAD 2>/dev/null )
  case "${fullRefname}" in
    HEAD|'')
      mode="detached"
      globals[G_HEADED_REF]=$( git rev-parse --short HEAD 2>/dev/null )
      ;;
    *)
      globals[G_HEADED_REF]=${fullRefname#refs/heads/}
  esac

  if [[ -z "$mode" ]] ; then
    if [[ -e "$cwRoot/.gitlego" ]] ; then
      mode=versioned
    fi


    if [[  -e "${cwRoot}/.gitmodules" ]] ; then

      while read module path; do
        if [[ $(get_lego_setting_concrete "${module}.branch" "submodule" "." "-f .gitmodules") ]]; then
          if (( $( check_ambiguous_lego_mode versioned ${mode} ) )) ; then
            mode=ambiguous
          else
            mode=versioned
          fi
          break
        fi
      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

      while read module value; do
        if [[ $value == true ]] && [[ $(get_lego_setting_concrete "${module}.branch" "submodule" "." "--local") ]]; then
          if (( $( check_ambiguous_lego_mode solo ${mode} ) )) ; then
            mode=ambiguous
          else
            mode=solo
          fi
          break
        fi
      done < <(git config --get-regexp "submodule.*.active" | sed -E "s/submodule\.(.*)\.active/\1/")

    #else
    #   TODO if no .gitmodules file -> no submodule -> git-lego ambigious ??
    #
    fi
  fi

  popd &>/dev/null
  echo "${mode:-empty}"
}


check_ambiguous_lego_mode() {
  local val=$1
  local prevVal=$2
  if [[ -n $prevVal ]] && [[ $val != $prevVal ]] ; then
    echo 1
  else
    echo 0
  fi
}




  ######################################################################################################################
  ############################################  MAIN SCRIPT  ###########################################################
  ######################################################################################################################


# The sed expression here replaces all backslashes by forward slashes.
# This helps our Windows users, while not bothering our Unix users.
export GITLEGO_DIR=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")

usage() {

  cat << EOF

    Git extension to ease work with intensive using of git submodules

    working dir: ${GITLEGO_DIR}
    usage: git lego <subcommand>

    Try 'git lego <subcommand> help' for details
EOF
}



#set -x

main() {
	if [ $# -lt 1 ]; then
		usage
		exit 1
	fi

	# sanity checks
	local SUBCOMMAND="$1"; shift

	if [ ! -e "$GITLEGO_DIR/git-lego-$SUBCOMMAND" ]; then
		usage
		exit 1
	fi

  FLAGS_PREFIX="${0##*/} $SUBCOMMAND"
	# run command
	. "$GITLEGO_DIR/git-lego-$SUBCOMMAND"


	SUBACTION="default"

	# Particular script can figure out a specific action depends on arguments or other circumstances.
	# In this case it should define dispatch_subaction function and echo'ing required action.
	# If dispatch_subaction returns empty string - default is using
	if type "dispatch_subaction" >/dev/null 2>&1; then
		local dispatched=$(dispatch_subaction "$@")
		if [[ -n ${dispatched} ]]; then
		  SUBACTION=${dispatched}
		fi
	fi

	if ! type "cmd_$SUBACTION" >/dev/null 2>&1; then
		warn "Unknown subcommand: '$SUBACTION'"
		usage
		exit 1
	fi

  cmd_$SUBACTION "$@"
}

main "$@"
