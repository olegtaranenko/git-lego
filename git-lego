#!/usr/bin/env bash

  # After call to 'umbrella_bootstrap' this array contains following predefined values.
  #
  ## "${globals[$G_ROOT_DIR]}" [cwRoot]             - file system path to root repository
  ## "${globals[$G_MODULES_FN]}" [cwTmpSubmodules]  - temporary file name, which listed all current repositories
  #                                                   with additional information
  ## "${globals[$G_MODULE_GIT_DIR]}" [gitDir]       - current repository
  #

## Global arrays for quick access of frequently used parameters
## There are basically a cache
g_module_name=()
g_relative_paths=()
g_git_dirs=()
g_full_paths=()
g_module_paths=()

globals=()
  ################################## CONSTANTS FOR globals array ##########################################
  #
  ## Root repo path
  #
G_ROOT_DIR=0
  #
  ## reference to git directory for current submodule.
  #
G_MODULE_GIT_DIR=1
  #
  ## Human-readable name of root repository path
  #
G_ROOT_NAME=2
  #
  ## Temporary folder owned by script invocation
G_SCRIPT_TMP_DIRECTORY=3
  #
  ## Reference to temporary file which keeps all submodules' path in reversed order
  ##  It is useful to apply regular actions against all modules, like bulk commit,push,etc
  #
G_MODULES_FN=4
  #
  ## Reference to temporary file which keeps modules' paths, which are effectively affected by
  # applying bulk operations such pull, commit, etc
  # They are in 'absolute' module structure form like /, or /macosx/docs
  #
G_AFFECTED_MODULES=5



#################### CONSTANTS for MODULE STATUS (see function module_porcelain_status() ####################
#
MS_BRANCH_INFO=0   # String
MS_DETACHED=1      # 0 is clean, 1 is detached, 2 is not synced
MS_COMMITABLE=2    # 1/0
MS_UNTRACKED=3     # ?
MS_MODIFIED=4      # M
MS_DELETED=5       # D
MS_ADDED=6         # A
MS_RENAMED=7       # R
MS_COPIED=8        # C
MS_UNMERGED=9      # U
MS_PUSHABLE=10     # 1/0
MS_PULLABLE=11     # 1/0
MS_SUBMODULES=12   # S

# To make module orchestration convenient for clone/merge/etc, in outer module we keep hint, which symbolic reference
# (tag or branch) the inner module should be checked out.
# This hint is maintained in .gitmodules branch
MS_INNER_REV_HINT=13

# Inner module is initialized, but can be detached or not.
# In case of it is attached, possible situation where outer repo has revision hint other than inner module is
# In case of module is detached, we looking into possible branches/tags and looking what are points to the
# sha, currently inner module stick on. If there is the only one, we are assuming module is consent.
# otherwise module reconciliation is required.
MS_INCONSISTENT=14

# One or more branches referencing on the inner:HEAD, which can be synchronized to the branch
# after attaching without getting outer repo dirty
MS_GUESSED_BRANCHES=15 # strings' array

# Module is not initialized yet or git submodule deinit was applied
MS_UNINITIALIZED=16  # 1/0



########################### CONSTANTS FOR MODULE FILE SYSTEM  ###############################################
## Array is filled up in function umbrella_bootstrap () and serves for path resolution
#
MFS_MODULE_NAME=0
MFS_RELATIVE_PATH=1
MFS_GIT_DIR=2
MFS_FULL_PATH=3
MFS_MODULE_PATH=4
MFS_MODULE_INITIALIZED=5



# set this to workaround expr problems in shFlags on freebsd
#if uname -s | egrep -iq 'bsd'; then export EXPR_COMPAT=1; fi


umbrella_bootstrap (){
  legoRemote=$(get_submodule_config "lego.remote")
  local gitDir
  local umbrellaRepoDir
  local tmpDir=$(mktemp -q -d -t "$(basename "$0")" 2>/dev/null || mktemp -q -d)
  globals[$G_SCRIPT_TMP_DIRECTORY]=${tmpDir}
  globals[$G_LEGO_REMOTE]=${legoRemote:-origin}
  legoRemote=${globals[$G_LEGO_REMOTE]}

  _m_not_git_repository; (( $? )) && exit 1

  gitDir=$(git rev-parse --git-dir)
  normalizedGitDir=${gitDir##*/}
  if [[ ${normalizedGitDir} == ".git" ]]; then
    umbrellaRepoDir=$(git rev-parse --show-toplevel)
  else
    pushd "${gitDir%%/.git/*}"  &>/dev/null
    umbrellaRepoDir=$(git rev-parse --show-toplevel)
    popd  > /dev/null
  fi

#  rm ${cwTmpSubmodules} &>/dev/null
  pushd ${umbrellaRepoDir} &>/dev/null

#  local remoteOrigin=$(git remote show)
  local umbrellaOriginUrl umbrellaRepoName
  if [[ -n $remoteOrigin ]]; then
    local url=$(get_repo_url "$umbrellaRepoDir")

    umbrellaOriginUrl=$(git remote get-url "${legoRemote}")
    umbrellaRepoName=${umbrellaOriginUrl##*:}
    umbrellaRepoName=${umbrellaRepoName##*/}

  else
    umbrellaOriginUrl=$(pwd)
    umbrellaRepoName=${umbrellaOriginUrl##*/}
  fi

  globals[$G_AFFECTED_MODULES]=${tmpDir}/affected
  globals[$G_MODULES_FN]=${tmpDir}/modules

#  git submodule foreach --recursive  |  sed "s/[^']*//" | tr -d "'" >>  ${tmpModules}

  #globals is an array defined in the caller of this method
  globals[$G_ROOT_DIR]=${umbrellaRepoDir}
  globals[$G_MODULE_GIT_DIR]=${gitDir}
  globals[$G_ROOT_NAME]=${umbrellaRepoName}
  module_startup_investigate "${umbrellaRepoName}" "/" ".git" "${umbrellaRepoDir}" "/" 1
  popd &>/dev/null
  splash ${umbrellaRepoName}

  return 0
}


function module_startup_investigate() {
  local tmpModules=${globals[$G_MODULES_FN]}
  echo "$@">>${tmpModules}
  # map emulation for quick access of the
  g_module_name+=($1)
  g_relative_paths+=($2)
  g_git_dirs+=($3)
  g_full_paths+=($4)
  g_module_paths+=($5)

  while read -a module
  do
    local subModule="${module[MFS_MODULE_NAME]}"
    local localPath="${module[MFS_RELATIVE_PATH]}"
    local is_initialized=1
    local moduleStatus=$(git submodule status -- ${subModule})

    pushd ${localPath} &> /dev/null
    module+=($(get_repo_git_dir))             # MFS_GIT_DIR=2
    module+=($(pwd))                          # MFS_FULL_PATH=3

    if [[ $5 == "/" ]]; then                  # MFS_MODULE_PATH = 4
      module+=("/$subModule")
    else
      module+=("$5/$subModule")
    fi
    if [[ ${moduleStatus:0:1} == "-" ]]; then
      is_initialized=0
    fi
    module+=(${is_initialized})

    module_startup_investigate ${module[@]}
    popd &> /dev/null
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
}


function umbrella_finalize() {
  rm -rf ${globals[$G_SCRIPT_TMP_DIRECTORY]}
  _m_finalize
}

warn() { echo "$@" >&2; }
#die() { warn "$@"; exit 1; }

function die() {
  local msg="$1"
  [ -z "${msg}" ] && "You are not in one of ConsistentWork repositories. Look in "$(dirname $0)"/Readme.MD for more information"
  cw_echo "${msg}"
  exit 1
}

function panic() {
  local msg="$1"
  [ -z "${msg}" ] && "Unexpected error. Please check the code or call to support"
  echo "panic: ${msg}"
  exit 2
}

typeset cwVerboseContinue=0

function cw_cr() {
  printf "\n" >&2

}

function cw_echo() {
  echo "${0##*/}: $1"
  if [[ -n "$2" ]]; then
    shift
    cw_verbose_start
    while [ -n "$1" ]; do
      cw_verbose "$1\n"
      shift
    done
    cw_verbose_stop
  fi
}

function cw_verbose_start () {
  cwVerboseContinue=1
}


function cw_verbose () {
  if (( $verbose )); then
    printf "verbose: $1" >&2
    (( ! $cwVerboseContinue )) && printf "\n" >&2
  fi
}

function cw_verbose_stop () {
  if (( $verbose )); then
    if (( $cwVerboseContinue )); then
      printf "\n" >&2
    fi
    cwVerboseContinue=0
  fi
}

function splash() {
  (( $skipSplash )) && return
  local url=$1
  local msg="umbrella repo: "${url}
  local currentGitDir=$(get_repo_git_dir)
  local currentRepoName=${currentGitDir##*/modules/}
  [[ -n ${currentRepoName} && ${url} != ${currentRepoName} && $currentGitDir != ".git" ]] && msg+=", current module '"${currentRepoName}"'"
  cw_echo "${msg}"
}

function get_repo_url() {
  [[ -n $1 && $1 != "." ]] && pushd $1  &> /dev/null
  local url=$(git remote get-url origin &> /dev/null)
  [[ -n $1 && $1 != "." ]] && popd  &> /dev/null
  echo ${url}
}

function get_repo_name_from_path() {
  [[ -n $1 && $1 != "." ]] && pushd $1  > /dev/null
  local gitDir=$(get_repo_git_dir)
  [[ -n $1 && $1 != "." ]] && popd  > /dev/null
  local name="${gitDir##*/modules/}"
  [[ $name == ".git" ]] && echo "/" || echo "$name"
}

function get_repo_git_dir() {
  [[ -n $1 && $1 != "." ]] && pushd $1  > /dev/null
  local url=$(git rev-parse --git-dir)
  [[ -n $1 && $1 != "." ]] && popd  > /dev/null
  echo ${url}
}

function get_module_path_up() {
  local ret=1
  local path

  if [[ $1 != "/" ]]; then
    path=${1%/*}

    (( ! ${#path} )) && path="/"
    ret=0

  fi

  (( ! $ret )) && echo "${path}"
  return ${ret}
}


function level_verbose_about_to {

  local path=$4
  local info="about to ${0##*/} module '${1}'"
  # global
  verboseMsg=([1]="path: $path")
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local fineIssues infoIssues
  verboseMsg[0]=${info}
#set +x
  cw_echo "${verboseMsg[@]}"

}


#
## Checks affected modules, which can be set after double dash
## ie. status / -- libs will check only libs module
#
# Parameters
#     $1 Module's full path to be tested on existence in afterDash array
#
# Returns
#     0 - module is found and listed in after dash parameters, or after-dash parameters are not set
#     1 - module is found but not listed in after dash parameters (out-filtered)
#     2 - N/A module is not found or wrong argument
#
# Globals using
#     $afterDash - array contains module list after double dash
#     $affected  - this variable should be defined outside of this function (output variable)
#
# TODO take into account --recursive flag
#
function drop_to_affected() {
  local levelPath=$1
  local found=0
  local ret=1

#  affected=0

  [[ -z ${levelPath} ]] && panic "$FUNCNAME() missed parameter 'path'"

  while read -a module; do
    found=0
    local moduleName=${module[$MFS_MODULE_NAME]}
    local fullPath=${module[MFS_FULL_PATH]}
    if [ "$levelPath" == "$fullPath" ]; then
      found=1
      if (( ${#afterDash[@]} )); then
        found=0
        for branch in ${afterDash[@]}; do
          # exact comparison, not matching
          if [ "${moduleName}" == "${branch}" ]; then
            found=1
            break
          fi
        done
      fi
    fi

    if (( ${found} )); then
      affected=1
      ret=0
      echo ${module[@]} >> ${globals[$G_AFFECTED_MODULES]}
      break
    fi

  done < <(cat ${globals[$G_MODULES_FN]})

  return ${ret}
}


function get_module_path_down() {
  local path
  local origin="$1"
  local reminder="$2"
  if [[ ${origin:(-1)} == "/" ]]; then
    path="$origin$reminder"
  else
    path="$origin/$reminder"
  fi

  local ret=1

  for mp in ${g_module_paths[@]}; do
    if [[ ${mp} == ${path} ]]; then
      ret=0
      break
    fi
  done

  (( ! $ret )) && echo "${path}"
  return ${ret}
}


function resolve_module_path() {
  cantResolve="Can't resolve module path '$1'"
  local originPath reminder="$1"
  local default="$2"

  if [[ -n ${reminder} ]]; then
    if [[ -n ${reminder%%/*} && -n ${reminder%%../*} && $reminder != ".." && -n ${reminder%%./*} && $reminder != "." ]]; then
      reminder="./$reminder"
    fi

    if [[ -z ${reminder%%/*} ]]; then
      originPath="/"
      reminder=${reminder:1}
    elif [[ -z ${reminder%%../*} || $reminder == ".." ]]; then
      reminder=${reminder:3}
      originPath=$(pmd)
      originPath=$(get_module_path_up ${originPath})
      (( $? )) && die "${cantResolve}"
    elif [[ -z ${reminder%%./*} || $reminder == "." ]]; then
      reminder=${reminder:2}
      originPath=$(pmd)
    fi

    if (( ${#reminder} )); then
      IFS="/" read -a parts <<< $reminder
      for part in $parts; do
        case $part in
          \.\.\.)
            die "${cantResolve}"
          ;;
          \.\.)
            originPath=$(get_module_path_up ${originPath})
            (( $? )) && die "${cantResolve}"
          ;;
          \.)
            ## nothing
          ;;
          *)
            originPath=$(get_module_path_down ${originPath} ${part})
            (( $? )) && die "${cantResolve}"
          ;;
        esac
      done
    fi
  fi

  [[ -z $originPath ]] && originPath="${default}"

  echo "${originPath}"
}

function module_info () {
  local modulePath="$1"
  shift
  local index=0
  local ret=1
  local results=()
  for mp in ${g_module_paths[@]}; do
    if [[ ${mp} = ${modulePath} ]]; then
      ret=0
      break
    fi
    index=$(( index + 1 ))
  done


  while [[ -n $1 ]]; do
    case $1 in
      index)
        results+=($index)
        ;;
      name)
        results+=(${g_module_name[$index]})
        ;;
      relative|local)
        results+=(${g_relative_paths[$index]})
        ;;
      full|path)
        results+=(${g_full_paths[$index]})
        ;;
      gitdir)
        results+=(${g_git_dirs[$index]})
        ;;
      *)
        ret=2
        break
    esac
    shift
  done

  (( ${#results[@]} )) && echo ${results[@]}
  return ${ret}
}


function is_repo_initialized() {
  local levelPath=$1
  local ret=0
  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"

  while read -a module; do
    local fullPath=${module[${MFS_FULL_PATH}]}
    if [[ ${levelPath} == ${fullPath} && ${module[${MFS_MODULE_INITIALIZED}]} == 1 ]]; then
      ret=1
      break
    fi
  done < <(cat ${globals[${G_MODULES_FN}]})

  echo ${ret};
  return ${ret}
}

function is_branch_exists() {
  [[ -z $1 ]] && (panic "'branch' argument for is_branch_exists() should be given")
  local branchName=$1
  local where=$2
  local checkedSites=("", "origin")
  if [[ -n $where ]]; then
    # TODO
    die "'where' parameter for is_branch_exists() not implemented yet"
  fi

  for prefix in "${checkedSites[@]}"; do
    (( ${#prefix} )) && prefix+="/"
    git rev-parse --no-revs "${prefix}${branchName}" &>/dev/null
    local ret=$?
    if (( ! $ret )); then
      ret=1
    else
      ret=0
    fi
    if (( $ret )); then
     break
    fi
  done

  echo ${ret}
  return ${ret}
}

typeset MODULE_STATUS=()
#
##  Get status for current module
#
#     Filling up $MODULE_STATUS array with parsed information about current module state.
#     Information in the array will be valid till next call of the method.
#     Directory of module should be set outside this function.
#
## Parameters
#     $1  - mode, which indicated the caller script, ie. "status"/"commit"/..
#     $2  - path of current module
#     ... - other parameters relevant to its caller
#       For 'status' mode
#           $3 - module is initialized (1/0)
#           $4 - stick-on-branches, branch which outer module expects inner module to be
#
## Globals affected
#     $MODULE_STATUS array
#
function module_porcelain_status() {
#module_porcelain_status status $modulePath "${initialized}" "${stickOnBranch}"
  local remoteInteraction=0 stickOnBranch guessedBranched

  [[ $1 == "push" || $1 == "pull" ]] && remoteInteraction=1

  unset MODULE_STATUS
  local modulePath="$2"
  local initialized="$3"
  local stickOnBranch="$4"

  # TODO take care about ambiguous references like master & tags/master
  test -n ${stickOnBranch} && MODULE_STATUS[$MS_INNER_REV_HINT]=${stickOnBranch}

#  set -x
  if (( ${initialized} )) || [[ ${modulePath} == / ]] ; then
    while read line; do
      # parse line into array or words
      local output=(${line})

      case ${output[0]} in
        \#\#)
          if [[ -n ${output[1]} ]]; then
            guessedBranched=$(guess_branch_from_hash HEAD $modulePath)

            if [[ ${output[1]} == "HEAD" ]]; then
              MODULE_STATUS[$MS_DETACHED]=1
            fi
            if [[ ${guessedBranched} != ${stickOnBranch} ]]; then
              MODULE_STATUS[$MS_INCONSISTENT]=1
              MODULE_STATUS[$MS_GUESSED_BRANCHES]=${guessedBranched}
            fi
            MODULE_STATUS[$MS_BRANCH_INFO]="${output[@]:1}"
          fi

          # TODO will not working in locale differs form en_US (or en_XX)
          # TODO git rev-list --count can help?
          if (( $remoteInteraction )); then
  #          local remoteRef="origin/"
            local ahead=$(echo $line | grep -Eo "ahead [[:digit:]]" | grep -Eo "[[:digit:]]")
            (( ! $? )) && (( $ahead )) && MODULE_STATUS[$MS_PUSHABLE]=1
          fi
          ;;
        *)
          local cmd=${output:0:2}
          case ${cmd} in
            \?\?)
              MODULE_STATUS[$MS_UNTRACKED]=1
            ;;
            *)
              local fChar=${cmd:0:1} sChar=${cmd:1:1}
              [[ ${fChar} == "M" || ${sChar} == "M" ]] && MODULE_STATUS[$MS_MODIFIED]=1; MODULE_STATUS[$MS_COMMITABLE]=1
              [[ ${fChar} == "A" || ${sChar} == "A" ]] && MODULE_STATUS[$MS_ADDED]=1; MODULE_STATUS[$MS_COMMITABLE]=1
              [[ ${fChar} == "D" || ${sChar} == "D" ]] && MODULE_STATUS[$MS_DELETED]=1; MODULE_STATUS[$MS_COMMITABLE]=1
              [[ ${fChar} == "R" || ${sChar} == "R" ]] && MODULE_STATUS[$MS_RENAMED]=1; MODULE_STATUS[$MS_COMMITABLE]=1
              [[ ${fChar} == "C" || ${sChar} == "C" ]] && MODULE_STATUS[$MS_COPIED]=1; MODULE_STATUS[$MS_COMMITABLE]=1
              [[ ${fChar} == "U" || ${sChar} == "U" ]] && MODULE_STATUS[$MS_UNMERGED]=1; MODULE_STATUS[$MS_COMMITABLE]=1
            ;;
          esac
        ;;
      esac
    done < <(git status -u --porcelain -b)
  elif (( ! $initialized )) ; then
    MODULE_STATUS[$MS_UNINITIALIZED]=1
  fi
#  echo "$FUNCNAME(): ${MODULE_STATUS[@]}"
}

function module_up() {
  cd $(git rev-parse --show-toplevel)"/.."
  cd $(git rev-parse --show-toplevel)
}

function possible_branch_from_parent_config() {
  local ret
  local repoName=$(get_repo_name_from_path)

  if [[ ${repoName} != / ]]; then
    pushd . &> /dev/null
    module_up
    ret=$(git config -f .gitmodules --get "submodule.$repoName.branch")
    popd &> /dev/null
  else
    ret=/
  fi
  echo ${ret}
}

function guess_branch_from_hash() {
  local ret hash=${1:-HEAD}
  local branches=()
  repoPath="$2"
  # const
  local legoRemote=origin

  if [[ ${repoPath} != / ]]; then
    while read sha commit ref; do
      refParsed=$(git rev-parse --abbrev-ref=strict ${ref})
      found=0
      for branch in ${branches[@]}; do
        if [[ "${branch}" = ${refParsed#${legoRemote}/} ]] || [[ ${refParsed%%/*} != ${legoRemote} ]] ; then
          found=1
          break
        fi
      done

      if [[ ${found} == 0 ]]; then
        branches+=("${refParsed#${legoRemote}/}")
      fi
    done < <(git for-each-ref --points-at=${hash})
  fi
  echo ${branches[@]}
}


construct_section_name() {
  local modulePath="$1"
  local extension="$2"
  local dir="${globals[$G_SCRIPT_TMP_DIRECTORY]}"
  local fn once=0

  if [[ ${#modulePath} == 0 || ${modulePath:0:1} != "/" ]]; then
    fn+="/"
  fi
  (( ${#modulePath} )) && fn+=${modulePath}

  fn=$(echo ${fn} | tr "/" "_")
  echo "$dir/${fn}.${extension}"
}

function export_gitmodules_section {
  echo ${FUNCNAME}": $@" >&2
  local modulePath="$1"
  local moduleName="$2"
  local revision="$3"
  local dumpFileName=$(construct_section_name "$1" "$3")
#  echo "${dumpFileName}"
#  pwd
  while  read -a module; do
    echo ${module[@]} >> ${dumpFileName}
  done < <(git config --file .gitmodules --get-regexp "submodule.${moduleName}.*")
#  cat "${dumpFileName}"
}

function import_gitmodules_section {
  echo ${FUNCNAME}": $@" >&2
  local modulePath="$1"
  local moduleName="$2"
  local revision="$3"
  local dumpFileName=$(construct_section_name "$1" "$3")
#  echo "${dumpFileName}"
#  pwd
  while  read -a setting; do
    git conifg --file .gitmodules ${setting[@]}
  done < <(cat "${dumpFileName}")
}


function prepare_checkout_level() {
  echo ${FUNCNAME}": $@" >&2
#  [[ -z ${levelPath} ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local levelRevision="$1"
  local modulePath="$2"
  local moduleName="$3"
  local levelPath="$4"
  local toBeDeleted=$5
  local parentCheckBranch="$6"
  local parentCheckCommit="$7"
  local parentRevision="${parentCheckBranch}"
  if [[ -z "${parentRevision}" ]]; then
    parentRevision="${parentCheckCommit}"
  fi

  local -a modulesBefore
  local -a modulesAfter
  local -a removedModules

  local ret=0 checkRevision
  local childRet # child modules return code

  pushd "${levelPath}" &> /dev/null

  if (( $toBeDeleted )); then

    module_porcelain_status checkout

    if [[ 0 == ${force} &&  (1 == ${MODULE_STATUS[$MS_COMMITABLE]} || 1 == ${MODULE_STATUS[$MS_UNTRACKED]} || 1 == ${MODULE_STATUS[MS_PUSHABLE]}) ]]; then
      dieMsg+="Module '$moduleName' has not committed or not pushed changes, but intended to be deleted as it does not exists in revision '$revision'"
      ret=1
    fi

  else
    ### Use case when in new checkout revision the submodule not exists, but in current branch it is change
    ### It should be vetoed, but this veto can be disclosed only on the next call for getting if sub-module is
    ### commitable.
    while read -a module; do
      local after="${module[0]}"
      modulesAfter+=($after)
      local branchAfter=$(git config --blob ${levelRevision}:.gitmodules --get "submodule.${after}.branch" )
      local commitAfter=$(git config --blob ${levelRevision}:.gitmodules --get "submodule.${after}.commit" )
      local revisionAfter=${branchAfter}
      if [[ -z $revisionAfter ]]; then
        revisionAfter=${commitAfter}
      fi
      revisionsAfter+=(${revisionAfter})
    done < <(git config --blob ${levelRevision}:.gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/" )

    local found=0
    while read -a module; do
      local b="${module[0]}"
      modulesBefore+=("$b")
      for a in ${modulesAfter[@]}; do
        if [[ $a == $b ]]; then
          found=1
          break
        fi
      done
      if (( ! $found )); then
        removedModules+=("${b}")
      fi
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

    drop_to_affected "${levelPath}"

    found=0
    while read -a module; do
      local after="${module[0]}"
      found=0
      for b in ${modulesBefore[@]}; do
        if [[ $after == $b ]]; then
          found=1
          break
        fi
      done
      if (( ! $found )); then
#        drop_to_affected "${levelPath}/${module[1]}"
        local localPath="${module[1]}"
        local childModulePath="${modulePath}"
        if [[ ${modulePath:(-1)} != "/" ]]; then
          local childModulePath+="/"
        fi
        childModulePath+="$after"
        ## dummy git dir
        echo "${after}" "${localPath}" "^" "${levelPath}/${localPath}" "$childModulePath" >> ${globals[$G_AFFECTED_MODULES]}
        affected=1
      fi
    done < <(git config --blob ${levelRevision}:.gitmodules --get-regexp "submodule.*.path" 2> /dev/null | sed -E "s/submodule\.(.*)\.path/\1/" )


    if [ -f .gitmodules ]; then
      while read -a module; do
        childRet=0
        subModule="${module[0]}"
        localPath="${module[1]}"
        local path="${levelPath}"/"${localPath}"

  #      checkoutd "${path}" &> /dev/null
        local childModulePath="${modulePath}"
        if [[ ${modulePath:(-1)} != "/" ]]; then
          local childModulePath+="/"
        fi
        childModulePath+="$subModule"

        local childToBeDeleted=0
        for b in ${removedModules[@]}; do
          if [[ $subModule == $b ]]; then
            childToBeDeleted=1
            break
          fi
        done

        if (( ! childToBeDeleted )); then
          local checkBranch=$(git config --blob "${levelRevision}":.gitmodules --get submodule."${subModule}".branch) 2> /dev/null
          local checkCommit=$(git config --blob "${levelRevision}":.gitmodules --get submodule."${subModule}".commit) 2> /dev/null
          checkRevision="${checkBranch}"
          if [[ -z $checkRevision ]]; then
            checkRevision="${checkCommit}"
          fi
        else
          checkRevision="^"
          # dump .gitmodules section in the separate temp file, (merge preparation)
#          export_gitmodules_section "${path}" "${subModule}" "${checkRevision}"
        fi

        prepare_checkout_level "${checkRevision}" "${childModulePath}" "${subModule}" "${path}" "${childToBeDeleted}" "${checkBranch}" "${checkCommit}"
        childRet=$?

        (( $childRet > $ret )) && ret=${childRet}
        popd  &> /dev/null

      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi
  fi

  popd &> /dev/null
  return ${ret}
} ## of prepare_checkout_level

##
## Checks branching state for current repository
## Let name the branch is synchronized if entry submodule.<module-name>.branch in .gitmodules is matched
## to the branch of the sub-repository, (what can be checked via 'cd module-path; git branch',
##
## It they are mismatched, 3 options are possible.
##
## 1. Sub-repo can be detached. In this case we are looking for value in the outer repo and doing git checkout branch
## 2. Sub-repo is pinned to another branch that is given in .gitmodules. To sync this we just changing value in .gitmodules file of outer repo
## 3. Sub-repo is detached, no value in .gitmodules. We are unable to re-syncronize, notify user about and exit.
## Parameters:
##      $1 path [required] - path getting started checking.
##      $2 doSync [optional, by default 0] - do synchronization (case 1) or not
##
## The function calls itself recursively to drill down to any leave repos.
##
## Returns
##
function check_branch_sync() {
  local levelPath="$1"
  local doSync=${2:-0}

  [[ -z ${levelPath} ]] && panic "check_branch_sync()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is synchronized
  local childRet # child return code
  cd "${levelPath}"

  while read -a repo; do
    childRet=0
    subRepoName="${repo[0]}"
    checkBranch=$(git config --file .gitmodules --get submodule."${subRepoName}".branch)
    checkPath="${repo[1]}"
    subRepoPath="${levelPath}"/"${checkPath}"

    #    echo "${subRepoName}" "${checkBranch}" "${checkPath}"

    pushd "${subRepoPath}" &> /dev/null
    #    pwd

    repoBranch=$(git rev-parse --abbrev-ref HEAD)
    local detached=0
    [[ "${repoBranch}" == "HEAD" ]] && detached=1

    #    echo "${repoBranch}"
    if [[ ${repoBranch} != ${checkBranch} ]]; then

      ret=1
      (( ! $doSync )) && cw_echo "Module ${subRepoName} is not synchronized"
      #      echo "$repoBranch != $checkBranch"

      #
      if [[ -n "${repoBranch}" && ${detached} == 0  ]]; then
        cd "${levelPath}"
        if (( $doSync )); then
          cw_echo "About to change reference in .gitmodules for submodule $subRepoName to branch $repoBranch"
          git config --file .gitmodules submodule."${subRepoName}".branch "${repoBranch}"
          ret=$?
        fi
      elif [[ -n "${checkBranch}" && ${detached} == 1 ]]; then
        cd "${subRepoPath}"
        if (( $doSync )); then
          cw_echo "About to checkout submodule $subRepoName to branch $checkBranch"
          git checkout ${checkBranch}
          ret=$?
        fi
      else
        cw_echo "Warning: submodule ${subRepoName} can't be synchronized"
        ret=2
      fi
    else
      (( $doView )) && cw_echo "Module '$subRepoName' at '$checkBranch' branch"
    fi

    if [[ -e .gitmodules ]]; then
      check_branch_sync "${subRepoPath}" ${doSync}
      childRet=$?
    fi
    (( $childRet )) && ret=1


    popd  &> /dev/null

    if (( $doSync )); then
      git diff --exit-code --quiet -- .gitmodules
      needToCommit=$?
      #echo "needToCommit=${needToCommit}"
      if (( $needToCommit)); then
        if (( $doAutoCommit )); then
          git add .gitmodules
          git commit -m "$subRepoName submodule configuration is changed"
        else
          needMessageToPush=1
        fi
      fi
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return "${ret}"
} ## of check_branch_sync



  ######################################################################################################################
  #################################################   MLS  #############################################################
  ######################################################################################################################



function _m_finalize() {
  unset strict
  unset verbose
  unset recursive
#  set +x
}

function _m_mls() {
  local ret=0
#  set -x
  while read -a module; do
    subModule="${module[0]}"
    localPath="${module[1]}"
    pushd "$localPath" &> /dev/null
    _m_pmd

    if (( $recursive )); then
      _m_mls && ret=1
    fi

    popd &> /dev/null
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
#  set +x
  return ${ret}
}

function _m_not_git_repository() {
  git rev-parse --git-dir &> /dev/null
  if (( $? )); then
    _m_die "Not a git repository"
    return 1
  fi
  return 0
}


function _m_pmd() {
  local gitDir=$(_m_git_dir)
  gitDir=${gitDir##*.git/}
  local path
  IFS="/" read -a names <<< ${gitDir}

  for name in ${names[@]}; do
    if [ ${name} != "modules" -a $name != ".git" ]; then
      path+=/"$name"
    fi
  done

  [[ -z $path ]] && path="/"
  echo  "${path}"
}


function _m_die() {
  echo $1 >&2
  _m_finalize
}


function _m_path_resolution() {
  local originPath reminder="$1"
  if [[ ${reminder} != "." && -n ${reminder} ]]; then
    local strict=$2

    if [[ -n ${reminder} ]]; then

      if [[ -z ${reminder%%/*} ]]; then
        _m_root 1; (( $? )) && return 1
        reminder=${reminder:1}
      elif [[ -z ${reminder%%../*} || $reminder == ".." ]]; then
        reminder=${reminder:3}
        _m_pwd 1
        _m_up 1; (( $? )) && return 1
      elif [[ -z ${reminder%%./*} || $reminder == "." ]]; then
        reminder=${reminder:2}
        _m_pwd 1
      fi

      if (( ${#reminder} )); then
        IFS="/" read -a parts <<< $reminder
        for part in $parts; do
          case $part in
            \.\.)
              _m_up 1; (( $? )) && return 1
            ;;
            \.)
              ## nothing
            ;;
            *)
              _m_down ${part} 1 $strict; (( $? )) && return 1
            ;;
          esac
        done
      fi
    fi
  else
    _m_pwd 1
  fi

  pwd
}


function _m_up() {
  local doCd=$1

  if [[ "$doCd" == 1 ]]; then
    if [[ $(_m_git_dir) == ".git" ]]; then
      echo "Can't up at the root module" >&2
      return 1
    else
      _m_pwd 1
      cd ..
      _m_pwd 1
    fi
  else
    # TODO
    echo "mode '$FUNCNAME $1' not yet implemented" >&2
    return 1
  fi
}



function _m_down() {
  local path="$1"
  local doCd="$2"
  local ret=1
  local strict="$3"

  if [[ -n $strict ]]; then
    path=${strict}${path}
  fi

  while read -a module; do
    subModule="${module[0]}"
    localPath="${module[1]}"
    echo "$subModule" | grep "${path}" &> /dev/null
    local existsReverted=$?
    if (( ! $existsReverted )); then
      ret=0
      if (( $doCd )); then
        cd "$localPath"
      else
        echo $(_m_pwd)/"${localPath}"
      fi
      break
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return ${ret}
}


  #
  ## Print module directory
  ## just like Unix pwd, but for modules hierarchy
  #
function _m_pwd() {
  local path=$(git rev-parse --show-toplevel)
  local doCd="$1"
  if (( "$doCd" )); then
    cd "${path}"
  else
    echo "${path}"
  fi
}

function _m_git_dir() {
  local url=$(git rev-parse --git-dir)
  echo ${url}
}

function _m_root() {
  local doCd="$1"
  local gitDir=$(_m_git_dir)
  local rootGitDir=${gitDir##*/}
  local root

  if [[ ${rootGitDir} == ".git" ]]; then
    root=$(git rev-parse --show-toplevel)
  else
    root="${gitDir%%/.git/*}"  > /dev/null
  fi

  if (( "$doCd" )); then
    cd "${root}"
  else
    echo "${root}"
  fi
}

#
# Boolean treated as it does in Java/javascript where true == 1|false == 0,
# opposed to bash world, where true == 0|false=1
# Sorry for inconvenience ;)
#
READ_boolean() {
  local input=${1:-0};
  local default=${2}

  case "${input}" in
    true|t|1)
      input=1;
    ;;
    false|f|0)
      input=0
    ;;
    *) warn "wrong format for boolean value, defaulting to 0" ;;
  esac
  echo ${input}
}

#
# Print a submodule configuration setting
#
# $1 = submodule name
# $2 = option name
# $3 = default value
#
# Checks in the usual git-config places first (for overrides),
# otherwise it falls back on .gitmodules.  This allows you to
# distribute project-wide defaults in .gitmodules, while still
# customizing individual repositories if necessary.  If the option is
# not in .gitmodules either, print a default value.
#
get_submodule_config () {
	name="$1"
	option="$2"
	default="$3"
	value=$(git config submodule."$name"."$option")
	if test -z "$value"
	then
		value=$(git config -f .gitmodules submodule."$name"."$option")
	fi
	printf '%s' "${value:-$default}"
}


  ######################################################################################################################
  ############################################  MAIN SCRIPT  ###########################################################
  ######################################################################################################################


# The sed expression here replaces all backslashes by forward slashes.
# This helps our Windows users, while not bothering our Unix users.
export GITLEGO_DIR=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")

usage() {

  cat << EOF

    Git extension to ease work with intensive using of git submodules

    working dir: ${GITLEGO_DIR}
    usage: git lego <subcommand>

    Try 'git lego <subcommand> help' for details
EOF
}



#set -x

main() {
	if [ $# -lt 1 ]; then
		usage
		exit 1
	fi

	# load common functionality
#	. "$GITLEGO_DIR/gitlego-common"

	# This environmental variable fixes non-POSIX getopt style argument
	# parsing, effectively breaking git-lego subcommand parsing on several
	# Linux platforms.
	export POSIXLY_CORRECT=1

	# sanity checks
	local SUBCOMMAND="$1"; shift

	if [ ! -e "$GITLEGO_DIR/git-lego-$SUBCOMMAND" ]; then
		usage
		exit 1
	fi

  FLAGS_PREFIX="'${0##*/} $SUBCOMMAND'"
	# run command
	. "$GITLEGO_DIR/git-lego-$SUBCOMMAND"


	SUBACTION="default"

	# Particular script can figure out a specific action depends on arguments or other circumstances.
	# In this case it should define cmd_sub_action function and echo'ing required action.
	# If cmd_sub_action returns empty string - default is using
	if type "cmd_sub_action" >/dev/null 2>&1; then
		local customized=$(cmd_sub_action "$@")
		if [[ -n $customized ]]; then
		  SUBACTION=$(customized)
		fi
	fi

	if ! type "cmd_$SUBACTION" >/dev/null 2>&1; then
		warn "Unknown subcommand: '$SUBACTION'"
		usage
		exit 1
	fi

  cmd_$SUBACTION "$@"
}


main "$@"
