#!/usr/bin/env bash

  # After call to 'umbrella_bootstrap' this array contains following predefined values.
  #
  ## "${globals[$G_ROOT_DIR]}" [cwRoot]             - file system path to root repository
  ## "${globals[$G_MODULES_FN]}" [cwTmpSubmodules]  - temporary file name, which listed all current repositories
  #                                                   with additional information
  ## "${globals[$G_MODULE_GIT_DIR]}" [gitDir]       - current repository
  #

##############################
#
# FOUND DEBUG OUTPUT TO STDERR
# Occurrences of '^ *(cat|echo).[\w\"\$\{\}\[\]\@\#\*\/\\\:\.\d \'\(\)]*>&2' in Project
#
##############################
EMPTY_TREE_HASH=$(git hash-object -t tree /dev/null)
## Global arrays for quick access of frequently used parameters
## There are basically a cache
g_module_name=()
g_relative_paths=()
g_git_dirs=()
g_full_paths=()
g_module_paths=()
g_module_inited=()
g_module_shas=()
g_module_managed=()
g_managed_refnames=()
g_module_lego_modes=()
g_module_lego_modes_implicit=()
g_checkout_refnames=()
#
# At the beginning there is a logic to investigate possible initial path of command
# For most of the git-lego commands initial path by default is current module - '.'
# But in command it can be explicit given, ie. 'git checkout master macosx' - both 'master' and 'macosx'
# are potential initial paths. Rough resolving whether the potential path is real one is done in umbrella_bootstrap.
#
#g_potential_init_paths=()

declare -a G_MANAGED_TOKENS=("refname")
declare -a G_REFTYPE_TOKENS=("branch" "pinned" "sha")

declare -a G_LEGO_MODES=("solo" "versioned")
G_MODE_MASK_SOLO="0x1"
G_MODE_MASK_VERSIONED="0x2"

declare NA="n/a"


typeset g_lego_mode



# keeps some global settings during git-lego script execution
# initialized at startup
globals=()
  ################################## CONSTANTS FOR globals array ##########################################
  #
  ## Root repo path
  #
G_ROOT_DIR=0
  #
  ## reference to git directory for current submodule.
  #
G_MODULE_GIT_DIR=1
  #
  ## Human-readable name of root repository path
  #
G_ROOT_NAME=2
  #
  ## Temporary folder owned by script invocation
G_SCRIPT_TMP_DIRECTORY=3
  #
  ## Reference to temporary file which keeps all submodules' path in reversed order
  ##  It is useful to apply regular actions against all modules, like bulk commit,push,etc
  #
G_MODULES_FN=4
  #
  ## Reference to temporary file which keeps modules' paths, which are effectively affected by
  # applying bulk operations such pull, commit, etc
  # They are in 'absolute' module structure form like /, or /macosx/docs
  #
G_AFFECTED_MODULES=5

  # Remote reference used in git-lego. By default, of course, 'origin'
G_LEGO_REMOTE=6

  # if root repository is headed (checked out to branch) it contains branch name, otherwise hash of the current HEAD
G_ROOT_REF=7

  # Reference type of module where git-lego starts. Ie.
G_ROOT_DETACHED=8

G_LEGO_MODE=9
G_LEGO_MODE_IMPLICIT=10
  # mac or win bash or linux...
G_PLATFORM=11
  # optimization for path conversion Win <-> (*)nux
G_WIN_PATH_PREFIX=12

#################### CONSTANTS for MODULE STATUS (see function module_porcelain_status() ####################
#
MS_BRANCH_INFO=0   # String
MS_UNTRACKED=1     # N
MS_MODIFIED=2      # M
MS_MODIFIED_SUBMODULE=28 #S
MS_DELETED=3       # D
MS_ADDED=4         # A
MS_RENAMED=5       # R
MS_COPIED=6        # C
MS_UNMERGED=7      # U
MS_PUSHABLE=8      # 1/0
MS_PULLABLE=9      # 1/0
MS_COMMITABLE=10   # 1/0
MS_SUBMODULES=11   # S
#
# After clone/update submodules always are in the *detached* state. That means, no symbolic reference points to inner module's HEAD.
# At the same time, outer module can have (or not) is't own expectation, which inner module should have, branch or tag.
# If outer module specifies the hint, *managed link*, branch or tag or just sha1 for inner module, let we say the inner module is "managed".
# Otherwise the inner module is *unmanaged* by outer module.
#
# If module is managed, but points to other sha1, than expected, the module's state is *mismatched*.
# Git-lego warns, if inner module is unmanaged or mismatched, and enumerates, to which symbolic links the inner module can be *attained*.
#
# Attain process means change hint in the scope of outer module, so that inner can match to the inner module state. Worktree of inner module is not changed,
# but worktree of outer module can be changed, if git-lego mode is *versioned*. If git-lego mode is set to *solo*, no worktree changes happens as well.
#
# Git-lego has an *auto-attain* setting, in which allow it can attains unmanaged or mismatched modules if no ambiguous symbolic links the inner module has.
#
# In case of mismatched state, there are possible either "attain" inner to outer, or update inner module to the state, referenced in outer hint.
# There are situation though, if outer hint is stale, and inner branch has no such ref. Let say the inner module is not *updateable*
# In this case only attaining will be advised
#
# Module is not initialized yet or git submodule deinit was applied
MS_UNINITIALIZED=14   # 1/0
#
# Unmanaged mean, git-lego has no idea what inner module should be stick on.
MS_UNMANAGED=15       # 1 - inner module is unmanaged, 0 - managed
#
# In case the module is managed
# 0 - inner module not detached (attached to any refs/heads/branch), 1 is detached to tag, 2 is detached to bare sha1
MS_DETACHED=16
MS_DETACHED_FROM=33

#
# Hint of outer
# 0 - managed with a branch head, 1 - pinned to tag, 2 - pinned to bare sha1
MS_MANAGED_REFTYPE=17
#
# Outer module hint for inner one, symbolic reference (tag or branch) or just bare sha1, the inner module expected to be.
MS_MANAGED_REFNAME=18

MS_CHECKOUT_REFTYPE=29
MS_CHECKOUT_REFNAME=30
#
# 0 - Inner module both outer hint and inner state are matched (branch -> branch or tag -> tag), but references are different
# ie, hint is branch develop, but inner state is master. In this case either git-lego update or git-lego attain are required
#
MS_MISMATCHED=19
#
# In case the module has managed, but mismatched state, whether or not it is updateable, to be syncronized with outer hint.
# Does not matter as branch or tag or ever sha1 situation.
MS_UPDATEABLE=20
#
# One or more branches referencing on the inner:HEAD, which can be synchronized to the branch after attaining without getting outer repo dirty
# strings' array
MS_GUESSED_BRANCHES=22

# One or more tags referencing to the inner module:HEAD, which can be synchronized with outer hint without making outer submodule reference dirty
# strings' array
MS_GUESSED_TAGS=23
#
# Modules symbolic name, or sha, if module HEAD is detached.
# For getting this info the 'git status --long' command is used. git status takes this information from git reflog,
# then this is not 100% reliable. For example in some cases it can show wrong last 'git tag'
MS_MODULE_REFNAME=24

# Module's upstream branch
MS_UPSTREAM=25

# How many revisions ahead & behind to the module's upstream
MS_UPSTREAM_AHEAD=26
MS_UPSTREAM_BEHIND=27

#Managed reference missed in the repository
MS_UNREACHABLE=31

# module's HEAD points to head-less commit and potentially can be later removed by garbage collector
MS_DANGLED=32


###############
# LAST MS_=33 #
###############


########################### CONSTANTS FOR MODULE FILE SYSTEM  ###############################################
## Array is filled up in function umbrella_bootstrap () and serves for path resolution
#
MFS_MODULE_NAME=0
MFS_RELATIVE_PATH=1
MFS_GIT_DIR=2
MFS_FULL_PATH=3
MFS_MODULE_PATH=4
MFS_MODULE_INITIALIZED=5
MFS_MODULE_SHA=6
MFS_MODULE_MANAGED=7
MFS_MANAGED_REFNAME=8
MFS_LEGO_MODE=9 
MFS_LEGO_MODE_IMPLICIT=10
MFS_CHECKOUT_REFNAME=11

# set this to workaround expr problems in shFlags on freebsd
#if uname -s | egrep -iq 'bsd'; then export EXPR_COMPAT=1; fi


typeset skipSplash=1

# warning text if command's commit/tag message is empty
typeset emptyMsgNotAllowed="Empty message not allowed"

typeset G_WIN_PREFIX
declare unameParts=$( uname -s )
declare platform
case $unameParts in
  MINGW*)
    platform="W"
    declare -l topLevel=$( git rev-parse --show-toplevel | grep -o -E "^[A-Z]:" )
    if [[ -z "$topLevel" ]]; then
      G_WIN_PREFIX="/"
    else
      G_WIN_PREFIX="/${topLevel:0:1}"
    fi
    show_toplevel() {
      local ret=0
      local result=$( git rev-parse --show-toplevel )
      ret=$?
      if (( ! "$ret" )); then
        result=$( echo "$result" | sed -e 's,\\,/,g');
        ret=$?
      fi
      (( ! "$ret" )) && echo "${G_WIN_PREFIX}${result:2}"
      return "$ret"
    }
    git_dir() {
      local ret=0 exists
      local result=$( git rev-parse --git-dir ); ret=$?
      if (( ! "$ret" )); then
        exists=$( echo "$result" | grep -o -E "^[A-Z]:" )
      fi
      if (( ! "$ret" )) && [[ -n "$exists" ]]; then
        result=$( echo "$result" | sed -e 's,\\,/,g' )
        ret=$?
        (( ! "$ret" )) && echo "${G_WIN_PREFIX}${result:2}"
      else
        echo "$result"
      fi
      return "$ret"
    }
    ;;
  *)
#  Darwin*)
    show_toplevel() {
      local ret=0
      local result=$( git rev-parse --show-toplevel 2>/dev/null )
      ret=$?
      echo "$result"
      return "$ret"
    }
    git_dir() {
      local ret=0
      local result=$( git rev-parse --git-dir 2>/dev/null )
      ret=$?
      echo "$result"
      return "$ret"
    }
    platform="M"
    ;;
esac

globals["$G_PLATFORM"]=platform


# means whether the command is looking for --[no]-pinned command parameter and/or relevant setting
# Ie. git pull by default skips fetching from pinned repositories
# 0 means --pinned parameter not relevant to the command. If so, adding --pinned to command paramter causes a warning (or error?)
typeset pinnedPolicy=1

# if pinnedPolicy set to 1, defines pinned value, if parameter not given
# 1 means command scope will include pinned repositories
# NOTE that pinnedPolicy=0 means that command is been acting without any consideration about pinned or not pinned attribute
# NOTE2: this is a hard coded default value per command, if no value in the git config is set
typeset pinnedDefault=0


# TODO add git-lego setting? pro command ?
typeset pinnedSetting=0

# Effective value of whether or not --[no-]pinned app-wide setting acts.
# Most priority affected on this value, low to high
#       1. pinnedDefault, if given in the script code
#       2. pinnedSetting, if given per module/per command, because it will be retrieve from git config machinery of the current module
#       3. parameter, if given in the command line
#
typeset pinnedFinal

# parameter --[no-]pinned as it set in command line
# If the parameter --[no-]pinned not given as parameter variable $pinnedParam will be  unset.
# Use [[ ${pinnedParam:-unset} == "unset" ]] if you need to detect this state
typeset pinnedParam


umbrella_bootstrap() {
#echo "$FUNCNAME() $@" >&2
  local legoRemote=$(get_lego_setting "remote")
  local gitDir
  local umbrellaRepoDir
  local tmpDir=$(mktemp -q -d -t "$(basename "$0")" 2>/dev/null || mktemp -q -d)
  globals[$G_SCRIPT_TMP_DIRECTORY]=${tmpDir}
  globals[$G_LEGO_REMOTE]=${legoRemote:-origin}
  legoRemote="${globals[$G_LEGO_REMOTE]}"

  _m_not_git_repository; (( $? )) && exit 1

  gitDir=$(git_dir)
  normalizedGitDir=${gitDir##*/}
  if [[ ${normalizedGitDir} == ".git" ]]; then
    umbrellaRepoDir=$(show_toplevel)
  else
    pushd "${gitDir%%/.git/*}"  &>/dev/null
    umbrellaRepoDir=$(show_toplevel)
    popd  &>/dev/null
  fi

#  rm ${cwTmpSubmodules} &>/dev/null
  pushd "$umbrellaRepoDir" &>/dev/null


#  local remoteOrigin=$(git remote show)
  local umbrellaOriginUrl umbrellaRepoName
#  if [[ -n ${legoRemote} ]]; then
#    local url=$(get_repo_url "$umbrellaRepoDir")
#
#    umbrellaOriginUrl=$(git remote get-url "${legoRemote}")
#    umbrellaRepoName=${umbrellaOriginUrl##*:}
#    umbrellaRepoName=${umbrellaRepoName##*/}
#
#  else
#    umbrellaOriginUrl=$(pwd)
#    umbrellaRepoName=${umbrellaOriginUrl##*/}
#  fi

  umbrellaOriginUrl=$(pwd)
  umbrellaRepoName=${umbrellaOriginUrl##*/}

  globals[$G_AFFECTED_MODULES]=${tmpDir}/affected
  globals[$G_MODULES_FN]=${tmpDir}/modules

  #globals is an array defined in the caller of this method
  globals[$G_ROOT_DIR]=${umbrellaRepoDir}
  globals[$G_MODULE_GIT_DIR]=${gitDir}
  globals[$G_ROOT_NAME]=${umbrellaRepoName}
  local sha=$( git rev-parse HEAD )

  ##
  local implicit
  read g_lego_mode implicit < <( get_lego_mode 1 "${globals[$G_ROOT_DIR]}" )
  globals[$G_LEGO_MODE]="$g_lego_mode"
  globals[$G_LEGO_MODE_IMPLICIT]="$implicit"
#  echo $g_lego_mode ${implicit:-2}


  module_startup_investigate "${umbrellaRepoName}" "/" ".git" "${umbrellaRepoDir}" "/" 1 "${sha}" 1 "$NA" "$g_lego_mode" "$implicit" "-"

#  cat ${globals[$G_MODULES_FN]} >&2
  popd &>/dev/null

  skipSplash=0
  return 0
}


recreate_modules_cache() {
#echo "$FUNCNAME() $@" >&2
  local modulePaths=("$@")
  local tmpDir="${globals[$G_SCRIPT_TMP_DIRECTORY]}"
  local originalModules="${globals[$G_MODULES_FN]}"
  local backup="$tmpDir/modules.bak"
  local newCache="$tmpDir/modules.new"

  local index=0
  while read -a module; do
    found=0
    local modulePath=${module[$MFS_MODULE_PATH]}
    
    for changedPath in "${modulePaths[@]}"; do
      if [[ "$changedPath" == "$modulePath" ]]; then
        found=1
        break
      fi
    done
    
    if (( $found )); then
      local l_module_name="${g_module_name[$index]}"
      local l_relative_paths="${g_relative_paths[$index]}"
      local l_git_dirs="${g_git_dirs[$index]}"
      local l_full_paths="${g_full_paths[$index]}"
      local l_module_paths="${g_module_paths[$index]}"
      local l_module_inited="${g_module_inited[$index]}"
      local l_module_shas="${g_module_shas[$index]}"
      local l_module_managed="${g_module_managed[$index]}"
      local l_managed_refnames="${g_managed_refnames[$index]}"
      local l_module_lego_modes="${g_module_lego_modes[$index]}"
      local l_module_lego_modes_implicit="${g_module_lego_modes_implicit[$index]}"
      local l_checkout_refnames="${g_checkout_refnames[$index]}"

      echo "$l_module_name" "$l_relative_paths" "$l_git_dirs" "$l_full_paths" "$l_module_paths" "$l_module_inited" "$l_module_shas" \
        "$l_module_managed" "$l_managed_refnames" "$l_module_lego_modes" "$l_module_lego_modes_implicit" "$l_checkout_refnames" >>$newCache
    else
      echo "${module[@]}">>$newCache
    fi

    index=$(( $index + 1 ))
  done < <(cat $originalModules)

  mv $originalModules $backup
  mv $newCache $originalModules
}

cache_module_descriptor() {
#echo "$FUNCNAME() $@" >&2
  local tmpModules=${globals[$G_MODULES_FN]}
  echo "$@">>${tmpModules}
  # keep all module descriptors' values in the global arrays for cached access
  # basically they will be used in 'module_info' method
  g_module_name+=("$1")
  g_relative_paths+=("$2")
  g_git_dirs+=("$3")
  g_full_paths+=("$4")
  g_module_paths+=("$5")
  g_module_inited+=("$6")
  g_module_shas+=("$7")
  g_module_managed+=("$8")
  g_managed_refnames+=("${9}")
  g_module_lego_modes+=("${10}")
  g_module_lego_modes_implicit+=("${11}")
  g_checkout_refnames+=("${12}")
}

function module_startup_investigate() {
#echo "$FUNCNAME() $@" >&2; pwd >&2
  local moduleName="$1"
  local modulePath="$5"
  local legoMode="${10}"
  local modeImplicit="${11}"
  local ret=0

  cache_module_descriptor $@

  local module=()

  while read -a module
  do
    local subModule="${module[$MFS_MODULE_NAME]}"       #0
    local localPath="${module[MFS_RELATIVE_PATH]}"      #1
    local subModulePath="$modulePath"
    [[ ${subModulePath:(-1)} != "/" ]] && subModulePath+="/"
    subModulePath+="$subModule"

    investigate_module "$subModule" "$localPath" "$subModulePath" "$legoMode" "$modeImplicit"

    pushd "$localPath" &>/dev/null
    ret=$?
    if (( ! "$ret" )); then
      module_startup_investigate "${module[@]}"
    fi
    popd &>/dev/null

  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return "$ret"
}


#
# EXTERNAL: module :: array(2), prepared with moduleName & localPath
#
investigate_module() {
#echo "$FUNCNAME() $@" >&2
  local moduleName="$1"
  local localPath="$2"
  local modulePath="$3"
  local parentLegoMode="$4"
  local parentModeImplicit="$5"

  local isInitialized=1
  local managed=($( resolve_module_managed "$moduleName" "$localPath" "$parentLegoMode" "$parentModeImplicit"))

  local moduleStatus=($(git submodule status -- "$localPath"))

  pushd "$localPath" &>/dev/null

  module+=($(get_repo_git_dir))             # MFS_GIT_DIR=2
  module+=($(pwd))                          # MFS_FULL_PATH=3

  module+=("$modulePath")                   # MFS_MODULE_PATH=4

  if [[ "${moduleStatus:0:1}" == "-" ]]; then
    isInitialized=0
  fi
  module+=("$isInitialized")                # MFS_MODULE_INITIALIZED=5
  local statusLine=("$moduleStatus")
  local sha="${statusLine[0]}"
  if [[ "${sha:0:1}" == "-" || "${sha:0:1}" == "+" ]]; then
    sha="${sha:1}"
  fi
  module+=("$sha")                          # MFS_MODULE_SHA 6
  module+=("${managed[0]}")                 # MFS_MODULE_MANAGED 7
  module+=("${managed[1]}")                 # MFS_MANAGED_REFNAME 8
  read moduleLegoMode implicit < <( get_lego_mode 1 "${module[$MFS_FULL_PATH]}" )
  module+=("$moduleLegoMode")               # MFS_LEGO_MODE 9
  module+=("$implicit")                     # MFS_LEGO_MODE_IMPLICIT 10
  # by default not set
  module+=("-")                             # MFS_CHECKOUT_REFNAME 11

  popd &>/dev/null
}


function umbrella_finalize() {
  rm -rf ${globals[$G_SCRIPT_TMP_DIRECTORY]}
  _m_finalize
}


warn() { echo "$@" >&2; }

die_not_implemented_yet() {
  die "feature '--$1' not implemented yet"
}

die_missed_param_value() {
  die "missed value for $1"
}

die_parameter_duplicated() {
  die "parameter $1 duplicated"
}

die_cant_resolve_module() {
  local path="$1"
  local quiet="${2:-0}"
  local ret=0
  cantResolve="Can't resolve module path '$1'"
  if (( ! "$quiet" )); then
    die "$cantResolve"
  else
    ret=1
  fi
  return "$ret"
}


die_usage() {
  local SUBCOMMAND="$1"
  local msg="$2"

  if [[ "$msg" ]]; then
    cw_echo "$msg" >&2
  fi

  if type ${SUBCOMMAND}_usage >/dev/null 2>&1; then
    ${SUBCOMMAND}_usage
  fi

  die "false"
}


function die() {
  local msg="$1"
  if [[ -z "$msg" ]] ; then
    msg="Something goes wrong."
  fi

  if [[ "$msg" != "false" ]]; then
    cw_echo "$msg" >&2
  fi
  exit 1
}


function see_help() {
  local msg=$1
  if [[ -n "$msg" ]]; then
    msg+=" Type '$FLAGS_PREFIX --help' for more information"
  fi

  die "$msg"
}


function panic() {
  local msg="$1"
  [ -z "${msg}" ] && "Unexpected error. Please check the code or file bug to the forum/github/etc"
  echo "panic: ${msg}"
  exit 2
}

typeset cwVerboseContinue=0

function cw_cr() {
  printf "\n" >&2

}


function cw_echo() {
  echo "${0##*/}: $1"
  if [[ -n "$2" ]]; then
    shift
    cw_verbose_start
    while [ -n "$1" ]; do
      cw_verbose "$1\n"
      shift
    done
    cw_verbose_stop
  fi
}


function cw_verbose_start () {
  cwVerboseContinue=1
}


function cw_verbose () {
  if (( $verbose )); then
    printf "verbose: $1" >&2
    (( ! $cwVerboseContinue )) && printf "\n" >&2
  fi
}


function cw_verbose_stop () {
  if (( $verbose )); then
    if (( $cwVerboseContinue )); then
      printf "\n" >&2
    fi
    cwVerboseContinue=0
  fi
}

#
# Print out to console message line of format
#      git-lego: Not affected modules: abc, def, ... + 5 other(s)
# External arrays:
#
#   affectedModules,  skippedModules
##
cw_show_affected_skipped() {
  local affectedCount="${#affectedModules[@]}"

  if (( ! $affectedCount )); then
    affectedCount=$(( $(cat ${globals[$G_AFFECTED_MODULES]} | wc -l ) ))
  fi

  echo "affectedCount: $affectedCount"

  if (( ! $affectedCount )); then
    cw_echo "No modules was affected"
  elif (( "${#skippedModules[@]}" )); then
    local modulesCount="${#skippedModules[@]}"
    local msgSkipped="Not affected modules: "
    local maxShownModules=5

    if (( $modulesCount > $maxShownModules )); then
      local rest=$(( $modulesCount - $maxShownModules ))
      msgSkipped+="${skippedModules[@]:0:$maxShownModules} and $rest others..."
    else
      msgSkipped+="${skippedModules[*]}"
    fi

    cw_echo "$msgSkipped"
  fi
}


function splash() {
  (( "$skipSplash" )) && return

  local modulePath="$1"
  local projectName="${globals[$G_ROOT_NAME]}"
  read moduleName legoMode implicit gitDir < <( module_info "$modulePath" "name" "lego_mode" "lego_mode_implicit" "git_dir" )

  local msg="project: $projectName"

  if [[ "$modulePath" != "/" && -n "$moduleName" ]]; then
    msg+=", current module '$moduleName'"
  fi

  if [[ "$legoMode" == "empty" ]]; then
    legoMode='none'
  fi
  local msg+=", lego mode: $legoMode"
  if (( "$implicit" )) &&  [[ "$legoMode" != "none" ]] && [[ "$legoMode" != "detached" ]]; then
     msg+=" (guessed)"
  fi

  cw_echo "${msg}"
}


detached_names_type() {
  local moduleHash="$1"

  local ret=0
  local tag
  local results=()
  local typeIndex=0 # tag, 2 - sha
  local detachedFrom=0
  local fromCommit
  local hashLength

  ## git status --porcelain does not shows get tag version
  ## so we need to use 'old good' git status --long for that
  while read -a output; do
    # find out tag or has
    # format HEAD detached at 23a34b or HEAD detached at refs/heads/master
    local parsedLength="${#output[@]}"
    tag="${output[$parsedLength-1]}"

    if [[ "${output[$parsedLength-2]}" == "from" ]]; then
      hashLength="${#tag}"
      typeIndex=2
      detachedFrom=1
      fromCommit="$tag"
      unset tag
    fi
  done < <(git status --long -uno | grep -E "HEAD detached (at|from)")

  if [[ -n "$moduleHash" && "$detachedFrom" == 1 ]]; then
    tag=$( git rev-parse --short "$moduleHash" )
  else
    git rev-parse --no-revs "tags/$tag" &>/dev/null
    local isTag=$?

    if (( ! "$isTag" )); then
      typeIndex=1
      tag="tags/$tag"
    else
      typeIndex=2
    fi
  fi

  results+=("$tag")
  results+=("$typeIndex")
  results+=("$fromCommit")

  echo "${results[@]}"

  return "$ret"
}


get_reftype_of_refname() {
#echo "$FUNCNAME()" $@ >&2
  local ret=0
  local refName="${1:-HEAD}"
  local extendedInfo="${2:-0}"
  local refType isCorrect distinctRefName fullRefName isRemote isBranch isTag
  local results=()

  if (( $extendedInfo )); then
    read refName refType isCorrect distinctRefName fullRefName < <( evaluate_refname "$refName" "1")
    ret=$?
  else
    read isCorrect refName isRemote isBranch isTag < <( is_revision_correct "$refName" "1")
    ret=$?
    if (( ! "$ret" )); then
      if (( "$isCorrect" )); then
        if (( "$isBranch" )); then
          refType="branch"
        elif (( "$isTag" )); then
          refType="pinned"
        fi
      else
        ret=1
      fi

    else
      ret=2
    fi
  fi

  if (( ! "$ret" )) && (( "$isCorrect" )); then
    results+=("$refType")

    if (( "$extendedInfo" )); then
      results+=("$refName")
    fi
  fi

  echo "${results[@]}"
#  echo "${results[@]}" >&2
  return "$ret"
}


#
# Evaluate and return refname and type of the current repository.
# The repo's head can be either detached ('tag' or plain 'sha' or git checkout ... --detach or git checkout origin/master)
# or headed to some 'branch' (possible values for reftype)
# If reftype is branch, we checking remote branches as well, which names are equals.
#
function evaluate_refname() {
#echo "$FUNCNAME()" $@ >&2
  local refName="${1:-HEAD}"
  local extendedInfo="${2:-0}"
  local refType="${3}"

  local results=()
  local ret=0
  local exists=0

  local remote="${globals[$G_LEGO_REMOTE]}"
  local distinctRefName fullRefName

  read isCorrect normalizedRef isRemote isBranch isTag < <( is_revision_correct "$refName" "1" "$refType")
  ret=$?

  if (( ! "$ret" )) && (( "$isCorrect" )); then
    fullRefName=$( git rev-parse --symbolic-full-name "$normalizedRef" 2>/dev/null )
    ret=$?

    if (( ! "$ret" )); then
      exists=1
      local abbrevRef=0
      local token="sha"

      case "$fullRefName" in
        refs/tags/*)
          abbrevRef=1
          refName="${fullRefName#refs/tags/}"
          token="pinned"
          ;;
        refs/heads/*)
          abbrevRef=1
          refName="${fullRefName#refs/heads/}"
          token="branch"
          ;;
        refs/remotes/$remote/*)
          abbrevRef=1
          refName="${fullRefName#refs/remotes/$remote/}"
          token="branch"
          ;;
    #    HEAD)
      esac

      local option
      if (( $abbrevRef )); then
        option="--abbrev-ref"
      else
        option="--short"
      fi

      if [[ -z "$fullRefName" ]]; then
        fullRefName="$normalizedRef"
      fi
      distinctRefName=$( git rev-parse "$option" "$fullRefName" 2>/dev/null )
      ret=$?
      if (( "$ret" )); then
        unset distinctRefName
      fi

      results+=("$refName")
      results+=("$token")
    fi
  fi

  if (( "$ret" )) || (( ! "$isCorrect" )); then
    results+=("$NA")
    results+=("unmanaged")
  fi

  if (( "$extendedInfo" )); then
    results+=("${exists:-0}")
    results+=("${distinctRefName:-${NA}}")
    results+=("${fullRefName:-${NA}}")
  fi


  echo "${results[@]}"
  return "$ret"
}


function get_repo_url() {
  [[ -n "$1" && "$1" != "." ]] && pushd $1 &>/dev/null
  local url=$(git remote get-url ${globals[$G_LEGO_REMOTE]} &>/dev/null)
  [[ -n "$1" && "$1" != "." ]] && popd  &>/dev/null
  echo "$url"
}


function get_repo_name_from_path() {
  [[ -n "$1" && "$1" != "." ]] && pushd $1 &>/dev/null
  local gitDir=$(get_repo_git_dir)
  [[ -n "$1" && "$1" != "." ]] && popd  &>/dev/null
  local name="${gitDir##*/modules/}"
  [[ "$name" == ".git" ]] && echo "/" || echo "$name"
}


function get_repo_git_dir() {
  [[ -n "$1" && "$1" != "." ]] && pushd $1 &>/dev/null
  local url=$(git_dir)
  [[ -n "$1" && "$1" != "." ]] && popd  &>/dev/null
  echo "$url"
}


function get_module_path_up() {
  local ret=1
  local path="$1"
  local found=0

  if [[ "$path" != "/" ]]; then
    while [[ -n "$path" && "$found" == 0 ]] ; do
      path="${path%/*}"

      if [[ -n "$path" ]]; then
        for pe in ${g_module_paths[@]}; do
          if [[ "$pe" == "$path" ]]; then
            found=1
            break
          fi
        done

        if (( "$found" )); then
          ret=0
        fi
      fi
    done

    if [[ -z "$path" ]]; then
      path="/"
      ret=0
    fi
  fi

  (( ! "$ret" )) && echo "$path"

  return "$ret"
}


# External
#
function get_module_path_down() {
  local path
  local originPath="$1"
  local reminder="$2"
  local pathRest=("$3")

  local currentRest=""
  local pathSuffixes=("")
  if (( ${#pathRest[@]} )); then
    for rest in ${pathRest[@]} ; do
      currentRest+="/$rest"
      pathSuffixes+=( "$currentRest" )
    done
  fi

  if [[ "${originPath:(-1)}" == "/" ]]; then
    path="$originPath$reminder"
  else
    path="$originPath/$reminder"
  fi

  local ret=1

  for suffix in "${pathSuffixes[@]}"; do
    local pathSuffix="$path$suffix"
    for modulePath in "${g_module_paths[@]}"; do
      if [[ "$modulePath" == "$pathSuffix" ]]; then
        ret=0
        break
      fi
    done

    if (( ! "$ret" )); then
      echo "$path"
      break
    fi
  done

  return "$ret"
}


function level_verbose_about_to {

  local path=$4
  local info="about to ${SUBCOMMAND} module '${1}'"
  # global
  verboseMsg=([1]="path: $path")
  verboseMsg+=("url: "$(get_repo_url))

  if (( $verbose )); then
    cw_cr
  fi

  local fineIssues infoIssues
  verboseMsg[0]=${info}
#set +x
  cw_echo "${verboseMsg[@]}"

}


#
## Checks affected modules, which can be set after double dash
## ie. status / -- libs will check only libs module
#
# Parameters
#     $1 Module's full path to be tested on existence in afterDash array
#
# Returns
#     0 - module is found and listed in after dash parameters, or after-dash parameters are not set
#     1 - module is found but not listed in after dash parameters (out-filtered) or by pinned property
#     2 - N/A module is not found or wrong argument
#
# Globals using
#     $afterDash - array, which contains restricted module list, can be given after double dash or some other manner
#     $affected  - this variable should be defined outside of this function (output variable)
#
# NOTODO take into account --[no]-recursive flag.... ? it should be resolved not here. In the prepare-level methods !!
#
function drop_to_affected() {
  local path=$1
  local found=0
  local ret=1

  # by default use current folder... maybe unsafe working because current folder can differ from modules FULL_PATH
  [[ -z "$path" ]] && path=$( pwd )

  while read -a module; do
    found=0

    if [[ "$path" == "${module[$MFS_MODULE_PATH]}" || "$path" == "${module[$MFS_FULL_PATH]}" ]]; then
      found=1
#      if (( "${#afterDash[@]}" )); then
#        found=0
#        for branch in "${afterDash[@]}"; do
#          if [[ "${module[$MFS_MODULE_NAME]}" == "$branch" ]]; then
#            found=1
#            break
#          fi
#        done
#      fi
    fi

    if (( "$found" )); then
      local pinnedAffected=1
      if (( "$pinnedPolicy" )) ; then
        local detached=${module[$MFS_MODULE_MANAGED]}
        if (( ! "$pinnedFinal" )) && [[ "$detached" == "pinned" ]]; then
          pinnedAffected=0
        fi
      fi

      if (( "$pinnedAffected" )); then
        affected=1
        ret=0
        echo ${module[@]} >> ${globals[$G_AFFECTED_MODULES]}
        break
      else
        skippedModules+=("${module[$MFS_MODULE_NAME]}")
        cw_verbose "'$path' skipped because it is pinned and pinnedFinal is set to $pinnedFinal"
      fi
    fi
  done < <(cat ${globals[$G_MODULES_FN]})

  return "$ret"
}


function module_descriptor() {
  local levelPath=$1

  while read -a module; do
    local fullPath="${module[MFS_FULL_PATH]}"

    if [ "$levelPath" == "$fullPath" ]; then
      echo ${module[@]}
      break
    fi
  done < <(cat ${globals[$G_MODULES_FN]})

}



#
# returns (echo)
#     modulePath - module path qualified from root, ie. /root/submodule (exit code 1)
#
# exit code:
#   1 if checked parameter is module path
#   0 otherwise
#
path_or_revision() {
  local ret=0
  local runner="$1"

  local pathOfRunner=$( resolve_module_path "$runner" "..." 1 )

  if  [[ "$pathOfRunner" ]]; then
    module_info "$pathOfRunner"
    local notModule=$?

    if (( ! "$notModule" )); then
      echo "$pathOfRunner"
      ret=1
    fi
  fi

  return "$ret"
}


#
# Parameters
#   $1 -  filePath of module.
#         NOTE: It may or may not match to the directory, where placed .git entry (file or directory).
#         That means path can be any valid sub-folder of the module
#   $2 -  defaultFilePath, used in case of $1 is empty. Sometimes used "..." as a default,
#         which semantically means 'do not use default value for resolving"
#   $3 -  quiet: boolean, if true (1) don't produce notification output to stderr
#
# Returns (echo)
#   module-path if it was resolved (exit code 0)
#   nothing otherwise
#
#
# Exit code
#   0 - correct path
#   1 - wrong path
#
# NOTE: the resolving not working before umbrella_bootstrap called,
#       cos it being used g_module_paths[@] array to detection up/down path structure
#

function resolve_module_path() {
#echo "$FUNCNAME() $@" >&2
  local originPath
  local reminder="$1"
  local default="$2"
  local quiet="${3:-0}"
  local ret=0

  if [[ -z "$reminder" ]]; then
    reminder="$default"
  fi

  if [[ -n "$reminder" ]]; then
    if [[ -n "${reminder%%/*}" && -n "${reminder%%../*}" && "$reminder" != ".." && -n "${reminder%%./*}" && "$reminder" != "." ]]; then
      reminder="./$reminder"
    fi

    if [[ -z "${reminder%%/*}" ]]; then
      originPath="/"
      reminder="${reminder:1}"
    elif [[ -z "${reminder%%../*}" || "$reminder" == ".." ]]; then
      reminder="${reminder:3}"
      originPath=$( _m_pmd )
      originPath=$( get_module_path_up "$originPath" )
      (( $? )) && ret=$( die_cant_resolve_module "$1" "$quiet" )
    elif [[ -z "${reminder%%./*}" || "$reminder" == "." ]]; then
      reminder="${reminder:2}"
      originPath=$( _m_pmd )
    fi

    if (( ! "$ret" )) && (( "${#reminder}" )); then
      IFS="/" read -a parts <<< $reminder
      local partIndex=1
      for part in "${parts[@]}"; do
        case "$part" in
          \.\.\.)
            die_cant_resolve_module "$1" "$quiet"
          ;;
          \.\.)
            originPath=$( get_module_path_up "$originPath" )
            (( $? )) && die_cant_resolve_module "$1" "$quiet"
          ;;
          \.)
            ## do nothing
          ;;
          *)
            local pathRest="${parts[@]:$partIndex}"
            originPath=$( get_module_path_down "$originPath" "$part" "${pathRest[@]}" )
            (( $? )) && die_cant_resolve_module "$1" "$quiet"
          ;;
        esac
        partIndex=$(( $partIndex + 1 ))
      done
    fi
  fi

  if (( ! "$ret" )); then
    [[ -z "$originPath" ]] && originPath="$default"
    echo "$originPath"
  fi

  return "$ret"
}


update_module_cache() {
  local modulePath="$1"
  shift

  local index=0
  local ret=1
  local results=()
  for mp in "${g_module_paths[@]}"; do
    if [[ "$mp" = "$modulePath" ]]; then
      ret=0
      break
    fi
    index=$(( $index + 1 ))
  done

  if (( ! "$ret" )); then
    while [[ -n $1 ]]; do
      if [[ -n "$1" ]]; then
        if [[ "$2" == "--unset" ]]; then
          eval unset $1[$index]
        else
          eval $1[$index]="$2"
        fi
      fi
      shift 2
    done
  fi

  return "$ret"
}


function module_info () {
  local modulePath="$1"
  shift
  local index=0
  local ret=1
  local results=()

  for mp in "${g_module_paths[@]}"; do
    if [[ "$mp" = "$modulePath" ]]; then
      ret=0
      break
    fi
    index=$(( $index + 1 ))
  done


  while [[ -n $1 ]]; do
    case $1 in
      index)
        results+=($index)
        ;;
      name)
        results+=(${g_module_name[$index]})
        ;;
      relative|local)
        results+=(${g_relative_paths[$index]})
        ;;
      full|path)
        results+=(${g_full_paths[$index]})
        ;;
      gitdir)
        results+=(${g_git_dirs[$index]})
        ;;
      sha)
        results+=(${g_module_shas[$index]})
        ;;
      initialized)
        results+=(${g_module_inited[$index]})
        ;;
      managed)
        results+=(${g_module_managed[$index]})
        ;;
      refname)
        results+=(${g_managed_refnames[$index]})
        ;;
      lego_mode)
        results+=(${g_module_lego_modes[$index]})
        ;;
      lego_mode_implicit)
        results+=(${g_module_lego_modes_implicit[$index]})
        ;;
      checkout)
        results+=(${g_checkout_refnames[$index]})
        ;;
      *)
        ret=2
        break
    esac
    shift
  done

  (( ${#results[@]} )) && echo ${results[@]}
  return "$ret"
}


git_editor() {
  local ret=0
	if test -z "${GIT_EDITOR:+set}"
	then
		GIT_EDITOR="$(git var GIT_EDITOR)" || return $?
	fi

	eval "$GIT_EDITOR" '"$@"'
	ret=$?

	return "$ret"
}


#
#
#
function is_revision_correct() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2

  [[ -z $1 ]] && panic "$FUNCNAME() missed revision argument"
  local refName="$1"
  local metrics="${2:-0}"
  local refType="${3}"

  local remote="${globals[$G_LEGO_REMOTE]}"
  local checkingPlaces=()
  local normalized=0

  local explicitRefType
  local explicitRemote=0
  local explicitHead=0
  local explicitTag=0
  local remotePrefix

  case "$refName" in
    refs/*)
      refName="${refName#refs/}"
      normalized=1
      ;;
  esac

  case "$refName" in
    heads/*)
      explicitHead=1
      normalized=1
      explicitRefType="branch"
      refName="${refName#heads/}"
      ;;
    tags/*)
      explicitTag=1
      normalized=1
      explicitRefType="pinned"
      refName="${refName#tags/}"
      ;;
    remotes/*)
      normalized=1
      explicitRefType="pinned"
      refName="${refName#remotes/}"
      ;;
  esac
  
  if (( ! $explicitHead )) && (( ! $explicitTag )) ; then
    case "$refName" in
      $remote/*)
        normalized=1
        explicitRemote=1
        explicitRefType="pinned"
        refName="${refName#$remote/}"
        ;;
    esac
  fi

#  local possibleAmbiguous=0
  if (( ! "$normalized" )); then
    if [[ -z "$refType" || "$refType" == "sha" ]] ; then
#      possibleAmbiguous=1
      checkingPlaces+=("")

    fi
    if [[ -z "$refType" || "$refType" == "branch" ]] ; then
      checkingPlaces+=("heads/")
      checkingPlaces+=("$remote/")
    fi
    if [[ -z "$refType" || "$refType" == "pinned" ]] ; then
      checkingPlaces+=("tags/")
    fi
  else
    if (( $explicitRemote )) ; then
      checkingPlaces+=("$remote/")
    elif (( $explicitHead )); then
      checkingPlaces+=("heads/")
      checkingPlaces+=("$remote/")
    elif (( $explicitTag )); then
      checkingPlaces+=("tags/")
    fi
  fi

  local ret=0
  local results=(0)

  for prefix in "${checkingPlaces[@]}"; do
    local prefixBranch="${prefix}${refName}"

    git rev-parse --no-revs "$prefixBranch" &>/dev/null
    local ret=$?

    if (( ! $ret )); then
      results[0]=1

      if (( "$metrics" == 1 )); then
        local result=0
        results+=("$prefixBranch")

        if [[ "$prefix" == "$remote/" ]] ; then
          result=1
        fi
        # isRemote
        results+=("$result")

        if [[ "$prefix" == "heads/" ]]; then
          result=1
        fi
        # isBranch
        results+=("$result")

        if [[ "$prefix" == "tags/" ]]; then
          result=1
        else
          result=0
        fi
        #isTag
        results+=("$result")
      fi
      break
    fi
  done

  echo "${results[@]}"
  return "$ret"
}


#
# Function accepts array of variables' list and check out variable are constructed from this list
# ie. list "delete verbose tag" will cause checking of variables doDelete, then doVerify, then doTag
# If any variable are defined & is not equals 0, function produce output according to input array items.
# If for example doTag=1 doDelete=0 doVerbose=1 -> "tag" "verbose" will be echoed
# Not defined variables are ignored
#
which_command() {
  local ret=()

  for cmd in $@; do
    local cmdVariable=do${cmd^}
    local value=${!cmdVariable}

    if (( "${value:-0}" )); then
      ret+=("$cmd")
    fi
  done

  echo "${ret[@]}"
}


assign_status_item() {
  if [[ -z $3 ]]; then
    eval $1\+=\("$2"\)
  else
    eval $1[$3]="$2"
  fi
}


assign_status_array() {
  local arr=$1 ind=$2
  shift 2
  eval $arr[$ind]=\$@
}


get_status_item() {
  eval echo '"${'$1'[$2]}"'
}


increase_status_item() {
  val=$( get_status_item $@ )
  val=$(( $val + 1 ))
  assign_status_item "$1" "$val" "$2"
}


typeset MODULE_STATUS=()
#
##  Get status for current module
#
#     Fill up one dimension array with different information about current module state.
#     Information in the array will be valid till next call of the method.
#     Current directory (pwd) of module should be set outside of the function.
#
## Parameters
#     $1  - file path of current module
#     $2  - caller, which indicated the caller script, ie. "status"/"commit"/..
#     $3  - destination external array, which accumulate all statuses, by default MODULE_STATUS
#     ... - other parameters relevant to its caller
#
## External variables
#     $MODULE_STATUS array
#
function module_porcelain_status() {
#echo "$FUNCNAME()" $@ >&2 ; pwd >&2
#if [[ $1 == "/viatra" ]]; then
#  set -x
#fi
#  local remoteInteraction=0
  local checkoutCheck=0 managedBranch guessedBranched=()

  local modulePath="$1"
  local caller="$2"
  local arrName="${3:-MODULE_STATUS}"

  [[ -z "$modulePath" ]] && panic "$FUNCNAME(): missed parameter 'path'"

  local guessing=1

  [[ "$caller" == "noguess" ]] && guessing=0
#  if [[ "$caller" == "status" ]]; then
#    remoteInteraction=1
#  fi

  if [[ "$caller" == "push" || "$caller" == "pull" ]]; then
#    remoteInteraction=1
    guessing=0
  fi

  if [[ "$caller" == "checkout" ]]; then
    checkoutCheck=1
  fi

  eval unset $arrName

  local moduleSha
  local managed
  local managedRefname managedReftype managedRefTypeIndex
  local unmanaged=1
#set -x
  read initialized managedReftype managedRefname moduleHash checkoutRef < <(module_info "$modulePath" "initialized" "managed" "refname" "sha" "checkout" )
  managedRefTypeIndex=$( ref_type_index "$managedReftype" )
  if [[ -z "$initialized" ]]; then
    panic "$FUNCNAME(): Variable \$initialized is empty. Check code!"
  fi

  if [[ "$checkoutCheck" == 1 ]]; then
    if [[ -n "$checkoutRef" && "$checkoutRef" != "-"  ]]; then
      unmanaged=0
      read type checkoutRef < <( get_reftype_of_refname "$checkoutRef" 1 )
      if (( $? )); then
        assign_status_item "$arrName" $( ref_type_index "$type" ) "$MS_CHECKOUT_REFTYPE"
        assign_status_item "$arrName" "$checkoutRef" "$MS_CHECKOUT_REFNAME"
      fi
    fi
  else
    if [[ -n "$managedReftype" && "$managedReftype" != "unmanaged" ]]; then
      managedRefTypeIndex=$( ref_type_index "$managedReftype" )
      unmanaged=0

      if [[ -n "$managedRefname" && "$managedRefname" != "$NA" ]]; then
        assign_status_item "$arrName" "$managedRefTypeIndex" "$MS_MANAGED_REFTYPE"
        assign_status_item "$arrName" "$managedRefname" "$MS_MANAGED_REFNAME"
      fi
    fi
  fi
  assign_status_item "$arrName" "$unmanaged" "$MS_UNMANAGED"

  local moduleRefname moduleRefTypeIndex detachedFrom
  local output=()

  if [[ -z "$initialized"  ||  "$initialized" == 0 ]] ; then
    assign_status_item "$arrName" 1 "$MS_UNINITIALIZED"
  else
    assign_status_item "$arrName" 0 "$MS_UNINITIALIZED"

    while read switch line; do
#      echo $switch >&2
#      echo $line >&2
      # parse line into array or words 
      # !! do not quote !!!
      output=( $line )

      case "$switch" in
        \#)
          case ${output[0]} in

            branch\.oid)
              moduleSha=${output[1]}
              # TODO do this at bootstrap
              assign_status_item "$arrName" $( git rev-parse --short "$moduleSha" ) "$MS_MODULE_REFNAME"
              ;;
            branch\.head)
              if [[ "${output[1]}" == "(detached)" ]]; then
                read moduleRefname moduleRefTypeIndex detachedFrom < <( detached_names_type "$moduleHash" )
              else
                moduleRefname="${output[1]}"
                moduleRefTypeIndex=0
              fi

              assign_status_item "$arrName" "$moduleRefname" "$MS_MODULE_REFNAME"
              assign_status_item "$arrName" "$moduleRefTypeIndex" "$MS_DETACHED"

              if [[ -n "$detachedFrom" ]]; then
                assign_status_item "$arrName" "$detachedFrom" "$MS_DETACHED_FROM"
              fi

              local mismatched=0

              if [[ ( "$moduleRefTypeIndex" != "$managedRefTypeIndex" ||  "$managedRefname" != "$moduleRefname" ) \
                  && "$unmanaged" == 0  && "$modulePath" != "/" ]]
              then

                mismatched=1

                if [[  "$moduleRefTypeIndex" > 0 &&  "$managedRefname" != "$NA" ]]; then
#                  calculate_ab_for_tag "$managedRefname" "HEAD" "$arrName"
                  local against="HEAD"
                  local reachable=$( git merge-base "$managedRefname" "$against" 2>/dev/null | wc -l )
                  ret=$?
                  if (( ! "$ret" )) && (( "$reachable" )); then
                    local a b
                    local out=$( git rev-list "$against".."$managedRefname" 2>/dev/null | wc -l )
                    ret=$?
                    if (( ! "$ret" )); then
                      b=$(( $out + 0 ))
                      assign_status_item "$arrName" "$b" "$MS_UPSTREAM_BEHIND"

                      out=$( git rev-list "$managedRefname".."$against" 2>/dev/null | wc -l )
                      ret=$?

                      if (( ! "$ret" )); then
                        a=$(( $out + 0 ))
                        assign_status_item "$arrName" "$a" "$MS_UPSTREAM_AHEAD"
                      fi
                    fi
                    if (( ! "$a" )) && (( ! "$b" )); then
                      mismatched=0
                    fi
                  else
                    assign_status_item "$arrName" 1 "$MS_UNREACHABLE"
                  fi
                fi
              fi

              assign_status_item "$arrName" "$mismatched" "$MS_MISMATCHED"
              ;;

            branch\.upstream)
              assign_status_item "$arrName" "${output[1]}" "$MS_UPSTREAM"
              ;;

            branch\.ab)
              local upstreamHead="${output[1]:1}"
              local upstreamBehind="${output[2]:1}"
              assign_status_item "$arrName" "$upstreamHead" "$MS_UPSTREAM_AHEAD"
              assign_status_item "$arrName" "$upstreamBehind" "$MS_UPSTREAM_BEHIND"
              if (( "$upstreamHead" )); then
                assign_status_item "$arrName" 1 "$MS_PUSHABLE"
              fi
              if (( "$upstreamBehind" )); then
                assign_status_item "$arrName" 1 "$MS_PULLABLE"
              fi
              ;;
          esac
          ;;
        \?)
          local entryName="${output[0]}" #.gitmodule or .gitlego
          if [[ "$entryName" == ".gitmodules"  || "$entryName" == ".gitlego" ]]; then
            increase_status_item "$arrName" "$MS_MODIFIED_SUBMODULE"
            assign_status_item "$arrName" 1 "$MS_COMMITABLE"
          else
            increase_status_item "$arrName" "$MS_UNTRACKED"
            if [[ "$caller" == "commit" ]] && (( "$doAppendUntracked" )); then
              assign_status_item "$arrName" 1 "$MS_COMMITABLE"
            fi
          fi
          ;;

        1|2|u)
          local fileState="${output[0]}"
          local fChar="${fileState:0:1}" sChar="${fileState:1:1}"
          local submoduleToken="${output[1]}"
          local entryName="${output[7]}" #.gitmodule or .gitlego or submodule name
          if [[ "$entryName" == ".gitmodules"  || "$entryName" == ".gitlego" || "${submoduleToken:0:1}" == "S" ]]; then increase_status_item "$arrName" "$MS_MODIFIED_SUBMODULE"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          elif [[ "$fChar" == "M" || "$sChar" == "M" ]] ; then increase_status_item "$arrName" "$MS_MODIFIED"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          elif [[ "$fChar" == "A" || "$sChar" == "A" ]] ; then increase_status_item "$arrName" "$MS_ADDED"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          elif [[ "$fChar" == "D" || "$sChar" == "D" ]] ; then increase_status_item "$arrName" "$MS_DELETED"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          elif [[ "$fChar" == "R" || "$sChar" == "R" ]] ; then increase_status_item "$arrName" "$MS_RENAMED"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          elif [[ "$fChar" == "C" || "$sChar" == "C" ]] ; then increase_status_item "$arrName" "$MS_COPIED"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          elif [[ "$fChar" == "U" || "$sChar" == "U" ]] ; then increase_status_item "$arrName" "$MS_UNMERGED"; assign_status_item "$arrName" 1 "$MS_COMMITABLE";
          fi
          ;;
      esac
    done < <(git status -u --porcelain=2 -b)

    if (( "$guessing" )); then
      guess_refnames_of_commit "$modulePath" "HEAD" "$arrName"
    fi

  fi
}


ref_type_index() {
  local managedReftype="$1"
  local index=0
  for reftype in "${G_REFTYPE_TOKENS[@]}" ; do
    if [[ "$reftype" == "$managedReftype" ]]; then
      break
    fi
    index=$(( $index + 1 ))
  done

  echo $index
}


function module_up() {
  cd $(show_toplevel)"/.."
  cd $(show_toplevel)
}


calculate_ab_for_branch() {
#  echo "$FUNCNAME()" >&2
  local normalizedRefname="$1"
  local against=${2:-HEAD}

  local ab=()
  local ret=0

  local reachable=$( git merge-base "$normalizedRefname" "$against" 2>/dev/null | wc -l )
  ret=$?

  if (( ! "$ret" )) && (( $reachable )); then
    local out=$( git rev-list "$against".."$normalizedRefname" 2>/dev/null | wc -l )
    ret=$?

    if (( ! "$ret" )); then
      local a=$(( $out + 0 ))
      ab+=(+"$a")
      MODULE_STATUS[$MS_UPSTREAM_AHEAD]="$a"

      out=$( git rev-list "$normalizedRefname".."$against" 2>/dev/null | wc -l )
      ret=$?

      if (( ! "$ret" )); then
        local b=$(( $out + 0 ))
        MODULE_STATUS[$MS_UPSTREAM_BEHIND]="$b"
        ab+=(-"$b")
      fi
    fi
  fi

  echo "${ab[@]}"
  return "$ret"
}


#
# External arrays:
#     guessedRefnames
#     asWellRefs
#
calculate_as_well_refnames() {
  local refName=$1

  for asWell in ${guessedRefnames[@]} ; do
    if [[ "$asWell" != "$refName" && "$asWell" != "${refName#refs/tags/}" && "$asWell" != "${refName#refs/heads/}" ]] ; then
      asWellRefs+=("$asWell")
    fi
  done
}


function guess_refnames_of_commit() {
  local modulePath="$1"
  local ret hash="${2:-HEAD}"
  local arrName="${3:-MODULE_STATUS}"

  local branches=()
  local tags=()
  # const
  local legoRemote="${globals[$G_LEGO_REMOTE]}"

  if [[ "$modulePath" != "/" ]]; then
    while read moduleSha commit ref; do
#      echo $ref >&2
      local refParsed
      refParsed=$( git rev-parse --abbrev-ref=loose "$ref" 2>/dev/null )
      found=0

      if [[ "${ref#refs/tags/}" == "$refParsed" ]] ; then
        for tag in ${tags[@]}; do
          if [[ "$tag" == "$refParsed" ]]; then
            found=1
            break
          fi
        done

        if (( ! "$found" )) ; then
#          echo ${refParsed} >&2
          tags+=("$refParsed")
        fi
      else
        if [[ "${refParsed#heads/}" != "$refParsed" ]]; then
          # filter out heads/master
          refParsed="${refParsed#heads/}"

        elif [[ "${refParsed#${legoRemote}/}" != "$refParsed" ]]; then

          # filter out origin/master
          refParsed="${refParsed#${legoRemote}/}"

        elif [[ "${ref#refs/remotes/}" == "$refParsed" ]]; then

          # filter out heads/remotes/other_remote/master
          local otherRemote="${ref#refs/remotes/}" # other_remote/master
          if [[ "${otherRemote#${legoRemote}/}" == "$otherRemote" ]]; then
            found=1
          fi
        fi

        if (( ! "$found" )); then
          for branch in ${branches[@]}; do
            if [[ "$branch" == "$refParsed" ]]; then
              found=1
              break
            fi
          done

          if (( ! "$found" )) ; then
#            echo ${refParsed#${legoRemote}/} >&2
            branches+=("${refParsed#${legoRemote}/}")
          fi
        fi
      fi
    done < <(git for-each-ref --points-at=HEAD)

    if (( "${#branches[@]}" )); then
      assign_status_array "$arrName" "$MS_GUESSED_BRANCHES" ${branches[@]}
#    else
#      local moduleRefTypeIndex=$( get_status_item "$arrName" "$MS_DETACHED" )
#      if (( "$moduleRefTypeIndex" )) ; then
#          assign_status_item "$arrName" 1 "$MS_DANGLED"
#      fi
    fi
    if (( "${#tags[@]}" )); then
      assign_status_array "$arrName" "$MS_GUESSED_TAGS" ${tags[@]}
    fi
  fi
}


persist_attain_hint() {
#echo "$FUNCNAME()" $@ >&2
  local doApply="$1"
  local moduleName="$2"
  local refName="$3"
  local refType="$4"
  local mode="${5:-${g_lego_mode}}"

  local remote="${globals[$G_LEGO_REMOTE]}"
  local ret=0
  local fullRefName="$refName"

  if (( "$ret" )); then
    dieMsg="$FUNCNAME(): unexpected error by 'git checkout $refName'"
  else
    local section="submodule.$moduleName"
    case "$refType" in
      branch)
        case "$refName" in
          refs/heads/*)
            # nothing
            ;;
          heads/*)
            fullRefName="refs/$refName"
            ;;
          *)
            fullRefName="refs/heads/$refName"
            ;;
        esac
        ;;

      pinned)
        case "$refName" in
          refs/remotes/$remote/*)
#            refType=remote
            # nothing
            ;;
          remotes/$remote/*)
#            refType=remote
            fullRefName="refs/$refName"
            ;;
          $remote/*)
#            refType=remote
            fullRefName="refs/remotes/$refName"
            ;;
          tags/*)
#            refType=tag
            fullRefName="refs/$refName"
            ;;
          *)
#            refType=tag
            fullRefName="refs/tags/$refName"
            ;;
        esac
       ;;

      sha)
        refType=commit
        ;;
    esac

    # currently checkout repository to tag or sha reference will not affect to last reflog entry
    # Last reflog entry is responsible to show 'git show --long' output, if repo is detached
    # Not clear this is a bug in git core or intended behaviour, currently git version 2.14.2
    # TODO instead of git checkout add new entry to reflog ?? issues with old git version ??
    if (( "$doApply" )); then
      local attainRefName="$refName"
      if [[ "$refType" != "branch"  ]]; then
        attainRefName="$fullRefName"
      fi
      cw_echo "About to update $moduleName to $attainRefName..."
      git checkout "$attainRefName"
      ret=$?
    fi

    cw_echo "Module '$moduleName' is attained to $refName $refType"
    set_module_meta_mode "refname" "$fullRefName" "$section" ".." "$mode"
  fi

  return "$ret"
}


#
# EXTERNAL : guessedRefnames - array of branches or tags
#
evaluate_attain_hint() {
  local parentRefname="$1"
  local parentRefType="$2"
  local hint=()

  local guessedRefname
  local guessedReftype="$parentRefType"

  case "$parentRefType" in
    branch)
      guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
      if (( ! "${#guessedRefnames[@]}" )); then
        guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
        if (( "${#guessedRefnames[@]}" )); then
          guessedReftype="pinned"
        else
          guessedReftype="sha"
        fi
      fi
      ;;
    pinned)
      guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_TAGS]})
      if (( ! "${#guessedRefnames[@]}" )); then
        guessedRefnames=(${MODULE_STATUS[$MS_GUESSED_BRANCHES]})
        if (( "${#guessedRefnames[@]}" )); then
          guessedReftype="branch"
        else
          guessedReftype="sha"
        fi
      fi
      ;;
#    sha)
#      guessedRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
#      ;;
  esac

  if [[ ${#guessedRefnames[@]} == 1 ]]; then
    guessedRefname="${guessedRefnames[0]}"
  elif [[ ${#guessedRefnames[@]} > 1 && -n "$parentRefname" ]]; then
    for myRefname in "${guessedRefnames[@]}"; do
      if [[ "$myRefname" == "$parentRefname" ]]; then
        guessedRefname="$myRefname"
      fi
    done
  fi

  if [[ -z "${guessedRefname}" && "${#guessedRefnames[@]}" ]]; then
    guessedRefname="${guessedRefnames[0]}"
  fi

  if [[ -z "${guessedRefname}" ]]; then
    guessedRefname="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
  fi

  hint+=("$guessedRefname")
  hint+=("$guessedReftype")
  echo "${hint[@]}"
}


do_module_update() {
#echo "$FUNCNAME()" $@ >&2
  local parentFilePath="$1"
  local moduleName="$2"
  local modulePath="$3"
  local localPath="$4"
  local revision="$5"

  if [[ "$modulePath" != "/" ]]; then
    local uninitialized=${MODULE_STATUS[$MS_UNINITIALIZED]}
    local unmanaged=${MODULE_STATUS[$MS_UNMANAGED]}
    local applied=1

    if (( "$uninitialized" )) || (( ! "$unmanaged" )) || [[ -n "$revision" ]] || (( $doForce )); then

      local managedRefname
      if (( $uninitialized )); then
        cw_echo "About to update module $moduleName..."
        git -C "$parentFilePath" submodule update --init -- "$localPath"
        (( ! $? )) && cw_echo "... OK!"
      fi

      if [[ -n "$revision" ]]; then
        managedRefname="$revision"
      elif (( ! $unmanaged )) ; then
        managedRefname=${MODULE_STATUS[$MS_MANAGED_REFNAME]}
#        else
#          managedRefname=$( get_attained_hint )
      fi
      if [[ -n "${managedRefname}" ]] ; then
        cw_echo "About to checkout to '$managedRefname' for '$moduleName' ..."
        git checkout "${managedRefname}"
        (( ! $? )) && cw_echo "... OK!"
      fi
    fi
  fi
}


update_level() {
#echo "$FUNCNAME()" $@ >&2
  local parentFilePath="$1"
  local levelPath=$(pwd)
#  [[ -z "$levelPath" ]] && panic "$FUNCNAME()... parameter 'path' is required"
  local moduleName="$2"
  local modulePath="$3"

  local ret=0   # return code
  local childRet # child return code

  drop_to_affected #"$levelPath"
  if (( ! $? )) ; then

    module_porcelain_status "$modulePath" "update"

    do_module_update "$@"

    if [ -f .gitmodules ]; then
      while read -a module; do
        childRet=0
        moduleName="${module[0]}"
        localPath="${module[1]}"

        subRepoPath="$levelPath"/"$localPath"

        local modulePath="$3"
        [[ ${modulePath:(-1)} != "/" ]] && modulePath+="/"
        modulePath+="$moduleName"

        pushd "$subRepoPath" &>/dev/null
        update_level "$levelPath" "$moduleName" "$modulePath" "$localPath"
        childRet=$?

        popd  &>/dev/null

        (( "$childRet" > "$ret" )) && ret="$childRet"
      done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
    fi
  fi
}

#
## DEPRECATED in favor of attain/update commands
#
## Checks branching state for current repository
## Let name the branch is synchronized if entry submodule.<module-name>.branch in .gitmodules is matched
## to the branch of the sub-repository, (what can be checked via 'cd module-path; git branch',
##
## It they are mismatched, 3 options are possible.
##
## 1. Sub-repo can be detached. In this case we are looking for value in the outer repo and doing git checkout branch
## 2. Sub-repo is pinned to another branch that is given in .gitmodules. To sync this we just changing value in .gitmodules file of outer repo
## 3. Sub-repo is detached, no value in .gitmodules. We are unable to re-syncronize, notify user about and exit.
## Parameters:
##      $1 path [required] - path getting started checking.
##      $2 doSync [optional, by default 0] - do synchronization (case 1) or not
##
## The function calls itself recursively to drill down to any leave repos.
##
## Returns
##
function check_branch_sync() {
  local levelPath="$1"
  local doSync=${2:-0}

  [[ -z ${levelPath} ]] && panic "check_branch_sync()... parameter 'path' is required"
  local repoBranch
  local ret=0   # return code, 0 - the repo is synchronized
  local childRet # child return code
  cd "${levelPath}"

  while read -a repo; do
    childRet=0
    subRepoName="${repo[0]}"
    checkBranch=$(git config --file .gitmodules --get submodule."${subRepoName}".branch)
    checkPath="${repo[1]}"
    subRepoPath="${levelPath}"/"${checkPath}"

    #    echo "${subRepoName}" "${checkBranch}" "${checkPath}"

    pushd "${subRepoPath}" &>/dev/null
    #    pwd

    repoBranch=$(git rev-parse --abbrev-ref HEAD)
    local detached=0
    [[ "${repoBranch}" == "HEAD" ]] && detached=1

    #    echo "${repoBranch}"
    if [[ ${repoBranch} != ${checkBranch} ]]; then

      ret=1
      (( ! $doSync )) && cw_echo "Module ${subRepoName} is not synchronized"
      #      echo "$repoBranch != $checkBranch"

      #
      if [[ -n "${repoBranch}" && ${detached} == 0  ]]; then
        cd "${levelPath}"
        if (( $doSync )); then
          cw_echo "About to change reference in .gitmodules for submodule $subRepoName to branch $repoBranch"
          git config --file .gitmodules submodule."${subRepoName}".branch "${repoBranch}"
          ret=$?
        fi
      elif [[ -n "${checkBranch}" && ${detached} == 1 ]]; then
        cd "${subRepoPath}"
        if (( $doSync )); then
          cw_echo "About to checkout submodule $subRepoName to branch $checkBranch"
          git checkout ${checkBranch}
          ret=$?
        fi
      else
        cw_echo "Warning: submodule ${subRepoName} can't be synchronized"
        ret=2
      fi
    else
      (( $doView )) && cw_echo "Module '$subRepoName' at '$checkBranch' branch"
    fi

    if [[ -e .gitmodules ]]; then
      check_branch_sync "${subRepoPath}" ${doSync}
      childRet=$?
    fi
    (( $childRet )) && ret=1


    popd  &>/dev/null

    if (( $doSync )); then
      git diff --exit-code --quiet -- .gitmodules
      needToCommit=$?
      #echo "needToCommit=${needToCommit}"
      if (( $needToCommit)); then
        if (( $doAutoCommit )); then
          git add .gitmodules
          git commit -m "$subRepoName submodule configuration is changed"
        else
          needMessageToPush=1
        fi
      fi
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return "${ret}"
} ## of check_branch_sync



  ######################################################################################################################
  #################################################   MLS  #############################################################
  ######################################################################################################################



function _m_finalize() {
  unset strict
  unset verbose
  unset recursive
#  set +x
}

function _m_mls() {
  local ret=0
  while read -a module; do
    subModule="${module[0]}"
    localPath="${module[1]}"
    pushd "$localPath" &>/dev/null
    _m_pmd

# TODO recursive is not defined. should be parameter?
    if (( $recursive )); then
      _m_mls && ret=1
    fi

    popd &>/dev/null
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
  return ${ret}
}

function _m_not_git_repository() {
  git rev-parse --git-dir &> /dev/null
  if (( $? )); then
    _m_die "Not a git repository"
    return 1
  fi
  return 0
}


function _m_pmd() {
  local gitDir=$(_m_git_dir)
  gitDir=${gitDir##*.git/}
  local path
  IFS="/" read -a names <<< ${gitDir}

  for name in ${names[@]}; do
    if [[ "$name" != "modules" && "$name" != ".git" ]]; then
      path+=/"$name"
    fi
  done

  [[ -z "$path" ]] && path="/"
  echo  "$path"
}


function _m_die() {
  echo $1 >&2
  _m_finalize
}


function _m_path_resolution() {
  local originPath reminder="$1"
  if [[ ${reminder} != "." && -n ${reminder} ]]; then
    local strict=$2

    if [[ -n ${reminder} ]]; then

      if [[ -z ${reminder%%/*} ]]; then
        _m_root 1; (( $? )) && return 1
        reminder=${reminder:1}
      elif [[ -z ${reminder%%../*} || $reminder == ".." ]]; then
        reminder=${reminder:3}
        _m_pwd 1
        _m_up 1; (( $? )) && return 1
      elif [[ -z ${reminder%%./*} || $reminder == "." ]]; then
        reminder=${reminder:2}
        _m_pwd 1
      fi

      if (( ${#reminder} )); then
        IFS="/" read -a parts <<< $reminder
        for part in $parts; do
          case $part in
            \.\.)
              _m_up 1; (( $? )) && return 1
            ;;
            \.)
              ## nothing
            ;;
            *)
              _m_down ${part} 1 $strict; (( $? )) && return 1
            ;;
          esac
        done
      fi
    fi
  else
    _m_pwd 1
  fi

  pwd
}


function _m_up() {
  local doCd=$1

  if [[ "$doCd" == 1 ]]; then
    if [[ $(_m_git_dir) == ".git" ]]; then
      echo "Can't get up at the root module" >&2
      return 1
    else
      _m_pwd 1
      cd ..
      _m_pwd 1
    fi
  else
    # TODO
    echo "mode '$FUNCNAME $1' not yet implemented" >&2
    return 1
  fi
}


function _m_down() {
  local path="$1"
  local doCd="$2"
  local ret=1
  local strict="$3"

  if [[ -n $strict ]]; then
    path=${strict}${path}
  fi

  while read -a module; do
    subModule="${module[0]}"
    localPath="${module[1]}"
    echo "$subModule" | grep "${path}" &> /dev/null
    local existsReverted=$?
    if (( ! $existsReverted )); then
      ret=0
      if (( $doCd )); then
        cd "$localPath"
      else
        echo $(_m_pwd)/"$localPath"
      fi
      break
    fi
  done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")

  return ${ret}
}


  #
  ## Print module directory
  ## just like Unix pwd, but for modules hierarchy
  #
function _m_pwd() {
  local path=$( show_toplevel )
  local doCd="$1"
  if (( "$doCd" )); then
    cd "$path"
  else
    echo "$path"
  fi
}


function _m_git_dir() {
  echo $( git_dir)
}


function _m_root() {
  local doCd="$1"
  local gitDir=$(_m_git_dir)
  local rootGitDir=${gitDir##*/}
  local root

  if [[ ${rootGitDir} == ".git" ]]; then
    root=$(show_toplevel)
  else
    root="${gitDir%%/.git/*}"  > /dev/null
  fi

  if (( "$doCd" )); then
    cd "${root}"
  else
    echo "${root}"
  fi
}


#
# Boolean treated as it does in Java/javascript where true == 1|false == 0,
# opposed to bash world, where true == 0|false=1
# Sorry for inconvenience ;)
#
READ_boolean() {
  local input="${1:-0}"
  local default="$2"

  case "${input}" in
    true|t|1)
      input=1;
    ;;
    false|f|0)
      input=0
    ;;
    *)
#      warn "wrong format for boolean value, defaulting to 0"
      input="$default"
      ;;
  esac
  echo "$input"
}


#
# Get  default if missed
#
READ_string() {
  local input="$1"
  local default="$2"

  case "${input}" in
    '')
      input="$default"
      ;;
    *) #warn "wrong format for boolean value, defaulting to 0" ;;
#      input
  esac

  echo "$input"
}


resolve_module_managed() {
  local moduleName=$1
  local modulePath=$2
  local parentLegoMode="${3:-$g_lego_mode}"
  local parentModeImplicit="${4:-1}"
  local ret=()
  local found=0

  local section="submodule.$moduleName"
  local value=$( get_lego_setting_mode "refname" "$section" "$parentLegoMode" )

  if (( "${#value}" )) ; then
    case "$value" in
      refs/heads/*)
        token="branch"
        value="${value#refs/heads/}"
        ;;
      heads/*)
        token="branch"
        value="${value#heads/}"
        ;;
      tags/*)
        token="pinned"
        value="refs/$value"
        ;;
      refs/tags/*)
        token="pinned"
        ;;
      *)
        token="sha"
        ;;
    esac
    ret+=("$token")
    ret+=("$value")
  else
    ret+=("unmanaged")
    ret+=("$NA")
  fi
  echo "${ret[@]}"
}


################################################### DELETING #################################################
clean_git_config_section() {
#echo "$FUNCNAME()" $@ >&2
  local legoModesMask=$1
  [[ -z ${legoModesMask} ]] && panic "$FUNCNAME()... parameter 'modesMask' is required"
  local section=$2
  [[ -z ${section} ]] && panic "$FUNCNAME()... parameter 'section' is required"
  local fileOption

  local index=0
  for mode in ${G_LEGO_MODES[@]}; do
    local bitIndex=$((1 << $index))
    if (( $bitIndex & $legoModesMask )); then
      if [[ "$mode" == "versioned" ]]; then
        fileOption="-f .gitlego"
        if [[ "$section" == "lego" ]]; then
          section="core"
        fi
      elif [[ "$mode" == "solo" && "$section" == "core" ]]; then
        section="lego"
      fi

      if [[ "$fileOption" != '-f .gitlego' || -e .gitlego ]]; then
        git config ${fileOption} --remove-section "${section}" 2>/dev/null
      fi
    fi
    index=$(( $index + 1 ))
  done

}


clean_module_meta_mode() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local mode="$1"
  local moduleName="$2"
  local worktree="$3"

  local section="submodule.$moduleName"
  for token in ${G_MANAGED_TOKENS[@]}; do
    wipe_lego_setting_at_mode "$token" "$section" "$mode" "$worktree"
  done
}


clean_module_meta_mask() {
#echo "$FUNCNAME()" $@ >&2
  local moduleName="$1"     # required
  local legoModesMask="${2:-0}" # required as well, by default - nothing wiped
  local worktree="$3"

  local index=0
  for mode in ${G_LEGO_MODES[@]}; do
    local bitIndex=$((1 << $index))
    if (( $bitIndex & $legoModesMask )); then
      clean_module_meta_mode "$mode" "$moduleName" "$worktree"
    fi
    index=$(( $index + 1))
  done
}


wipe_lego_setting_at_mode() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  local section="$2"
  local mode="${3:-${g_lego_mode}}"
  local worktree="${4:-.}"
  local value

  if [[ "$mode" == "solo" ]] ; then
    wipe_lego_setting_concrete "$key" "$section" "$worktree" "--local"
  elif [[ "$mode" == "versioned" ]] ; then
    wipe_lego_setting_concrete "$key" "$section" "$worktree" "-f .gitlego"
  fi
}


wipe_lego_setting_concrete() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  [[ -z "$key" ]] && panic "$FUNCNAME() missing parameter 'key'"
  local section="${2:-core}"
  local worktree="${3:-.}"
  local fileOption="${4:---}"
  local ret=0

  if [[ "$worktree" == "." ]]; then
    unset worktree
  fi

  if [[ -z "${fileOption##--*}" &&  "$section" == "core" ]] ; then
    section="lego"
  elif [[ -n "${fileOption##--*}" &&  "$section" == "lego" ]] ; then
    section="core"
  fi

  if [[ "$fileOption" == "--" ]]; then
    unset fileOption
  fi


  local topRelative
  if [[ -n "$worktree" ]]; then
    topRelative=$( git -C "$worktree" rev-parse --show-cdup 2>/dev/null )
  fi

  git ${worktree:+ -C $topRelative$worktree} config $fileOption --unset-all "${section}.$key"  &>/dev/null
  ret=$?

  wipe_section_if_empty "$section" "$fileOption" "$worktree"

  return "$ret"
}


wipe_section_if_empty () {
#echo "$FUNCNAME()" $@ >&2
  local section="$1"
  local fileOption="${2:---}"
  local worktree="$3"

  if [[ -z "${fileOption##--*}" &&  "$section" == "core" ]] ; then
    section="lego"
  elif [[ -n "${fileOption##--*}" &&  "$section" == "lego" ]] ; then
    section="core"
  fi

  if [[ "$fileOption" == -- ]]; then
    unset fileOption
  fi

  local keyRe="${section}.*"
  local topRelative
  if [[ -n "$worktree" ]]; then
    topRelative=$( git -C "$worktree" rev-parse --show-cdup 2>/dev/null )
  fi

  local notEmpty=$( git ${worktree:+ -C $topRelative$worktree} config $fileOption --get-regexp "$keyRe" 2>/dev/null | wc -l )

  if (( ! $notEmpty )); then
    if [[ "$fileOption" != '-f .gitlego' || -e .gitlego ]]; then
      git ${worktree:+ -C $topRelative$worktree} config $fileOption --remove-section "$section" 2>/dev/null
      read notEmpty fn < <(wc -w .gitlego 2>/dev/null)
      notEmpty=$(( $notEmpty + 0 ))
      if (( ! "$notEmpty" )); then
        rm -f .gitlego &>/dev/null
      fi
    fi
  fi
}


##################################################### SETTING #################################################
set_module_meta_mode() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  local value="$2"
  local section="$3"
  local worktree="${4:-.}"
  local mode="${5:-${g_lego_mode}}"
  local ret=0

  if [[ "$mode" == "solo" ]]; then
    value=$( set_lego_setting_concrete "$key" "$value" "$section" "$mode" "$worktree")
    ret=$? || $ret
  elif [[ "$mode" == "versioned" ]]; then
    value=$( set_lego_setting_concrete "$key" "$value" "$section" "$mode" "$worktree" "-f .gitlego" )
    ret=$? || $ret
  fi
  return $ret
}


set_lego_setting_concrete() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  [[ -z $key ]] && panic "$FUNCNAME() missing parameter 'key'"
  local value="$2"
  local section="$3"
  local mode="$4"
  local worktree="$5"
  local fileOption="${6:---}"

  if [[ "$worktree" == "." ]]; then
    unset worktree
  fi

  if [[ -z "${fileOption##--*}" && "$section" == core ]] ; then
    section="lego"
  elif [[ -n "${fileOption##--*}" &&  "$section" == lego ]] ; then
    section="core"
  fi


  if [[ "$fileOption" == "--" ]]; then
    fileOption="--local"
  fi

  local topRelative
  if [[ -n "$worktree" ]]; then
    topRelative=$( git -C "$worktree" rev-parse --show-cdup 2>/dev/null )
  fi
#  pwd >&2
#  echo "git ${worktree:+ -C $topRelative$worktree} config $fileOption --replace-all $section.$key $value" >&2

  git ${worktree:+ -C $topRelative$worktree} config $fileOption --replace-all "$section.$key" "$value"
  ret=$?

  return $ret
}


##################################################### GETTING #################################################
get_lego_setting_mode() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  local section="$2"
  local mode="$3"
  local worktree="${4:-.}"
  local value

  if [[ "$mode" == "solo" ]] ; then
    value=$( get_lego_setting_concrete "$1" "$section" "$worktree")
  elif [[ "$mode" == "versioned" ]] ; then
    value=$( get_lego_setting_concrete "$1" "$section" "$worktree" "-f .gitlego" )
#    if [[ -z "$value" && -z ${section##submodule.*} ]]; then
#      value=$( get_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitmodules" )
#    fi
  fi
#  echo "$value" >&2
  echo "$value"
}


get_lego_setting() {
#echo "$FUNCNAME()" $@ >&2
  local key="$1"
  local section="${2:-core}"
  local worktree="${3:-.}"
  local value=$( get_lego_setting_concrete "$key" "$section" "$worktree" "-f .gitlego" )
#  [[ -z "$value" && -z ${section##submodule*} ]] && value=$( get_lego_setting_concrete "$1" "${section}" "$worktree" "-f .gitmodules")
  [[ -z "$value" ]] && value=$( get_lego_setting_concrete "$1" "$section" "$worktree" )
#  [[ -z value ]] || value=$( get_lego_setting_concrete $1 ${section} "$worktree" "--local" } )
#  [[ -z value ]] && value=$( get_lego_setting_concrete $1 ${section} "$worktree" "--global"} )
#  [[ -z value ]] && value=$( get_lego_setting_concrete $1 ${section} "$worktree" "--system"} )
  echo "$value"
}


##
get_lego_setting_concrete() {
#echo "$FUNCNAME()" $@ >&2
#pwd >&2
  local key="$1"
  [[ -z "$key" ]] && panic "$FUNCNAME() missing setting name"
  local section="${2:-core}"
  local worktree="$3"
  local fileOption="${4:---}"

  if [[ "$worktree" == "." ]]; then
    unset worktree
  fi


  if [[ -z "${fileOption##--*}" && "$section" == "core" ]] ; then
    section="lego"
  elif [[ -n "${fileOption##--*}" &&  "$section" == "lego" ]] ; then
    section="core"
  fi

  if [[ "$fileOption" == "--" ]]; then
    unset fileOption
  fi

  local topRelative
  if [[ -n "$worktree" ]]; then
    topRelative=$( git -C "$worktree" rev-parse --show-cdup 2>/dev/null )
  fi

  echo $(git ${worktree:+ -C $topRelative$worktree} config ${fileOption} --get "${section}.$key" 2>/dev/null)
}


##
get_lego_mode() {
  local verbose="${1:-0}"
  local moduleFilePath="${2:-.}"

  pushd "$moduleFilePath" &>/dev/null

  local mode=$( get_lego_setting "mode")

  local implicit=0
  local results=()
  if [[ -z "$mode" ]] ; then
    mode=$( investigate_lego_mode )
    implicit=1
  fi
  results+=("$mode")
  if [[ "$verbose" == 1 ]] ; then
    results+=("${implicit}")
  fi
  popd &>/dev/null
  echo "${results[@]}"
}

normalize_blob_revision() {
  local ret=0
  local levelRevision="$1"
  local levelType="$2"

  [[ -z "$levelRevision" ]] && ( ret=2; dieMsg="$FUNCNAME(): missing parameter 'revision'" )

  local blobRevision="$levelRevision"
  if [[ "$levelType" == "branch" ]]; then
    if [[ -n "$levelRevision" ]]; then
      local isBranchRemote=$( is_branch_remote "$levelRevision" )

      if (( ! "$isBranchRemote" )); then
        local untrackedBranches=($( retrieve_untracked_remote_branches 1))
        for branch in "${untrackedBranches[@]}"; do
          if [[ "$branch" == "$levelRevision" ]]; then
            blobRevision="${globals[$G_LEGO_REMOTE]}/$levelRevision"
            break
          fi
        done
      fi
    fi
  elif [[ "$levelType" == "pinned" ]]; then
    git rev-parse --no-revs "tags/$levelRevision"
    local isTag=$?
    if (( ! "$isTag" )) ; then
    #
    # Workaround of bug
    #
    # .
    # $ git cat-file -s --allow-unknown-type tags//extjs-6.5.2:.gitmodules
    # fatal: Not a valid object name tags\\extjs-6.5.2;.gitmodules
    #
    # This bug prevents to define tag and branch with same name
    #
    # Same for git config
    # $ git config --blob heads/master:.gitmodules submodule.icomoon.url
    # error: unable to resolve config blob 'heads\master;.gitmodules'
    #
      blobRevision="$levelRevision"
#      blobRevision="tags/$levelRevision"
    fi
  fi
  echo "$blobRevision"
  return "$ret"
}

is_branch_remote() {
  local ret=0
  local branch="$1"
  local isRemote=0
  local legoRemote="${globals[$G_LEGO_REMOTE]}"

  [[ -z "$branch" ]] && ret=1
  if [[ "${branch#$legoRemote/}" != "$branch" || "${branch#remotes/$legoRemote/}" != "$branch" || "${branch#refs/remotes/$legoRemote/}" != "$branch" ]]; then
    isRemote=1
  fi

  echo "$isRemote"
  return "$ret"
}

retrieve_untracked_remote_branches() {
  local ret=0
  local stripped=${1:-0}
  local legoRemote="${2:-${globals[$G_LEGO_REMOTE]}}"
#  TODO think is there need?
#  [[ -z "$legoRemote" ]] && ( ret=2; dieMsg="Lego remote for is not set")

  local currentBranches=() remoteBranches=()
  while read -a branch; do
    if [[ "${branch[0]}" == "*" ]]; then
      currentBranches+=("${branch[1]}")
    else
      currentBranches+=("${branch[0]}")
    fi
  done < <(git branch --list | grep -v HEAD)

  while read rBranch; do
    if [[ "${rBranch#${legoRemote}/}" != "$rBranch" ]]; then
      local strippedBranch="${rBranch#${legoRemote}/}"

      local found=0
      for branch in "${currentBranches[@]}"; do
        if [[ "$strippedBranch" == "$branch" ]]; then
            found=1
            break;
        fi
      done
      if (( ! "$found" )); then
        if (( "$stripped" )); then
          remoteBranches+=("$strippedBranch")
        else
          remoteBranches+=("$rBranch")
        fi
      fi
    fi
  done < <(git branch -r | grep -v HEAD)

  echo "${remoteBranches[@]}"
  return "$ret"
}



investigate_lego_mode() {
  local mode
#  local ambiguous
  local module value
  local moduleFilePath="${1:-.}"
  local headed

  if [[ -z "$mode" ]] ; then
    if [[ -e "$moduleFilePath/.gitlego" ]] ; then
      mode=versioned
    fi

    if [[ -e "${moduleFilePath}/.gitmodules" ]] ; then
      while read module value; do
        mode=solo
        break
      done < <(git config --get-regexp "submodule.*.refname" | sed -E "s/submodule\.(.*)\.refname/\1/")
    fi
  fi

#  popd &>/dev/null
  echo "${mode:-empty}"
}


check_ambiguous_lego_mode() {
  local val=$1
  local prevVal=$2
  if [[ -n $prevVal ]] && [[ $val != $prevVal ]] ; then
    echo 1
  else
    echo 0
  fi
}


## EXTERNAL
#   updateManagedRef
#   attainOnCheckout
#   doForce
#
checkout_level () {
echo "$FUNCNAME()" $@ >&2; pwd >&2

  local ret=0

  local revision="$1"
  local revisionType="$2"
  local moduleName="$3"
  local modulePath="$4"
  local levelPath="$5"
  local parentRefName="$6"
  local parentRefType="$7"
  local moduleLocalPath="${8:-.}"

  local topLevelModule=1

  if [[ "$revision" == "-" ]]; then
    topLevelModule=0
  fi

  local parentFilePath="$9"

  if [[ -z "$parentRefName" && "$revision" != "-" && -n "$revision" ]]; then
    parentRefName="$revision"
  fi

  if [[ -z "$parentRefType" && "$revisionType" != "-" && -n "$revisionType"  ]]; then
    parentRefType="$revisionType"
  fi

  if [[ -n "$parentRefName" && -z "$parentRefType" ]]; then
    parentRefType=$( get_reftype_of_refname "$parentRefName" )
  fi

  local refType="$revisionType"
  local blobRevision="$revision"

  if (( ! "$attainOnCheckout" )) && (( ! "$topLevelModule" )); then
    local moduleCommit=( $( git cat-file -p HEAD | grep -E "^tree [[:xdigit:]]{40}$" | cut -d' ' -f2 | xargs git cat-file -p | grep -E "^160000\s*commit\s*[[:xdigit:]]{40}\s*${moduleName}" ) )
    ret=$?

    blobRevision="${moduleCommit[2]}"

#      revision=$( git_submodule_blob_sha "$moduleName" )
  fi

  pushd "$levelPath" &>/dev/null
  ret=$?

  (( "$ret" )) && return "$ret"

  local modulesBefore=()
  local modulePathsBefore=()
  local modulesAfter=()
  local refnamesAfter=()
  local modulesNamesAfter=()
  local modulePathsAfter=()
  local hashesAfter=()
  local addedModules=()
  local deletedModules=()
  local movedModules=()
  local postBlobModules=()
  local postBlobRefs=()

  local noSubmodules noLego

  read initialized checkoutRef < <(module_info "$modulePath" "initialized" "checkout" )

  if [[ "$initialized" == 1 ]]; then

    # TODO in rare situation checkout reference is missed in the repo, ie. removed tag, etc
    local missedReference=0
    if [[ -n "$checkoutRef" && "$checkoutRef" != "-" && "$attainOnCheckout" == 1 ]]; then
      read revision refType  < <( evaluate_refname "$checkoutRef" )
      ret=$?
      [[ "$revision" == "$NA" ]] && missedReference=1
    fi

    if [[ "$revision" != "-" && "$ret" == 0 && "$attainOnCheckout" == 1 && "$missedReference" == 0 ]]; then
      blobRevision=$( normalize_blob_revision "$revision" "$refType")
      ret=$?
    fi

    noSubmodules=$(git cat-file -s "$blobRevision":.gitmodules &>/dev/null; echo $?)
    noLego=$(git cat-file -s "$blobRevision":.gitlego &>/dev/null; echo $?)

    if (( ! $noSubmodules )) && (( ! $ret )); then
      while read -a module; do
        local blobRefName
        local after="${module[0]}"
        modulesNamesAfter+=("$after")
        # modulesAfter keeps module local path instead of just module name
        modulesAfter+=("${module[1]}")
        local pathAfter="${modulePath}"
        [[ "${pathAfter:-1}" != "/" ]] && pathAfter+="/"
        pathAfter+="${after}"
        modulePathsAfter+=("$pathAfter")
        local notUpdated

        if (( ! $noLego )); then
          blobRefName=$( git config --blob ${blobRevision}:.gitlego "submodule.$after.refname" 2>/dev/null )
          blobRefName="${blobRefName:--}"
          refnamesAfter+=("$blobRefName")
          update_module_cache "$pathAfter" "g_checkout_refnames" "$blobRefName"
          notUpdated=$?
          if (( "$notUpdated" )); then
            postBlobModules+=("$pathAfter")
            postBlobRefs+=("$blobRefName")
          fi
        else
          update_module_cache "$pathAfter" "g_module_managed" "unmanaged" "g_managed_refnames" "$NA"
#          notUpdated=$?
        fi
      done < <(git config --blob ${blobRevision}:.gitmodules --get-regexp "submodule.*.path" 2>/dev/null | sed -E "s/submodule\.(.*)\.path/\1/" )
    fi

    local found
    local moduleIndex=0

    while read -a module; do
      local before="${module[0]}"
      local localPath="${module[1]}"
      modulesBefore+=("$localPath")
      local pathBefore="$modulePath"
      [[ "${pathBefore:-1}" != "/" ]] && pathBefore+="/"
      pathBefore+="$before"
      modulePathsBefore+=("$pathBefore")

      found=0
      if (( ! $noSubmodules )); then
        local pathAfter
        for pathAfter in "${modulePathsAfter[@]}"; do
          if [[ "$pathAfter" == "$pathBefore" ]]; then
            found=1
            break
          fi
        done
      fi

      if (( ! $found )); then
        deletedModules+=("$pathBefore")
        local DELETED_STATUS=()
        pushd "$localPath" &>/dev/null
        module_porcelain_status "$pathBefore" "checkout" "DELETED_STATUS"
        popd  &>/dev/null

        if [[ 0 == "$doForce" && ( 1 == "${DELETED_STATUS[$MS_COMMITABLE]}" || 1 == "${DELETED_STATUS[$MS_UNTRACKED]}" || 1 == "${DELETED_STATUS[$MS_PUSHABLE]}" ) ]]; then
          dieMsg+="Module '$before' (maybe others as well) has not committed or not pushed changes, but intended to be deleted as it does not exists in revision '$revision'"
          return 1
        else
          if [[ "${DELETED_STATUS[$MS_UNINITIALIZED]}" == 0 ]]; then
            git submodule deinit -- "$localPath"
          else
            rm -rf "$localPath" &>/dev/null
          fi
        fi

#      else
#        local foundPath="${modulePathsAfter[$moduleIndex]}"
#        if [[ "$foundPath" != "$localPath" ]]; then
#          movedModules+=("$localPath")
#        fi
      fi
      moduleIndex=$(( $moduleIndex + 1 ))
    done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")


    if (( ! $noSubmodules )); then
      moduleIndex=0
      local pathAfter pathBefore
      for pathAfter in "${modulePathsAfter[@]}"; do
        local after="${modulesAfter[$moduleIndex]}"

        found=0
        for pathBefore in "${modulePathsBefore[@]}"; do
          if [[ "$pathBefore" == "$pathAfter" ]]; then
            found=1
            break
          fi
        done

        if (( ! $found )); then
          addedModules+=("$after")
        fi

        moduleIndex=$(( $moduleIndex + 1 ))
      done
    fi

    if [[ "$modulePath" != "/" && -n "$moduleLocalPath" && "$revision" == "-" ]]; then
      git -C "$parentFilePath" submodule update -- "$moduleLocalPath"
      ret=$?

      # module sha have to be changed in cache arrays
      local sha=$( git rev-parse HEAD )
      update_module_cache "$modulePath" "g_module_shas" "$sha"
    fi

#    echo "before: ${modulesBefore[@]}" >&2
#    echo "paths before: ${modulePathsBefore[@]}" >&2
#    echo "after: ${modulesAfter[@]}" >&2
#    echo "names after: ${modulesNamesAfter[@]}" >&2
#    echo "paths after: ${modulePathsAfter[@]}" >&2
#    echo "to add: ${addedModules[@]}" >&2
#    echo "to delete: ${deletedModules[@]}" >&2


   module_porcelain_status "$modulePath" "checkout"

    if [[ "$revision" == "-" && "$attainOnCheckout" == 1 ]]; then
      local type
      local checkoutRefName="${MODULE_STATUS[$MS_CHECKOUT_REFNAME]}"
      local checkoutRefType="${MODULE_STATUS[$MS_CHECKOUT_REFTYPE]}"

      if [[ -z "$checkoutRefName" || -z "$checkoutRefType" || "$checkoutRefName" == "-" || "$checkoutRefName" == "$NA" ]]; then
        # TODO auto-attain setting/parameter ??
        local guessedRefnames=()
        read revision type < <( evaluate_attain_hint  "$parentRefName" "$parentRefType" )
        type=$( ref_type_index "$type")
      else
        MODULE_STATUS[$MS_UNMANAGED]=0
        revision="$checkoutRefName"
        type="$checkoutRefType"
      fi

      MODULE_STATUS["$MS_MANAGED_REFNAME"]="$revision"
      MODULE_STATUS["$MS_MANAGED_REFTYPE"]="$type"
    fi

    if (( ! $ret )); then
      local addedFound
      local beforeIndex afterIndex
      local added deleted before subModule before pathAdded

      if [[ -n "${MODULE_STATUS[$MS_MANAGED_REFNAME]}" && "$revision" == "-" && "${MODULE_STATUS[$MS_UNMANAGED]}" == 0 ]]; then
        revision="${MODULE_STATUS[$MS_MANAGED_REFNAME]}"
        refTypeIndex="${MODULE_STATUS[$MS_MANAGED_REFTYPE]}"
        refType="${G_REFTYPE_TOKENS[$refTypeIndex]}"
      fi

      if [[ -n "$revision" && "$revision" != "$NA" && -n "$refType" && "$refType" != "-" && \
            (("$refType" != "sha" && "$attainOnCheckout" == 1) || "$topLevelModule" == 1) ]]; then

        git checkout "$revision"
        ret=$?

        if (( $ret )); then
          dieMsg="Unrecoverable error by checkout $revision for module $moduleName ($modulePath)"
        else
          if [[ "$modulePath" != "/" && ( "$updateManagedRef" == 1 || "$topLevelModule" == 1) ]]; then
            read legoMode modeImplicit < <( get_lego_mode "1" "$parentFilePath" )

            if [[ "$legoMode" != "versioned" ]]; then
              legoMode="solo"
            fi
            persist_attain_hint "0" "$moduleName" "$revision" "$refType" "$legoMode"
            ret=$?
          fi
        fi

        if (( ! "$ret" )); then
          local index=0
          local doUpdateInit=0
          local doAppendNewModule=0
          local recreatedModules=()

          local pathAfter

          for pathAfter in "${modulePathsAfter[@]}"; do
            local localPath="${modulesAfter[$index]}"
            local afterName="${modulesNamesAfter[$index]}"
            doUpdateInit=0
            local doRecreateCache=0

            initialized=$(module_info "$pathAfter" "initialized")

            if [[ -z "$initialized" || "$initialized" == 0 ]]; then
              git submodule update --init -- "$localPath"
              ret=$?
              if [[ -z "$initialized" ]]; then
                # 'module' is an external array is being used in investigate_module function
                local module=("$afterName")
                module+=("$localPath")
                local subModulePath="$modulePath"
                [[ "${subModulePath:(-1)}" != "/" ]] && subModulePath+="/"
                subModulePath+="$afterName"
                investigate_module "$afterName" "$localPath" "$subModulePath"

                cache_module_descriptor "${module[@]}"

              else
                update_module_cache "$pathAfter" "g_module_inited" 1
                doRecreateCache=1
              fi
#set -x
              if (( "${#postBlobModules[@]}" )); then
                local blobIndex=0
                for blobModule in "${postBlobModules[@]}"; do

                  if [[ "$pathAfter" == "$blobModule" ]]; then
                    local blobRef="${postBlobRefs[$blobIndex]}"
                    update_module_cache "$pathAfter" "g_checkout_refnames" "$blobRef"
                    doRecreateCache=1
                  fi

                  blobIndex=$(( $blobIndex + 1 ))
                done
              fi
              if (( "$doRecreateCache" )); then
                recreatedModules+=("$pathAfter")
              fi
#set +x

            fi

            index=$(( $index + 1 ))
          done

          if (( "${#recreatedModules[@]}" )); then
            recreate_modules_cache "${recreatedModules[@]}"
          fi

          if [ -f .gitmodules ]; then
            if (( ! "$topLevelModule" )); then
              parentRefName="${MODULE_STATUS[$MS_MODULE_REFNAME]}"
              parentRefTypeIndex="${MODULE_STATUS[$MS_DETACHED]}"
              parentRefType="${G_REFTYPE_TOKENS[$parentRefTypeIndex]}"
            fi
            while read -a module; do
              local subModule="${module[0]}"
              local localPath="${module[1]}"
              subRepoPath="$levelPath/$localPath"

              local subModulePath="$modulePath"
              [[ ${subModulePath:(-1)} != "/" ]] && subModulePath+="/"
              subModulePath+="$subModule"

              checkout_level "-" "-" "$subModule" "$subModulePath" "$subRepoPath" "$parentRefName" "$parentRefType" "$localPath" "$levelPath"

            done < <(git config -f .gitmodules --get-regexp "submodule.*.path" | sed -E "s/submodule\.(.*)\.path/\1/")
          fi
        fi
      fi
    else
      die "$dieMsg"
    fi
    popd &>/dev/null
  fi
#if [[ $4 == "/ext/packages/icomoon" ]]; then
#  set +x
#fi
}  ## of checkout_level



  ######################################################################################################################
  ############################################  MAIN SCRIPT  ###########################################################
  ######################################################################################################################


# The sed expression here replaces all backslashes by forward slashes.
# This helps our Windows users, while not bothering our Unix users.
export GITLEGO_DIR=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")

usage() {
  local subcommand="${1:-<subcommand>}"
  cat << EOF
    git-lego is a git extension to ease dealing with git submodules (installed in ${GITLEGO_DIR})
    Usage: git lego [<global-options>] <subcommand> [<subcommand arguments> ...]
    Try 'git lego --help' to list all git-lego commands
    or 'git lego $subcommand --help' for more details
EOF
}


declare SUBCOMMAND


# delegate not recognized (not common) attributes further to command
typeset raw_args=()
typeset g_extra_git_params=()

global_parse_args() {
#echo "$FUNCNAME()" "$@" >&2
  local potential_subcommand
  local found=0
  local doGlobalParam=0
  local stopOptions=0

#  local VERSION="0.1"

  while [[ -n "$1" ]]; do
    if (( $stopOptions )); then
      g_extra_git_params+=("$1")
    else
      case "$1" in
        gc)
          # preserve using token as an argument
          if [[ -z "$SUBCOMMAND" ]]; then
            SUBCOMMAND="generic"
            GENERIC_ACTION="$1"
          else
            die "wrong command $1"
          fi
          ;;

        --)
          stopOptions=1
          ;;

        --version)
          SUBCOMMAND="config"
          raw_args+=("--version")
          break
          ;;

        --pinned)
          pinnedParam=1
          ;;
        --no-pinned)
          pinnedParam=0
          ;;

        --initial-path)
          if [[ -z "$initialPath" ]]; then
            if [[ -z "$2" ]]; then
              die_missed_param_value "$1"
            else
              initialPath="$2"
              shift
            fi
          else
            die_parameter_duplicated "$1"
          fi
          ;;

        --initial-path=*)
          if [[ -z "$initialPath" ]]; then
            initialPath="${1#*=}"
            if [[ -z "$initialPath" ]]; then
              die_missed_param_value "$1"
            fi
          else
            die_parameter_duplicated "$1"
          fi
          ;;

        --*)
          raw_args+=("$1")
          ;;

        -*)
          local getOpt=${1:1}
          for (( n=0; n < ${#getOpt}; n++ ))
          do
            raw_args+=("-${getOpt:n:1}")
          done
          ;;

        *)
          if [[ -z "$SUBCOMMAND" ]]; then
            if [ -e "$GITLEGO_DIR/git-lego-$1" ]; then
              SUBCOMMAND="$1"
              found=1
            else
              if [[ -z "$potential_subcommand" ]]; then
                potential_subcommand="$1"
              else
                raw_args+=("$1")
              fi
            fi
          else
            raw_args+=("$1")
          fi
        ;;
      esac
    fi

    shift
  done

  if [[ -z "$SUBCOMMAND" && -n "$potential_subcommand" ]]; then
    SUBCOMMAND="$potential_subcommand"
  fi
}


pinned_metrics() {
#echo "$FUNCNAME()" $@ >&2
  local command="$1"

  local results=()
  local pinnedPolicy
  local pinnedFinal
  local localPinnedParam="$pinnedParam"
  local pinnedSetting
  local pinnedDefault

  case "$command" in
    status|clone|push|checkout)
      pinnedPolicy=0
      ;;
    *)
      pinnedPolicy=1
  esac

  results+=("$pinnedPolicy")

  if (( "$pinnedPolicy" )); then
    case "$command" in
      commit|checkout)
        pinnedDefault=1
        ;;
      *)
        pinnedDefault=0
    esac
  fi

  if [[ "${localPinnedParam:-unset}" != "unset" ]]; then
    pinnedFinal="$localPinnedParam"
  else
      local section="command.${command}"
      local pinnedSetting=$( get_lego_setting_mode "pinned" "$section" "solo" )
      if [[ "${pinnedSetting:-unset}" != "unset" ]]; then
        pinnedFinal="$pinnedSetting"
      else
        pinnedFinal="$pinnedDefault"
      fi
  fi

  results+=("${pinnedFinal:-2}")
  results+=("${localPinnedParam:-2}")
  results+=("${pinnedSetting:-2}")

  results+=("$pinnedDefault")

  echo "${results[@]}"
}

#declare moduleName moduleFilePath
main() {
	if [ $# -lt 1 ]; then
		usage
		exit 1
	fi

  global_parse_args "$@"

	if [ ! -e "$GITLEGO_DIR/git-lego-$SUBCOMMAND" ]; then
	  cw_echo "wrong command '$SUBCOMMAND'"
		usage
		exit 1
  else
    set -- "${raw_args[@]}"
	fi

  FLAGS_PREFIX="${0##*/} $SUBCOMMAND"

	# load main script where
	#
	#     1) specific command's parameters are parsing
	#     2) initialPath is detected
	#     3) umbrella_bootstrap is called
	#
	. "$GITLEGO_DIR/git-lego-$SUBCOMMAND"

  local defInitPath="."
  # if
  if type default_init_path_callback >/dev/null 2>&1; then
    defInitPath=$( default_init_path_callback "$SUBCOMMAND" "${raw_args[@]}" )
  fi

  if [[ "$pinnedPolicy" == 0 && -n "$pinnedParam" ]]; then
    cw_echo "Warning command '$SUBCOMMAND' not intended to consume --[no-]pinned parameter"
  fi

  modulePath=$( resolve_module_path "$initialPath" "$defInitPath" )
  if [[ -n "$modulePath" ]]; then
    read moduleName moduleFilePath moduleLocalPath moduleInitialized moduleGitDir moduleLegoMode < \
        <( module_info "$modulePath" "name" "path" "local" "initialized" "gitdir" "lego_mode")

    read pinnedPolicy pinnedFinal pinnedParam pinnedSetting pinnedDefault < <( pinned_metrics "$SUBCOMMAND" "${raw_args[@]}" )

#    echo "pinnedPolicy $pinnedPolicy pinnedFinal $pinnedFinal pinnedParam $pinnedParam pinnedSetting $pinnedSetting pinnedDefault $pinnedDefault"

  	splash "$modulePath"
  fi

	SUBACTION="default"
	# Particular script can figure out a specific action depends on arguments or other circumstances.
	# In this case it should define dispatch_subaction function and echo'ing required action.
	# If dispatch_subaction returns empty string - default is using
	if type "dispatch_subaction" >/dev/null 2>&1; then
		local dispatched=$( dispatch_subaction "$@" )
		if [[ -n "$dispatched" ]]; then
		  SUBACTION="$dispatched"
		fi
	fi

	if ! type "cmd_$SUBACTION" >/dev/null 2>&1; then
		warn "Unknown subcommand: '$SUBACTION'"
		usage "$SUBCOMMAND"
		exit 1
	fi

  cmd_$SUBACTION "$@"
}

main "$@"
